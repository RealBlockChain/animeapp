(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/encodeurl/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module exports.
 * @public
 */ module.exports = encodeUrl;
/**
 * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
 * and including invalid escape sequences.
 * @private
 */ var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
/**
 * RegExp to match unmatched surrogate pair.
 * @private
 */ var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
/**
 * String to replace unmatched surrogate pair with.
 * @private
 */ var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2';
/**
 * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
 *
 * This function will take an already-encoded URL and encode all the non-URL
 * code points. This function will not encode the "%" character unless it is
 * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
 * be encoded as `%25foo`).
 *
 * This encode is meant to be "safe" and does not throw errors. It will try as
 * hard as it can to properly encode the given URL, including replacing any raw,
 * unpaired surrogate pairs with the Unicode replacement character prior to
 * encoding.
 *
 * @param {string} url
 * @return {string}
 * @public
 */ function encodeUrl(url) {
    return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
}
}}),
"[project]/node_modules/escape-html/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */ 'use strict';
/**
 * Module variables.
 * @private
 */ var matchHtmlRegExp = /["'&<>]/;
/**
 * Module exports.
 * @public
 */ module.exports = escapeHtml;
/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */ function escapeHtml(string) {
    var str = '' + string;
    var match = matchHtmlRegExp.exec(str);
    if (!match) {
        return str;
    }
    var escape;
    var html = '';
    var index = 0;
    var lastIndex = 0;
    for(index = match.index; index < str.length; index++){
        switch(str.charCodeAt(index)){
            case 34:
                escape = '&quot;';
                break;
            case 38:
                escape = '&amp;';
                break;
            case 39:
                escape = '&#39;';
                break;
            case 60:
                escape = '&lt;';
                break;
            case 62:
                escape = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escape;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
}}),
"[project]/node_modules/parseurl/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ var url = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/native-url/index.js [app-client] (ecmascript)");
var parse = url.parse;
var Url = url.Url;
/**
 * Module exports.
 * @public
 */ module.exports = parseurl;
module.exports.original = originalurl;
/**
 * Parse the `req` url with memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */ function parseurl(req) {
    var url = req.url;
    if (url === undefined) {
        // URL is undefined
        return undefined;
    }
    var parsed = req._parsedUrl;
    if (fresh(url, parsed)) {
        // Return cached URL parse
        return parsed;
    }
    // Parse the URL
    parsed = fastparse(url);
    parsed._raw = url;
    return req._parsedUrl = parsed;
}
;
/**
 * Parse the `req` original url with fallback and memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */ function originalurl(req) {
    var url = req.originalUrl;
    if (typeof url !== 'string') {
        // Fallback
        return parseurl(req);
    }
    var parsed = req._parsedOriginalUrl;
    if (fresh(url, parsed)) {
        // Return cached URL parse
        return parsed;
    }
    // Parse the URL
    parsed = fastparse(url);
    parsed._raw = url;
    return req._parsedOriginalUrl = parsed;
}
;
/**
 * Parse the `str` url with fast-path short-cut.
 *
 * @param {string} str
 * @return {Object}
 * @private
 */ function fastparse(str) {
    if (typeof str !== 'string' || str.charCodeAt(0) !== 0x2f /* / */ ) {
        return parse(str);
    }
    var pathname = str;
    var query = null;
    var search = null;
    // This takes the regexp from https://github.com/joyent/node/pull/7878
    // Which is /^(\/[^?#\s]*)(\?[^#\s]*)?$/
    // And unrolls it into a for loop
    for(var i = 1; i < str.length; i++){
        switch(str.charCodeAt(i)){
            case 0x3f:
                /* ?  */ if (search === null) {
                    pathname = str.substring(0, i);
                    query = str.substring(i + 1);
                    search = str.substring(i);
                }
                break;
            case 0x09:
            /* \t */ case 0x0a:
            /* \n */ case 0x0c:
            /* \f */ case 0x0d:
            /* \r */ case 0x20:
            /*    */ case 0x23:
            /* #  */ case 0xa0:
            case 0xfeff:
                return parse(str);
        }
    }
    var url = Url !== undefined ? new Url() : {};
    url.path = str;
    url.href = str;
    url.pathname = pathname;
    if (search !== null) {
        url.query = query;
        url.search = search;
    }
    return url;
}
/**
 * Determine if parsed is still fresh for url.
 *
 * @param {string} url
 * @param {object} parsedUrl
 * @return {boolean}
 * @private
 */ function fresh(url, parsedUrl) {
    return typeof parsedUrl === 'object' && parsedUrl !== null && (Url === undefined || parsedUrl instanceof Url) && parsedUrl._raw === url;
}
}}),
"[project]/node_modules/depd/lib/browser/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module exports.
 * @public
 */ module.exports = depd;
/**
 * Create deprecate for namespace in caller.
 */ function depd(namespace) {
    if (!namespace) {
        throw new TypeError('argument namespace is required');
    }
    function deprecate(message) {
    // no-op in browser
    }
    deprecate._file = undefined;
    deprecate._ignored = true;
    deprecate._namespace = namespace;
    deprecate._traced = false;
    deprecate._warned = Object.create(null);
    deprecate.function = wrapfunction;
    deprecate.property = wrapproperty;
    return deprecate;
}
/**
 * Return a wrapped function in a deprecation message.
 *
 * This is a no-op version of the wrapper, which does nothing but call
 * validation.
 */ function wrapfunction(fn, message) {
    if (typeof fn !== 'function') {
        throw new TypeError('argument fn must be a function');
    }
    return fn;
}
/**
 * Wrap property in a deprecation message.
 *
 * This is a no-op version of the wrapper, which does nothing but call
 * validation.
 */ function wrapproperty(obj, prop, message) {
    if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
        throw new TypeError('argument obj must be object');
    }
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (!descriptor) {
        throw new TypeError('must call property on owner object');
    }
    if (!descriptor.configurable) {
        throw new TypeError('property must be configurable');
    }
}
}}),
"[project]/node_modules/setprototypeof/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/* eslint no-proto: 0 */ module.exports = Object.setPrototypeOf || (({
    __proto__: []
}) instanceof Array ? setProtoOf : mixinProperties);
function setProtoOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
}
function mixinProperties(obj, proto) {
    for(var prop in proto){
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
            obj[prop] = proto[prop];
        }
    }
    return obj;
}
}}),
"[project]/node_modules/statuses/codes.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"100\":\"Continue\",\"101\":\"Switching Protocols\",\"102\":\"Processing\",\"103\":\"Early Hints\",\"200\":\"OK\",\"201\":\"Created\",\"202\":\"Accepted\",\"203\":\"Non-Authoritative Information\",\"204\":\"No Content\",\"205\":\"Reset Content\",\"206\":\"Partial Content\",\"207\":\"Multi-Status\",\"208\":\"Already Reported\",\"226\":\"IM Used\",\"300\":\"Multiple Choices\",\"301\":\"Moved Permanently\",\"302\":\"Found\",\"303\":\"See Other\",\"304\":\"Not Modified\",\"305\":\"Use Proxy\",\"307\":\"Temporary Redirect\",\"308\":\"Permanent Redirect\",\"400\":\"Bad Request\",\"401\":\"Unauthorized\",\"402\":\"Payment Required\",\"403\":\"Forbidden\",\"404\":\"Not Found\",\"405\":\"Method Not Allowed\",\"406\":\"Not Acceptable\",\"407\":\"Proxy Authentication Required\",\"408\":\"Request Timeout\",\"409\":\"Conflict\",\"410\":\"Gone\",\"411\":\"Length Required\",\"412\":\"Precondition Failed\",\"413\":\"Payload Too Large\",\"414\":\"URI Too Long\",\"415\":\"Unsupported Media Type\",\"416\":\"Range Not Satisfiable\",\"417\":\"Expectation Failed\",\"418\":\"I'm a Teapot\",\"421\":\"Misdirected Request\",\"422\":\"Unprocessable Entity\",\"423\":\"Locked\",\"424\":\"Failed Dependency\",\"425\":\"Too Early\",\"426\":\"Upgrade Required\",\"428\":\"Precondition Required\",\"429\":\"Too Many Requests\",\"431\":\"Request Header Fields Too Large\",\"451\":\"Unavailable For Legal Reasons\",\"500\":\"Internal Server Error\",\"501\":\"Not Implemented\",\"502\":\"Bad Gateway\",\"503\":\"Service Unavailable\",\"504\":\"Gateway Timeout\",\"505\":\"HTTP Version Not Supported\",\"506\":\"Variant Also Negotiates\",\"507\":\"Insufficient Storage\",\"508\":\"Loop Detected\",\"509\":\"Bandwidth Limit Exceeded\",\"510\":\"Not Extended\",\"511\":\"Network Authentication Required\"}"));}}),
"[project]/node_modules/statuses/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ var codes = __turbopack_context__.r("[project]/node_modules/statuses/codes.json (json)");
/**
 * Module exports.
 * @public
 */ module.exports = status;
// status code to message map
status.message = codes;
// status message (lower-case) to code map
status.code = createMessageToStatusCodeMap(codes);
// array of status codes
status.codes = createStatusCodeList(codes);
// status codes for redirects
status.redirect = {
    300: true,
    301: true,
    302: true,
    303: true,
    305: true,
    307: true,
    308: true
};
// status codes for empty bodies
status.empty = {
    204: true,
    205: true,
    304: true
};
// status codes for when you should retry the request
status.retry = {
    502: true,
    503: true,
    504: true
};
/**
 * Create a map of message to status code.
 * @private
 */ function createMessageToStatusCodeMap(codes) {
    var map = {};
    Object.keys(codes).forEach(function forEachCode(code) {
        var message = codes[code];
        var status = Number(code);
        // populate map
        map[message.toLowerCase()] = status;
    });
    return map;
}
/**
 * Create a list of all status codes.
 * @private
 */ function createStatusCodeList(codes) {
    return Object.keys(codes).map(function mapCode(code) {
        return Number(code);
    });
}
/**
 * Get the status code for given message.
 * @private
 */ function getStatusCode(message) {
    var msg = message.toLowerCase();
    if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
        throw new Error('invalid status message: "' + message + '"');
    }
    return status.code[msg];
}
/**
 * Get the status message for given code.
 * @private
 */ function getStatusMessage(code) {
    if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
        throw new Error('invalid status code: ' + code);
    }
    return status.message[code];
}
/**
 * Get the status code.
 *
 * Given a number, this will throw if it is not a known status
 * code, otherwise the code will be returned. Given a string,
 * the string will be parsed for a number and return the code
 * if valid, otherwise will lookup the code assuming this is
 * the status message.
 *
 * @param {string|number} code
 * @returns {number}
 * @public
 */ function status(code) {
    if (typeof code === 'number') {
        return getStatusMessage(code);
    }
    if (typeof code !== 'string') {
        throw new TypeError('code must be a number or string');
    }
    // '403'
    var n = parseInt(code, 10);
    if (!isNaN(n)) {
        return getStatusMessage(n);
    }
    return getStatusCode(code);
}
}}),
"[project]/node_modules/inherits/inherits_browser.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        }
    };
} else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
        }
    };
}
}}),
"[project]/node_modules/toidentifier/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module exports.
 * @public
 */ module.exports = toIdentifier;
/**
 * Trasform the given string into a JavaScript identifier
 *
 * @param {string} str
 * @returns {string}
 * @public
 */ function toIdentifier(str) {
    return str.split(' ').map(function(token) {
        return token.slice(0, 1).toUpperCase() + token.slice(1);
    }).join('').replace(/[^ _0-9a-z]/gi, '');
}
}}),
"[project]/node_modules/http-errors/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ var deprecate = __turbopack_context__.r("[project]/node_modules/depd/lib/browser/index.js [app-client] (ecmascript)")('http-errors');
var setPrototypeOf = __turbopack_context__.r("[project]/node_modules/setprototypeof/index.js [app-client] (ecmascript)");
var statuses = __turbopack_context__.r("[project]/node_modules/statuses/index.js [app-client] (ecmascript)");
var inherits = __turbopack_context__.r("[project]/node_modules/inherits/inherits_browser.js [app-client] (ecmascript)");
var toIdentifier = __turbopack_context__.r("[project]/node_modules/toidentifier/index.js [app-client] (ecmascript)");
/**
 * Module exports.
 * @public
 */ module.exports = createError;
module.exports.HttpError = createHttpErrorConstructor();
module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
// Populate exports for all constructors
populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
/**
 * Get the code class of a status code.
 * @private
 */ function codeClass(status) {
    return Number(String(status).charAt(0) + '00');
}
/**
 * Create a new HTTP Error.
 *
 * @returns {Error}
 * @public
 */ function createError() {
    // so much arity going on ~_~
    var err;
    var msg;
    var status = 500;
    var props = {};
    for(var i = 0; i < arguments.length; i++){
        var arg = arguments[i];
        var type = typeof arg;
        if (type === 'object' && arg instanceof Error) {
            err = arg;
            status = err.status || err.statusCode || status;
        } else if (type === 'number' && i === 0) {
            status = arg;
        } else if (type === 'string') {
            msg = arg;
        } else if (type === 'object') {
            props = arg;
        } else {
            throw new TypeError('argument #' + (i + 1) + ' unsupported type ' + type);
        }
    }
    if (typeof status === 'number' && (status < 400 || status >= 600)) {
        deprecate('non-error status code; use only 4xx or 5xx status codes');
    }
    if (typeof status !== 'number' || !statuses.message[status] && (status < 400 || status >= 600)) {
        status = 500;
    }
    // constructor
    var HttpError = createError[status] || createError[codeClass(status)];
    if (!err) {
        // create error
        err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
        Error.captureStackTrace(err, createError);
    }
    if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        // add properties to generic error
        err.expose = status < 500;
        err.status = err.statusCode = status;
    }
    for(var key in props){
        if (key !== 'status' && key !== 'statusCode') {
            err[key] = props[key];
        }
    }
    return err;
}
/**
 * Create HTTP error abstract base class.
 * @private
 */ function createHttpErrorConstructor() {
    function HttpError() {
        throw new TypeError('cannot construct abstract class');
    }
    inherits(HttpError, Error);
    return HttpError;
}
/**
 * Create a constructor for a client error.
 * @private
 */ function createClientErrorConstructor(HttpError, name, code) {
    var className = toClassName(name);
    function ClientError(message) {
        // create the error object
        var msg = message != null ? message : statuses.message[code];
        var err = new Error(msg);
        // capture a stack trace to the construction point
        Error.captureStackTrace(err, ClientError);
        // adjust the [[Prototype]]
        setPrototypeOf(err, ClientError.prototype);
        // redefine the error message
        Object.defineProperty(err, 'message', {
            enumerable: true,
            configurable: true,
            value: msg,
            writable: true
        });
        // redefine the error name
        Object.defineProperty(err, 'name', {
            enumerable: false,
            configurable: true,
            value: className,
            writable: true
        });
        return err;
    }
    inherits(ClientError, HttpError);
    nameFunc(ClientError, className);
    ClientError.prototype.status = code;
    ClientError.prototype.statusCode = code;
    ClientError.prototype.expose = true;
    return ClientError;
}
/**
 * Create function to test is a value is a HttpError.
 * @private
 */ function createIsHttpErrorFunction(HttpError) {
    return function isHttpError(val) {
        if (!val || typeof val !== 'object') {
            return false;
        }
        if (val instanceof HttpError) {
            return true;
        }
        return val instanceof Error && typeof val.expose === 'boolean' && typeof val.statusCode === 'number' && val.status === val.statusCode;
    };
}
/**
 * Create a constructor for a server error.
 * @private
 */ function createServerErrorConstructor(HttpError, name, code) {
    var className = toClassName(name);
    function ServerError(message) {
        // create the error object
        var msg = message != null ? message : statuses.message[code];
        var err = new Error(msg);
        // capture a stack trace to the construction point
        Error.captureStackTrace(err, ServerError);
        // adjust the [[Prototype]]
        setPrototypeOf(err, ServerError.prototype);
        // redefine the error message
        Object.defineProperty(err, 'message', {
            enumerable: true,
            configurable: true,
            value: msg,
            writable: true
        });
        // redefine the error name
        Object.defineProperty(err, 'name', {
            enumerable: false,
            configurable: true,
            value: className,
            writable: true
        });
        return err;
    }
    inherits(ServerError, HttpError);
    nameFunc(ServerError, className);
    ServerError.prototype.status = code;
    ServerError.prototype.statusCode = code;
    ServerError.prototype.expose = false;
    return ServerError;
}
/**
 * Set the name of a function, if possible.
 * @private
 */ function nameFunc(func, name) {
    var desc = Object.getOwnPropertyDescriptor(func, 'name');
    if (desc && desc.configurable) {
        desc.value = name;
        Object.defineProperty(func, 'name', desc);
    }
}
/**
 * Populate the exports object with constructors for every error class.
 * @private
 */ function populateConstructorExports(exports, codes, HttpError) {
    codes.forEach(function forEachCode(code) {
        var CodeError;
        var name = toIdentifier(statuses.message[code]);
        switch(codeClass(code)){
            case 400:
                CodeError = createClientErrorConstructor(HttpError, name, code);
                break;
            case 500:
                CodeError = createServerErrorConstructor(HttpError, name, code);
                break;
        }
        if (CodeError) {
            // export the constructor
            exports[code] = CodeError;
            exports[name] = CodeError;
        }
    });
}
/**
 * Get a class name from a name identifier.
 * @private
 */ function toClassName(name) {
    return name.substr(-5) !== 'Error' ? name + 'Error' : name;
}
}}),
"[project]/node_modules/ms/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
        return parse(val);
    } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch(type){
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
        return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}
}}),
"[project]/node_modules/debug/src/common.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = __turbopack_context__.r("[project]/node_modules/ms/index.js [app-client] (ecmascript)");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
                return;
            }
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') {
                // Anything else let's inspect with %O
                args.unshift('%O');
            }
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') {
                    return '%';
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) {
                    return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') {
            createDebug.init(debug);
        }
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(/\s+/g, ',').split(',').filter(Boolean);
        for (const ns of split){
            if (ns[0] === '-') {
                createDebug.skips.push(ns.slice(1));
            } else {
                createDebug.names.push(ns);
            }
        }
    }
    /**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */ function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while(searchIndex < search.length){
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
                // Match character or proceed with wildcard
                if (template[templateIndex] === '*') {
                    starIndex = templateIndex;
                    matchIndex = searchIndex;
                    templateIndex++; // Skip the '*'
                } else {
                    searchIndex++;
                    templateIndex++;
                }
            } else if (starIndex !== -1) {
                // Backtrack to the last '*' and try to match more characters
                templateIndex = starIndex + 1;
                matchIndex++;
                searchIndex = matchIndex;
            } else {
                return false; // No match
            }
        }
        // Handle trailing '*' in template
        while(templateIndex < template.length && template[templateIndex] === '*'){
            templateIndex++;
        }
        return templateIndex === template.length;
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace)=>'-' + namespace)
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        for (const skip of createDebug.skips){
            if (matchesTemplate(name, skip)) {
                return false;
            }
        }
        for (const ns of createDebug.names){
            if (matchesTemplate(name, ns)) {
                return true;
            }
        }
        return false;
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) {
            return val.stack || val.message;
        }
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;
}}),
"[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
        return true;
    }
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
    }
    let m;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    // eslint-disable-next-line no-return-assign
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) {
        return;
    }
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') {
            return;
        }
        index++;
        if (match === '%c') {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
        }
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) {
            exports.storage.setItem('debug', namespaces);
        } else {
            exports.storage.removeItem('debug');
        }
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && 'env' in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
        r = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.DEBUG;
    }
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/common.js [app-client] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};
}}),
"[project]/node_modules/etag/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
'use strict';
/**
 * Module exports.
 * @public
 */ module.exports = etag;
/**
 * Module dependencies.
 * @private
 */ var crypto = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/crypto-browserify/index.js [app-client] (ecmascript)");
var Stats = (()=>{
    const e = new Error("Cannot find module 'fs'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})().Stats;
/**
 * Module variables.
 * @private
 */ var toString = Object.prototype.toString;
/**
 * Generate an entity tag.
 *
 * @param {Buffer|string} entity
 * @return {string}
 * @private
 */ function entitytag(entity) {
    if (entity.length === 0) {
        // fast-path empty
        return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
    }
    // compute hash of entity
    var hash = crypto.createHash('sha1').update(entity, 'utf8').digest('base64').substring(0, 27);
    // compute length of entity
    var len = typeof entity === 'string' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].byteLength(entity, 'utf8') : entity.length;
    return '"' + len.toString(16) + '-' + hash + '"';
}
/**
 * Create a simple ETag.
 *
 * @param {string|Buffer|Stats} entity
 * @param {object} [options]
 * @param {boolean} [options.weak]
 * @return {String}
 * @public
 */ function etag(entity, options) {
    if (entity == null) {
        throw new TypeError('argument entity is required');
    }
    // support fs.Stats object
    var isStats = isstats(entity);
    var weak = options && typeof options.weak === 'boolean' ? options.weak : isStats;
    // validate argument
    if (!isStats && typeof entity !== 'string' && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(entity)) {
        throw new TypeError('argument entity must be string, Buffer, or fs.Stats');
    }
    // generate entity tag
    var tag = isStats ? stattag(entity) : entitytag(entity);
    return weak ? 'W/' + tag : tag;
}
/**
 * Determine if object is a Stats object.
 *
 * @param {object} obj
 * @return {boolean}
 * @api private
 */ function isstats(obj) {
    // genuine fs.Stats
    if (typeof Stats === 'function' && obj instanceof Stats) {
        return true;
    }
    // quack quack
    return obj && typeof obj === 'object' && 'ctime' in obj && toString.call(obj.ctime) === '[object Date]' && 'mtime' in obj && toString.call(obj.mtime) === '[object Date]' && 'ino' in obj && typeof obj.ino === 'number' && 'size' in obj && typeof obj.size === 'number';
}
/**
 * Generate a tag for a stat.
 *
 * @param {object} stat
 * @return {string}
 * @private
 */ function stattag(stat) {
    var mtime = stat.mtime.getTime().toString(16);
    var size = stat.size.toString(16);
    return '"' + size + '-' + mtime + '"';
}
}}),
"[project]/node_modules/fresh/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * RegExp to check for no-cache token in Cache-Control.
 * @private
 */ var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
/**
 * Module exports.
 * @public
 */ module.exports = fresh;
/**
 * Check freshness of the response using request and response headers.
 *
 * @param {Object} reqHeaders
 * @param {Object} resHeaders
 * @return {Boolean}
 * @public
 */ function fresh(reqHeaders, resHeaders) {
    // fields
    var modifiedSince = reqHeaders['if-modified-since'];
    var noneMatch = reqHeaders['if-none-match'];
    // unconditional request
    if (!modifiedSince && !noneMatch) {
        return false;
    }
    // Always return stale when Cache-Control: no-cache
    // to support end-to-end reload requests
    // https://tools.ietf.org/html/rfc2616#section-14.9.4
    var cacheControl = reqHeaders['cache-control'];
    if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
        return false;
    }
    // if-none-match takes precedent over if-modified-since
    if (noneMatch) {
        if (noneMatch === '*') {
            return true;
        }
        var etag = resHeaders.etag;
        if (!etag) {
            return false;
        }
        var matches = parseTokenList(noneMatch);
        for(var i = 0; i < matches.length; i++){
            var match = matches[i];
            if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {
                return true;
            }
        }
        return false;
    }
    // if-modified-since
    if (modifiedSince) {
        var lastModified = resHeaders['last-modified'];
        var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
        if (modifiedStale) {
            return false;
        }
    }
    return true;
}
/**
 * Parse an HTTP Date into a number.
 *
 * @param {string} date
 * @private
 */ function parseHttpDate(date) {
    var timestamp = date && Date.parse(date);
    // istanbul ignore next: guard against date.js Date.parse patching
    return typeof timestamp === 'number' ? timestamp : NaN;
}
/**
 * Parse a HTTP token list.
 *
 * @param {string} str
 * @private
 */ function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;
    // gather tokens
    for(var i = 0, len = str.length; i < len; i++){
        switch(str.charCodeAt(i)){
            case 0x20:
                /*   */ if (start === end) {
                    start = end = i + 1;
                }
                break;
            case 0x2c:
                /* , */ list.push(str.substring(start, end));
                start = end = i + 1;
                break;
            default:
                end = i + 1;
                break;
        }
    }
    // final token
    list.push(str.substring(start, end));
    return list;
}
}}),
"[project]/node_modules/send/node_modules/mime-types/mimeScore.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// 'mime-score' back-ported to CommonJS
// Score RFC facets (see https://tools.ietf.org/html/rfc6838#section-3)
var FACET_SCORES = {
    'prs.': 100,
    'x-': 200,
    'x.': 300,
    'vnd.': 400,
    default: 900
};
// Score mime source (Logic originally from `jshttp/mime-types` module)
var SOURCE_SCORES = {
    nginx: 10,
    apache: 20,
    iana: 40,
    default: 30 // definitions added by `jshttp/mime-db` project?
};
var TYPE_SCORES = {
    // prefer application/xml over text/xml
    // prefer application/rtf over text/rtf
    application: 1,
    // prefer font/woff over application/font-woff
    font: 2,
    default: 0
};
/**
 * Get each component of the score for a mime type.  The sum of these is the
 * total score.  The higher the score, the more "official" the type.
 */ module.exports = function mimeScore(mimeType, source = 'default') {
    if (mimeType === 'application/octet-stream') {
        return 0;
    }
    const [type, subtype] = mimeType.split('/');
    const facet = subtype.replace(/(\.|x-).*/, '$1');
    const facetScore = FACET_SCORES[facet] || FACET_SCORES.default;
    const sourceScore = SOURCE_SCORES[source] || SOURCE_SCORES.default;
    const typeScore = TYPE_SCORES[type] || TYPE_SCORES.default;
    // All else being equal prefer shorter types
    const lengthScore = 1 - mimeType.length / 100;
    return facetScore + sourceScore + typeScore + lengthScore;
};
}}),
"[project]/node_modules/send/node_modules/mime-types/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ var db = __turbopack_context__.r("[project]/node_modules/send/node_modules/mime-db/index.js [app-client] (ecmascript)");
var extname = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)").extname;
var mimeScore = __turbopack_context__.r("[project]/node_modules/send/node_modules/mime-types/mimeScore.js [app-client] (ecmascript)");
/**
 * Module variables.
 * @private
 */ var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var TEXT_TYPE_REGEXP = /^text\//i;
/**
 * Module exports.
 * @public
 */ exports.charset = charset;
exports.charsets = {
    lookup: charset
};
exports.contentType = contentType;
exports.extension = extension;
exports.extensions = Object.create(null);
exports.lookup = lookup;
exports.types = Object.create(null);
exports._extensionConflicts = [];
// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types);
/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function charset(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
        return mime.charset;
    }
    // default text/* to utf-8
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return 'UTF-8';
    }
    return false;
}
/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */ function contentType(str) {
    // TODO: should this even be in this module?
    if (!str || typeof str !== 'string') {
        return false;
    }
    var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;
    if (!mime) {
        return false;
    }
    // TODO: use content-type or other module
    if (mime.indexOf('charset') === -1) {
        var charset = exports.charset(mime);
        if (charset) mime += '; charset=' + charset.toLowerCase();
    }
    return mime;
}
/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function extension(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    // get extensions
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
        return false;
    }
    return exts[0];
}
/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */ function lookup(path) {
    if (!path || typeof path !== 'string') {
        return false;
    }
    // get the extension ("ext" or ".ext" or full path)
    var extension = extname('x.' + path).toLowerCase().slice(1);
    if (!extension) {
        return false;
    }
    return exports.types[extension] || false;
}
/**
 * Populate the extensions and types maps.
 * @private
 */ function populateMaps(extensions, types) {
    Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
            return;
        }
        // mime -> extensions
        extensions[type] = exts;
        // extension -> mime
        for(var i = 0; i < exts.length; i++){
            var extension = exts[i];
            types[extension] = _preferredType(extension, types[extension], type);
            // DELETE (eventually): Capture extension->type maps that change as a
            // result of switching to mime-score.  This is just to help make reviewing
            // PR #119 easier, and can be removed once that PR is approved.
            const legacyType = _preferredTypeLegacy(extension, types[extension], type);
            if (legacyType !== types[extension]) {
                exports._extensionConflicts.push([
                    extension,
                    legacyType,
                    types[extension]
                ]);
            }
        }
    });
}
// Resolve type conflict using mime-score
function _preferredType(ext, type0, type1) {
    var score0 = type0 ? mimeScore(type0, db[type0].source) : 0;
    var score1 = type1 ? mimeScore(type1, db[type1].source) : 0;
    return score0 > score1 ? type0 : type1;
}
// Resolve type conflict using pre-mime-score logic
function _preferredTypeLegacy(ext, type0, type1) {
    var SOURCE_RANK = [
        'nginx',
        'apache',
        undefined,
        'iana'
    ];
    var score0 = type0 ? SOURCE_RANK.indexOf(db[type0].source) : 0;
    var score1 = type1 ? SOURCE_RANK.indexOf(db[type1].source) : 0;
    if (exports.types[extension] !== 'application/octet-stream' && (score0 > score1 || score0 === score1 && exports.types[extension]?.slice(0, 12) === 'application/')) {
        return type0;
    }
    return score0 > score1 ? type0 : type1;
}
}}),
"[project]/node_modules/type-is/node_modules/mime-types/mimeScore.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// 'mime-score' back-ported to CommonJS
// Score RFC facets (see https://tools.ietf.org/html/rfc6838#section-3)
var FACET_SCORES = {
    'prs.': 100,
    'x-': 200,
    'x.': 300,
    'vnd.': 400,
    default: 900
};
// Score mime source (Logic originally from `jshttp/mime-types` module)
var SOURCE_SCORES = {
    nginx: 10,
    apache: 20,
    iana: 40,
    default: 30 // definitions added by `jshttp/mime-db` project?
};
var TYPE_SCORES = {
    // prefer application/xml over text/xml
    // prefer application/rtf over text/rtf
    application: 1,
    // prefer font/woff over application/font-woff
    font: 2,
    default: 0
};
/**
 * Get each component of the score for a mime type.  The sum of these is the
 * total score.  The higher the score, the more "official" the type.
 */ module.exports = function mimeScore(mimeType, source = 'default') {
    if (mimeType === 'application/octet-stream') {
        return 0;
    }
    const [type, subtype] = mimeType.split('/');
    const facet = subtype.replace(/(\.|x-).*/, '$1');
    const facetScore = FACET_SCORES[facet] || FACET_SCORES.default;
    const sourceScore = SOURCE_SCORES[source] || SOURCE_SCORES.default;
    const typeScore = TYPE_SCORES[type] || TYPE_SCORES.default;
    // All else being equal prefer shorter types
    const lengthScore = 1 - mimeType.length / 100;
    return facetScore + sourceScore + typeScore + lengthScore;
};
}}),
"[project]/node_modules/type-is/node_modules/mime-types/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ var db = __turbopack_context__.r("[project]/node_modules/type-is/node_modules/mime-db/index.js [app-client] (ecmascript)");
var extname = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)").extname;
var mimeScore = __turbopack_context__.r("[project]/node_modules/type-is/node_modules/mime-types/mimeScore.js [app-client] (ecmascript)");
/**
 * Module variables.
 * @private
 */ var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var TEXT_TYPE_REGEXP = /^text\//i;
/**
 * Module exports.
 * @public
 */ exports.charset = charset;
exports.charsets = {
    lookup: charset
};
exports.contentType = contentType;
exports.extension = extension;
exports.extensions = Object.create(null);
exports.lookup = lookup;
exports.types = Object.create(null);
exports._extensionConflicts = [];
// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types);
/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function charset(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
        return mime.charset;
    }
    // default text/* to utf-8
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return 'UTF-8';
    }
    return false;
}
/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */ function contentType(str) {
    // TODO: should this even be in this module?
    if (!str || typeof str !== 'string') {
        return false;
    }
    var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;
    if (!mime) {
        return false;
    }
    // TODO: use content-type or other module
    if (mime.indexOf('charset') === -1) {
        var charset = exports.charset(mime);
        if (charset) mime += '; charset=' + charset.toLowerCase();
    }
    return mime;
}
/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function extension(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    // get extensions
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
        return false;
    }
    return exts[0];
}
/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */ function lookup(path) {
    if (!path || typeof path !== 'string') {
        return false;
    }
    // get the extension ("ext" or ".ext" or full path)
    var extension = extname('x.' + path).toLowerCase().slice(1);
    if (!extension) {
        return false;
    }
    return exports.types[extension] || false;
}
/**
 * Populate the extensions and types maps.
 * @private
 */ function populateMaps(extensions, types) {
    Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
            return;
        }
        // mime -> extensions
        extensions[type] = exts;
        // extension -> mime
        for(var i = 0; i < exts.length; i++){
            var extension = exts[i];
            types[extension] = _preferredType(extension, types[extension], type);
            // DELETE (eventually): Capture extension->type maps that change as a
            // result of switching to mime-score.  This is just to help make reviewing
            // PR #119 easier, and can be removed once that PR is approved.
            const legacyType = _preferredTypeLegacy(extension, types[extension], type);
            if (legacyType !== types[extension]) {
                exports._extensionConflicts.push([
                    extension,
                    legacyType,
                    types[extension]
                ]);
            }
        }
    });
}
// Resolve type conflict using mime-score
function _preferredType(ext, type0, type1) {
    var score0 = type0 ? mimeScore(type0, db[type0].source) : 0;
    var score1 = type1 ? mimeScore(type1, db[type1].source) : 0;
    return score0 > score1 ? type0 : type1;
}
// Resolve type conflict using pre-mime-score logic
function _preferredTypeLegacy(ext, type0, type1) {
    var SOURCE_RANK = [
        'nginx',
        'apache',
        undefined,
        'iana'
    ];
    var score0 = type0 ? SOURCE_RANK.indexOf(db[type0].source) : 0;
    var score1 = type1 ? SOURCE_RANK.indexOf(db[type1].source) : 0;
    if (exports.types[extension] !== 'application/octet-stream' && (score0 > score1 || score0 === score1 && exports.types[extension]?.slice(0, 12) === 'application/')) {
        return type0;
    }
    return score0 > score1 ? type0 : type1;
}
}}),
"[project]/node_modules/express/node_modules/mime-types/mimeScore.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// 'mime-score' back-ported to CommonJS
// Score RFC facets (see https://tools.ietf.org/html/rfc6838#section-3)
var FACET_SCORES = {
    'prs.': 100,
    'x-': 200,
    'x.': 300,
    'vnd.': 400,
    default: 900
};
// Score mime source (Logic originally from `jshttp/mime-types` module)
var SOURCE_SCORES = {
    nginx: 10,
    apache: 20,
    iana: 40,
    default: 30 // definitions added by `jshttp/mime-db` project?
};
var TYPE_SCORES = {
    // prefer application/xml over text/xml
    // prefer application/rtf over text/rtf
    application: 1,
    // prefer font/woff over application/font-woff
    font: 2,
    default: 0
};
/**
 * Get each component of the score for a mime type.  The sum of these is the
 * total score.  The higher the score, the more "official" the type.
 */ module.exports = function mimeScore(mimeType, source = 'default') {
    if (mimeType === 'application/octet-stream') {
        return 0;
    }
    const [type, subtype] = mimeType.split('/');
    const facet = subtype.replace(/(\.|x-).*/, '$1');
    const facetScore = FACET_SCORES[facet] || FACET_SCORES.default;
    const sourceScore = SOURCE_SCORES[source] || SOURCE_SCORES.default;
    const typeScore = TYPE_SCORES[type] || TYPE_SCORES.default;
    // All else being equal prefer shorter types
    const lengthScore = 1 - mimeType.length / 100;
    return facetScore + sourceScore + typeScore + lengthScore;
};
}}),
"[project]/node_modules/express/node_modules/mime-types/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ var db = __turbopack_context__.r("[project]/node_modules/express/node_modules/mime-db/index.js [app-client] (ecmascript)");
var extname = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)").extname;
var mimeScore = __turbopack_context__.r("[project]/node_modules/express/node_modules/mime-types/mimeScore.js [app-client] (ecmascript)");
/**
 * Module variables.
 * @private
 */ var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var TEXT_TYPE_REGEXP = /^text\//i;
/**
 * Module exports.
 * @public
 */ exports.charset = charset;
exports.charsets = {
    lookup: charset
};
exports.contentType = contentType;
exports.extension = extension;
exports.extensions = Object.create(null);
exports.lookup = lookup;
exports.types = Object.create(null);
exports._extensionConflicts = [];
// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types);
/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function charset(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
        return mime.charset;
    }
    // default text/* to utf-8
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return 'UTF-8';
    }
    return false;
}
/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */ function contentType(str) {
    // TODO: should this even be in this module?
    if (!str || typeof str !== 'string') {
        return false;
    }
    var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;
    if (!mime) {
        return false;
    }
    // TODO: use content-type or other module
    if (mime.indexOf('charset') === -1) {
        var charset = exports.charset(mime);
        if (charset) mime += '; charset=' + charset.toLowerCase();
    }
    return mime;
}
/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function extension(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    // get extensions
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
        return false;
    }
    return exts[0];
}
/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */ function lookup(path) {
    if (!path || typeof path !== 'string') {
        return false;
    }
    // get the extension ("ext" or ".ext" or full path)
    var extension = extname('x.' + path).toLowerCase().slice(1);
    if (!extension) {
        return false;
    }
    return exports.types[extension] || false;
}
/**
 * Populate the extensions and types maps.
 * @private
 */ function populateMaps(extensions, types) {
    Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
            return;
        }
        // mime -> extensions
        extensions[type] = exts;
        // extension -> mime
        for(var i = 0; i < exts.length; i++){
            var extension = exts[i];
            types[extension] = _preferredType(extension, types[extension], type);
            // DELETE (eventually): Capture extension->type maps that change as a
            // result of switching to mime-score.  This is just to help make reviewing
            // PR #119 easier, and can be removed once that PR is approved.
            const legacyType = _preferredTypeLegacy(extension, types[extension], type);
            if (legacyType !== types[extension]) {
                exports._extensionConflicts.push([
                    extension,
                    legacyType,
                    types[extension]
                ]);
            }
        }
    });
}
// Resolve type conflict using mime-score
function _preferredType(ext, type0, type1) {
    var score0 = type0 ? mimeScore(type0, db[type0].source) : 0;
    var score1 = type1 ? mimeScore(type1, db[type1].source) : 0;
    return score0 > score1 ? type0 : type1;
}
// Resolve type conflict using pre-mime-score logic
function _preferredTypeLegacy(ext, type0, type1) {
    var SOURCE_RANK = [
        'nginx',
        'apache',
        undefined,
        'iana'
    ];
    var score0 = type0 ? SOURCE_RANK.indexOf(db[type0].source) : 0;
    var score1 = type1 ? SOURCE_RANK.indexOf(db[type1].source) : 0;
    if (exports.types[extension] !== 'application/octet-stream' && (score0 > score1 || score0 === score1 && exports.types[extension]?.slice(0, 12) === 'application/')) {
        return type0;
    }
    return score0 > score1 ? type0 : type1;
}
}}),
"[project]/node_modules/accepts/node_modules/mime-types/mimeScore.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// 'mime-score' back-ported to CommonJS
// Score RFC facets (see https://tools.ietf.org/html/rfc6838#section-3)
var FACET_SCORES = {
    'prs.': 100,
    'x-': 200,
    'x.': 300,
    'vnd.': 400,
    default: 900
};
// Score mime source (Logic originally from `jshttp/mime-types` module)
var SOURCE_SCORES = {
    nginx: 10,
    apache: 20,
    iana: 40,
    default: 30 // definitions added by `jshttp/mime-db` project?
};
var TYPE_SCORES = {
    // prefer application/xml over text/xml
    // prefer application/rtf over text/rtf
    application: 1,
    // prefer font/woff over application/font-woff
    font: 2,
    default: 0
};
/**
 * Get each component of the score for a mime type.  The sum of these is the
 * total score.  The higher the score, the more "official" the type.
 */ module.exports = function mimeScore(mimeType, source = 'default') {
    if (mimeType === 'application/octet-stream') {
        return 0;
    }
    const [type, subtype] = mimeType.split('/');
    const facet = subtype.replace(/(\.|x-).*/, '$1');
    const facetScore = FACET_SCORES[facet] || FACET_SCORES.default;
    const sourceScore = SOURCE_SCORES[source] || SOURCE_SCORES.default;
    const typeScore = TYPE_SCORES[type] || TYPE_SCORES.default;
    // All else being equal prefer shorter types
    const lengthScore = 1 - mimeType.length / 100;
    return facetScore + sourceScore + typeScore + lengthScore;
};
}}),
"[project]/node_modules/accepts/node_modules/mime-types/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ var db = __turbopack_context__.r("[project]/node_modules/accepts/node_modules/mime-db/index.js [app-client] (ecmascript)");
var extname = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)").extname;
var mimeScore = __turbopack_context__.r("[project]/node_modules/accepts/node_modules/mime-types/mimeScore.js [app-client] (ecmascript)");
/**
 * Module variables.
 * @private
 */ var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var TEXT_TYPE_REGEXP = /^text\//i;
/**
 * Module exports.
 * @public
 */ exports.charset = charset;
exports.charsets = {
    lookup: charset
};
exports.contentType = contentType;
exports.extension = extension;
exports.extensions = Object.create(null);
exports.lookup = lookup;
exports.types = Object.create(null);
exports._extensionConflicts = [];
// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types);
/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function charset(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
        return mime.charset;
    }
    // default text/* to utf-8
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return 'UTF-8';
    }
    return false;
}
/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */ function contentType(str) {
    // TODO: should this even be in this module?
    if (!str || typeof str !== 'string') {
        return false;
    }
    var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;
    if (!mime) {
        return false;
    }
    // TODO: use content-type or other module
    if (mime.indexOf('charset') === -1) {
        var charset = exports.charset(mime);
        if (charset) mime += '; charset=' + charset.toLowerCase();
    }
    return mime;
}
/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function extension(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    // get extensions
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
        return false;
    }
    return exts[0];
}
/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */ function lookup(path) {
    if (!path || typeof path !== 'string') {
        return false;
    }
    // get the extension ("ext" or ".ext" or full path)
    var extension = extname('x.' + path).toLowerCase().slice(1);
    if (!extension) {
        return false;
    }
    return exports.types[extension] || false;
}
/**
 * Populate the extensions and types maps.
 * @private
 */ function populateMaps(extensions, types) {
    Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
            return;
        }
        // mime -> extensions
        extensions[type] = exts;
        // extension -> mime
        for(var i = 0; i < exts.length; i++){
            var extension = exts[i];
            types[extension] = _preferredType(extension, types[extension], type);
            // DELETE (eventually): Capture extension->type maps that change as a
            // result of switching to mime-score.  This is just to help make reviewing
            // PR #119 easier, and can be removed once that PR is approved.
            const legacyType = _preferredTypeLegacy(extension, types[extension], type);
            if (legacyType !== types[extension]) {
                exports._extensionConflicts.push([
                    extension,
                    legacyType,
                    types[extension]
                ]);
            }
        }
    });
}
// Resolve type conflict using mime-score
function _preferredType(ext, type0, type1) {
    var score0 = type0 ? mimeScore(type0, db[type0].source) : 0;
    var score1 = type1 ? mimeScore(type1, db[type1].source) : 0;
    return score0 > score1 ? type0 : type1;
}
// Resolve type conflict using pre-mime-score logic
function _preferredTypeLegacy(ext, type0, type1) {
    var SOURCE_RANK = [
        'nginx',
        'apache',
        undefined,
        'iana'
    ];
    var score0 = type0 ? SOURCE_RANK.indexOf(db[type0].source) : 0;
    var score1 = type1 ? SOURCE_RANK.indexOf(db[type1].source) : 0;
    if (exports.types[extension] !== 'application/octet-stream' && (score0 > score1 || score0 === score1 && exports.types[extension]?.slice(0, 12) === 'application/')) {
        return type0;
    }
    return score0 > score1 ? type0 : type1;
}
}}),
"[project]/node_modules/ee-first/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */ 'use strict';
/**
 * Module exports.
 * @public
 */ module.exports = first;
/**
 * Get the first event in a set of event emitters and event pairs.
 *
 * @param {array} stuff
 * @param {function} done
 * @public
 */ function first(stuff, done) {
    if (!Array.isArray(stuff)) throw new TypeError('arg must be an array of [ee, events...] arrays');
    var cleanups = [];
    for(var i = 0; i < stuff.length; i++){
        var arr = stuff[i];
        if (!Array.isArray(arr) || arr.length < 2) throw new TypeError('each array member must be [ee, events...]');
        var ee = arr[0];
        for(var j = 1; j < arr.length; j++){
            var event = arr[j];
            var fn = listener(event, callback);
            // listen to the event
            ee.on(event, fn);
            // push this listener to the list of cleanups
            cleanups.push({
                ee: ee,
                event: event,
                fn: fn
            });
        }
    }
    function callback() {
        cleanup();
        done.apply(null, arguments);
    }
    function cleanup() {
        var x;
        for(var i = 0; i < cleanups.length; i++){
            x = cleanups[i];
            x.ee.removeListener(x.event, x.fn);
        }
    }
    function thunk(fn) {
        done = fn;
    }
    thunk.cancel = cleanup;
    return thunk;
}
/**
 * Create the event listener.
 * @private
 */ function listener(event, done) {
    return function onevent(arg1) {
        var args = new Array(arguments.length);
        var ee = this;
        var err = event === 'error' ? arg1 : null;
        // copy args to prevent arguments escaping scope
        for(var i = 0; i < args.length; i++){
            args[i] = arguments[i];
        }
        done(err, ee, event, args);
    };
}
}}),
"[project]/node_modules/on-finished/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
/**
 * Module exports.
 * @public
 */ module.exports = onFinished;
module.exports.isFinished = isFinished;
/**
 * Module dependencies.
 * @private
 */ var asyncHooks = tryRequireAsyncHooks();
var first = __turbopack_context__.r("[project]/node_modules/ee-first/index.js [app-client] (ecmascript)");
/**
 * Variables.
 * @private
 */ /* istanbul ignore next */ var defer = typeof setImmediate === 'function' ? setImmediate : function(fn) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(fn.bind.apply(fn, arguments));
};
/**
 * Invoke callback when the response has finished, useful for
 * cleaning up resources afterwards.
 *
 * @param {object} msg
 * @param {function} listener
 * @return {object}
 * @public
 */ function onFinished(msg, listener) {
    if (isFinished(msg) !== false) {
        defer(listener, null, msg);
        return msg;
    }
    // attach the listener to the message
    attachListener(msg, wrap(listener));
    return msg;
}
/**
 * Determine if message is already finished.
 *
 * @param {object} msg
 * @return {boolean}
 * @public
 */ function isFinished(msg) {
    var socket = msg.socket;
    if (typeof msg.finished === 'boolean') {
        // OutgoingMessage
        return Boolean(msg.finished || socket && !socket.writable);
    }
    if (typeof msg.complete === 'boolean') {
        // IncomingMessage
        return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
    }
    // don't know
    return undefined;
}
/**
 * Attach a finished listener to the message.
 *
 * @param {object} msg
 * @param {function} callback
 * @private
 */ function attachFinishedListener(msg, callback) {
    var eeMsg;
    var eeSocket;
    var finished = false;
    function onFinish(error) {
        eeMsg.cancel();
        eeSocket.cancel();
        finished = true;
        callback(error);
    }
    // finished on first message event
    eeMsg = eeSocket = first([
        [
            msg,
            'end',
            'finish'
        ]
    ], onFinish);
    function onSocket(socket) {
        // remove listener
        msg.removeListener('socket', onSocket);
        if (finished) return;
        if (eeMsg !== eeSocket) return;
        // finished on first socket event
        eeSocket = first([
            [
                socket,
                'error',
                'close'
            ]
        ], onFinish);
    }
    if (msg.socket) {
        // socket already assigned
        onSocket(msg.socket);
        return;
    }
    // wait for socket to be assigned
    msg.on('socket', onSocket);
    if (msg.socket === undefined) {
        // istanbul ignore next: node.js 0.8 patch
        patchAssignSocket(msg, onSocket);
    }
}
/**
 * Attach the listener to the message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */ function attachListener(msg, listener) {
    var attached = msg.__onFinished;
    // create a private single listener with queue
    if (!attached || !attached.queue) {
        attached = msg.__onFinished = createListener(msg);
        attachFinishedListener(msg, attached);
    }
    attached.queue.push(listener);
}
/**
 * Create listener on message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */ function createListener(msg) {
    function listener(err) {
        if (msg.__onFinished === listener) msg.__onFinished = null;
        if (!listener.queue) return;
        var queue = listener.queue;
        listener.queue = null;
        for(var i = 0; i < queue.length; i++){
            queue[i](err, msg);
        }
    }
    listener.queue = [];
    return listener;
}
/**
 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
 *
 * @param {ServerResponse} res
 * @param {function} callback
 * @private
 */ // istanbul ignore next: node.js 0.8 patch
function patchAssignSocket(res, callback) {
    var assignSocket = res.assignSocket;
    if (typeof assignSocket !== 'function') return;
    // res.on('socket', callback) is broken in 0.8
    res.assignSocket = function _assignSocket(socket) {
        assignSocket.call(this, socket);
        callback(socket);
    };
}
/**
 * Try to require async_hooks
 * @private
 */ function tryRequireAsyncHooks() {
    try {
        return (()=>{
            const e = new Error("Cannot find module 'async_hooks'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
    } catch (e) {
        return {};
    }
}
/**
 * Wrap function with async resource, if possible.
 * AsyncResource.bind static method backported.
 * @private
 */ function wrap(fn) {
    var res;
    // create anonymous resource
    if (asyncHooks.AsyncResource) {
        res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');
    }
    // incompatible node.js
    if (!res || !res.runInAsyncScope) {
        return fn;
    }
    // return bound function
    return res.runInAsyncScope.bind(res, fn, null);
}
}}),
"[project]/node_modules/range-parser/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module exports.
 * @public
 */ module.exports = rangeParser;
/**
 * Parse "Range" header `str` relative to the given file `size`.
 *
 * @param {Number} size
 * @param {String} str
 * @param {Object} [options]
 * @return {Array}
 * @public
 */ function rangeParser(size, str, options) {
    if (typeof str !== 'string') {
        throw new TypeError('argument str must be a string');
    }
    var index = str.indexOf('=');
    if (index === -1) {
        return -2;
    }
    // split the range string
    var arr = str.slice(index + 1).split(',');
    var ranges = [];
    // add ranges type
    ranges.type = str.slice(0, index);
    // parse all ranges
    for(var i = 0; i < arr.length; i++){
        var range = arr[i].split('-');
        var start = parseInt(range[0], 10);
        var end = parseInt(range[1], 10);
        // -nnn
        if (isNaN(start)) {
            start = size - end;
            end = size - 1;
        // nnn-
        } else if (isNaN(end)) {
            end = size - 1;
        }
        // limit last-byte-pos to current length
        if (end > size - 1) {
            end = size - 1;
        }
        // invalid or unsatisifiable
        if (isNaN(start) || isNaN(end) || start > end || start < 0) {
            continue;
        }
        // add range
        ranges.push({
            start: start,
            end: end
        });
    }
    if (ranges.length < 1) {
        // unsatisifiable
        return -1;
    }
    return options && options.combine ? combineRanges(ranges) : ranges;
}
/**
 * Combine overlapping & adjacent ranges.
 * @private
 */ function combineRanges(ranges) {
    var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
    for(var j = 0, i = 1; i < ordered.length; i++){
        var range = ordered[i];
        var current = ordered[j];
        if (range.start > current.end + 1) {
            // next range
            ordered[++j] = range;
        } else if (range.end > current.end) {
            // extend range
            current.end = range.end;
            current.index = Math.min(current.index, range.index);
        }
    }
    // trim ordered array
    ordered.length = j + 1;
    // generate combined range
    var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
    // copy ranges type
    combined.type = ranges.type;
    return combined;
}
/**
 * Map function to add index value to ranges.
 * @private
 */ function mapWithIndex(range, index) {
    return {
        start: range.start,
        end: range.end,
        index: index
    };
}
/**
 * Map function to remove index value from ranges.
 * @private
 */ function mapWithoutIndex(range) {
    return {
        start: range.start,
        end: range.end
    };
}
/**
 * Sort function to sort ranges by index.
 * @private
 */ function sortByRangeIndex(a, b) {
    return a.index - b.index;
}
/**
 * Sort function to sort ranges by start position.
 * @private
 */ function sortByRangeStart(a, b) {
    return a.start - b.start;
}
}}),
"[project]/node_modules/send/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
'use strict';
/**
 * Module dependencies.
 * @private
 */ var createError = __turbopack_context__.r("[project]/node_modules/http-errors/index.js [app-client] (ecmascript)");
var debug = __turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)")('send');
var encodeUrl = __turbopack_context__.r("[project]/node_modules/encodeurl/index.js [app-client] (ecmascript)");
var escapeHtml = __turbopack_context__.r("[project]/node_modules/escape-html/index.js [app-client] (ecmascript)");
var etag = __turbopack_context__.r("[project]/node_modules/etag/index.js [app-client] (ecmascript)");
var fresh = __turbopack_context__.r("[project]/node_modules/fresh/index.js [app-client] (ecmascript)");
var fs = (()=>{
    const e = new Error("Cannot find module 'fs'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var mime = __turbopack_context__.r("[project]/node_modules/send/node_modules/mime-types/index.js [app-client] (ecmascript)");
var ms = __turbopack_context__.r("[project]/node_modules/ms/index.js [app-client] (ecmascript)");
var onFinished = __turbopack_context__.r("[project]/node_modules/on-finished/index.js [app-client] (ecmascript)");
var parseRange = __turbopack_context__.r("[project]/node_modules/range-parser/index.js [app-client] (ecmascript)");
var path = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)");
var statuses = __turbopack_context__.r("[project]/node_modules/statuses/index.js [app-client] (ecmascript)");
var Stream = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
var util = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
/**
 * Path function references.
 * @private
 */ var extname = path.extname;
var join = path.join;
var normalize = path.normalize;
var resolve = path.resolve;
var sep = path.sep;
/**
 * Regular expression for identifying a bytes Range header.
 * @private
 */ var BYTES_RANGE_REGEXP = /^ *bytes=/;
/**
 * Maximum value allowed for the max age.
 * @private
 */ var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000 // 1 year
;
/**
 * Regular expression to match a path with a directory up component.
 * @private
 */ var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
/**
 * Module exports.
 * @public
 */ module.exports = send;
/**
 * Return a `SendStream` for `req` and `path`.
 *
 * @param {object} req
 * @param {string} path
 * @param {object} [options]
 * @return {SendStream}
 * @public
 */ function send(req, path, options) {
    return new SendStream(req, path, options);
}
/**
 * Initialize a `SendStream` with the given `path`.
 *
 * @param {Request} req
 * @param {String} path
 * @param {object} [options]
 * @private
 */ function SendStream(req, path, options) {
    Stream.call(this);
    var opts = options || {};
    this.options = opts;
    this.path = path;
    this.req = req;
    this._acceptRanges = opts.acceptRanges !== undefined ? Boolean(opts.acceptRanges) : true;
    this._cacheControl = opts.cacheControl !== undefined ? Boolean(opts.cacheControl) : true;
    this._etag = opts.etag !== undefined ? Boolean(opts.etag) : true;
    this._dotfiles = opts.dotfiles !== undefined ? opts.dotfiles : 'ignore';
    if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {
        throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
    }
    this._extensions = opts.extensions !== undefined ? normalizeList(opts.extensions, 'extensions option') : [];
    this._immutable = opts.immutable !== undefined ? Boolean(opts.immutable) : false;
    this._index = opts.index !== undefined ? normalizeList(opts.index, 'index option') : [
        'index.html'
    ];
    this._lastModified = opts.lastModified !== undefined ? Boolean(opts.lastModified) : true;
    this._maxage = opts.maxAge || opts.maxage;
    this._maxage = typeof this._maxage === 'string' ? ms(this._maxage) : Number(this._maxage);
    this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
    this._root = opts.root ? resolve(opts.root) : null;
}
/**
 * Inherits from `Stream`.
 */ util.inherits(SendStream, Stream);
/**
 * Emit error with `status`.
 *
 * @param {number} status
 * @param {Error} [err]
 * @private
 */ SendStream.prototype.error = function error(status, err) {
    // emit if listeners instead of responding
    if (hasListeners(this, 'error')) {
        return this.emit('error', createHttpError(status, err));
    }
    var res = this.res;
    var msg = statuses.message[status] || String(status);
    var doc = createHtmlDocument('Error', escapeHtml(msg));
    // clear existing headers
    clearHeaders(res);
    // add error headers
    if (err && err.headers) {
        setHeaders(res, err.headers);
    }
    // send basic response
    res.statusCode = status;
    res.setHeader('Content-Type', 'text/html; charset=UTF-8');
    res.setHeader('Content-Length', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].byteLength(doc));
    res.setHeader('Content-Security-Policy', "default-src 'none'");
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.end(doc);
};
/**
 * Check if the pathname ends with "/".
 *
 * @return {boolean}
 * @private
 */ SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
    return this.path[this.path.length - 1] === '/';
};
/**
 * Check if this is a conditional GET request.
 *
 * @return {Boolean}
 * @api private
 */ SendStream.prototype.isConditionalGET = function isConditionalGET() {
    return this.req.headers['if-match'] || this.req.headers['if-unmodified-since'] || this.req.headers['if-none-match'] || this.req.headers['if-modified-since'];
};
/**
 * Check if the request preconditions failed.
 *
 * @return {boolean}
 * @private
 */ SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
    var req = this.req;
    var res = this.res;
    // if-match
    var match = req.headers['if-match'];
    if (match) {
        var etag = res.getHeader('ETag');
        return !etag || match !== '*' && parseTokenList(match).every(function(match) {
            return match !== etag && match !== 'W/' + etag && 'W/' + match !== etag;
        });
    }
    // if-unmodified-since
    var unmodifiedSince = parseHttpDate(req.headers['if-unmodified-since']);
    if (!isNaN(unmodifiedSince)) {
        var lastModified = parseHttpDate(res.getHeader('Last-Modified'));
        return isNaN(lastModified) || lastModified > unmodifiedSince;
    }
    return false;
};
/**
 * Strip various content header fields for a change in entity.
 *
 * @private
 */ SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
    var res = this.res;
    res.removeHeader('Content-Encoding');
    res.removeHeader('Content-Language');
    res.removeHeader('Content-Length');
    res.removeHeader('Content-Range');
    res.removeHeader('Content-Type');
};
/**
 * Respond with 304 not modified.
 *
 * @api private
 */ SendStream.prototype.notModified = function notModified() {
    var res = this.res;
    debug('not modified');
    this.removeContentHeaderFields();
    res.statusCode = 304;
    res.end();
};
/**
 * Raise error that headers already sent.
 *
 * @api private
 */ SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
    var err = new Error('Can\'t set headers after they are sent.');
    debug('headers already sent');
    this.error(500, err);
};
/**
 * Check if the request is cacheable, aka
 * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
 *
 * @return {Boolean}
 * @api private
 */ SendStream.prototype.isCachable = function isCachable() {
    var statusCode = this.res.statusCode;
    return statusCode >= 200 && statusCode < 300 || statusCode === 304;
};
/**
 * Handle stat() error.
 *
 * @param {Error} error
 * @private
 */ SendStream.prototype.onStatError = function onStatError(error) {
    switch(error.code){
        case 'ENAMETOOLONG':
        case 'ENOENT':
        case 'ENOTDIR':
            this.error(404, error);
            break;
        default:
            this.error(500, error);
            break;
    }
};
/**
 * Check if the cache is fresh.
 *
 * @return {Boolean}
 * @api private
 */ SendStream.prototype.isFresh = function isFresh() {
    return fresh(this.req.headers, {
        etag: this.res.getHeader('ETag'),
        'last-modified': this.res.getHeader('Last-Modified')
    });
};
/**
 * Check if the range is fresh.
 *
 * @return {Boolean}
 * @api private
 */ SendStream.prototype.isRangeFresh = function isRangeFresh() {
    var ifRange = this.req.headers['if-range'];
    if (!ifRange) {
        return true;
    }
    // if-range as etag
    if (ifRange.indexOf('"') !== -1) {
        var etag = this.res.getHeader('ETag');
        return Boolean(etag && ifRange.indexOf(etag) !== -1);
    }
    // if-range as modified date
    var lastModified = this.res.getHeader('Last-Modified');
    return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
};
/**
 * Redirect to path.
 *
 * @param {string} path
 * @private
 */ SendStream.prototype.redirect = function redirect(path) {
    var res = this.res;
    if (hasListeners(this, 'directory')) {
        this.emit('directory', res, path);
        return;
    }
    if (this.hasTrailingSlash()) {
        this.error(403);
        return;
    }
    var loc = encodeUrl(collapseLeadingSlashes(this.path + '/'));
    var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc));
    // redirect
    res.statusCode = 301;
    res.setHeader('Content-Type', 'text/html; charset=UTF-8');
    res.setHeader('Content-Length', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].byteLength(doc));
    res.setHeader('Content-Security-Policy', "default-src 'none'");
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('Location', loc);
    res.end(doc);
};
/**
 * Pipe to `res.
 *
 * @param {Stream} res
 * @return {Stream} res
 * @api public
 */ SendStream.prototype.pipe = function pipe(res) {
    // root path
    var root = this._root;
    // references
    this.res = res;
    // decode the path
    var path = decode(this.path);
    if (path === -1) {
        this.error(400);
        return res;
    }
    // null byte(s)
    if (~path.indexOf('\0')) {
        this.error(400);
        return res;
    }
    var parts;
    if (root !== null) {
        // normalize
        if (path) {
            path = normalize('.' + sep + path);
        }
        // malicious path
        if (UP_PATH_REGEXP.test(path)) {
            debug('malicious path "%s"', path);
            this.error(403);
            return res;
        }
        // explode path parts
        parts = path.split(sep);
        // join / normalize from optional root dir
        path = normalize(join(root, path));
    } else {
        // ".." is malicious without "root"
        if (UP_PATH_REGEXP.test(path)) {
            debug('malicious path "%s"', path);
            this.error(403);
            return res;
        }
        // explode path parts
        parts = normalize(path).split(sep);
        // resolve the path
        path = resolve(path);
    }
    // dotfile handling
    if (containsDotFile(parts)) {
        debug('%s dotfile "%s"', this._dotfiles, path);
        switch(this._dotfiles){
            case 'allow':
                break;
            case 'deny':
                this.error(403);
                return res;
            case 'ignore':
            default:
                this.error(404);
                return res;
        }
    }
    // index file support
    if (this._index.length && this.hasTrailingSlash()) {
        this.sendIndex(path);
        return res;
    }
    this.sendFile(path);
    return res;
};
/**
 * Transfer `path`.
 *
 * @param {String} path
 * @api public
 */ SendStream.prototype.send = function send(path, stat) {
    var len = stat.size;
    var options = this.options;
    var opts = {};
    var res = this.res;
    var req = this.req;
    var ranges = req.headers.range;
    var offset = options.start || 0;
    if (res.headersSent) {
        // impossible to send now
        this.headersAlreadySent();
        return;
    }
    debug('pipe "%s"', path);
    // set header fields
    this.setHeader(path, stat);
    // set content-type
    this.type(path);
    // conditional GET support
    if (this.isConditionalGET()) {
        if (this.isPreconditionFailure()) {
            this.error(412);
            return;
        }
        if (this.isCachable() && this.isFresh()) {
            this.notModified();
            return;
        }
    }
    // adjust len to start/end options
    len = Math.max(0, len - offset);
    if (options.end !== undefined) {
        var bytes = options.end - offset + 1;
        if (len > bytes) len = bytes;
    }
    // Range support
    if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
        // parse
        ranges = parseRange(len, ranges, {
            combine: true
        });
        // If-Range support
        if (!this.isRangeFresh()) {
            debug('range stale');
            ranges = -2;
        }
        // unsatisfiable
        if (ranges === -1) {
            debug('range unsatisfiable');
            // Content-Range
            res.setHeader('Content-Range', contentRange('bytes', len));
            // 416 Requested Range Not Satisfiable
            return this.error(416, {
                headers: {
                    'Content-Range': res.getHeader('Content-Range')
                }
            });
        }
        // valid (syntactically invalid/multiple ranges are treated as a regular response)
        if (ranges !== -2 && ranges.length === 1) {
            debug('range %j', ranges);
            // Content-Range
            res.statusCode = 206;
            res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]));
            // adjust for requested range
            offset += ranges[0].start;
            len = ranges[0].end - ranges[0].start + 1;
        }
    }
    // clone options
    for(var prop in options){
        opts[prop] = options[prop];
    }
    // set read options
    opts.start = offset;
    opts.end = Math.max(offset, offset + len - 1);
    // content-length
    res.setHeader('Content-Length', len);
    // HEAD support
    if (req.method === 'HEAD') {
        res.end();
        return;
    }
    this.stream(path, opts);
};
/**
 * Transfer file for `path`.
 *
 * @param {String} path
 * @api private
 */ SendStream.prototype.sendFile = function sendFile(path) {
    var i = 0;
    var self = this;
    debug('stat "%s"', path);
    fs.stat(path, function onstat(err, stat) {
        var pathEndsWithSep = path[path.length - 1] === sep;
        if (err && err.code === 'ENOENT' && !extname(path) && !pathEndsWithSep) {
            // not found, check extensions
            return next(err);
        }
        if (err) return self.onStatError(err);
        if (stat.isDirectory()) return self.redirect(path);
        if (pathEndsWithSep) return self.error(404);
        self.emit('file', path, stat);
        self.send(path, stat);
    });
    function next(err) {
        if (self._extensions.length <= i) {
            return err ? self.onStatError(err) : self.error(404);
        }
        var p = path + '.' + self._extensions[i++];
        debug('stat "%s"', p);
        fs.stat(p, function(err, stat) {
            if (err) return next(err);
            if (stat.isDirectory()) return next();
            self.emit('file', p, stat);
            self.send(p, stat);
        });
    }
};
/**
 * Transfer index for `path`.
 *
 * @param {String} path
 * @api private
 */ SendStream.prototype.sendIndex = function sendIndex(path) {
    var i = -1;
    var self = this;
    function next(err) {
        if (++i >= self._index.length) {
            if (err) return self.onStatError(err);
            return self.error(404);
        }
        var p = join(path, self._index[i]);
        debug('stat "%s"', p);
        fs.stat(p, function(err, stat) {
            if (err) return next(err);
            if (stat.isDirectory()) return next();
            self.emit('file', p, stat);
            self.send(p, stat);
        });
    }
    next();
};
/**
 * Stream `path` to the response.
 *
 * @param {String} path
 * @param {Object} options
 * @api private
 */ SendStream.prototype.stream = function stream(path, options) {
    var self = this;
    var res = this.res;
    // pipe
    var stream = fs.createReadStream(path, options);
    this.emit('stream', stream);
    stream.pipe(res);
    // cleanup
    function cleanup() {
        stream.destroy();
    }
    // response finished, cleanup
    onFinished(res, cleanup);
    // error handling
    stream.on('error', function onerror(err) {
        // clean up stream early
        cleanup();
        // error
        self.onStatError(err);
    });
    // end
    stream.on('end', function onend() {
        self.emit('end');
    });
};
/**
 * Set content-type based on `path`
 * if it hasn't been explicitly set.
 *
 * @param {String} path
 * @api private
 */ SendStream.prototype.type = function type(path) {
    var res = this.res;
    if (res.getHeader('Content-Type')) return;
    var ext = extname(path);
    var type = mime.contentType(ext) || 'application/octet-stream';
    debug('content-type %s', type);
    res.setHeader('Content-Type', type);
};
/**
 * Set response header fields, most
 * fields may be pre-defined.
 *
 * @param {String} path
 * @param {Object} stat
 * @api private
 */ SendStream.prototype.setHeader = function setHeader(path, stat) {
    var res = this.res;
    this.emit('headers', res, path, stat);
    if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {
        debug('accept ranges');
        res.setHeader('Accept-Ranges', 'bytes');
    }
    if (this._cacheControl && !res.getHeader('Cache-Control')) {
        var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000);
        if (this._immutable) {
            cacheControl += ', immutable';
        }
        debug('cache-control %s', cacheControl);
        res.setHeader('Cache-Control', cacheControl);
    }
    if (this._lastModified && !res.getHeader('Last-Modified')) {
        var modified = stat.mtime.toUTCString();
        debug('modified %s', modified);
        res.setHeader('Last-Modified', modified);
    }
    if (this._etag && !res.getHeader('ETag')) {
        var val = etag(stat);
        debug('etag %s', val);
        res.setHeader('ETag', val);
    }
};
/**
 * Clear all headers from a response.
 *
 * @param {object} res
 * @private
 */ function clearHeaders(res) {
    for (const header of res.getHeaderNames()){
        res.removeHeader(header);
    }
}
/**
 * Collapse all leading slashes into a single slash
 *
 * @param {string} str
 * @private
 */ function collapseLeadingSlashes(str) {
    for(var i = 0; i < str.length; i++){
        if (str[i] !== '/') {
            break;
        }
    }
    return i > 1 ? '/' + str.substr(i) : str;
}
/**
 * Determine if path parts contain a dotfile.
 *
 * @api private
 */ function containsDotFile(parts) {
    for(var i = 0; i < parts.length; i++){
        var part = parts[i];
        if (part.length > 1 && part[0] === '.') {
            return true;
        }
    }
    return false;
}
/**
 * Create a Content-Range header.
 *
 * @param {string} type
 * @param {number} size
 * @param {array} [range]
 */ function contentRange(type, size, range) {
    return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size;
}
/**
 * Create a minimal HTML document.
 *
 * @param {string} title
 * @param {string} body
 * @private
 */ function createHtmlDocument(title, body) {
    return '<!DOCTYPE html>\n' + '<html lang="en">\n' + '<head>\n' + '<meta charset="utf-8">\n' + '<title>' + title + '</title>\n' + '</head>\n' + '<body>\n' + '<pre>' + body + '</pre>\n' + '</body>\n' + '</html>\n';
}
/**
 * Create a HttpError object from simple arguments.
 *
 * @param {number} status
 * @param {Error|object} err
 * @private
 */ function createHttpError(status, err) {
    if (!err) {
        return createError(status);
    }
    return err instanceof Error ? createError(status, err, {
        expose: false
    }) : createError(status, err);
}
/**
 * decodeURIComponent.
 *
 * Allows V8 to only deoptimize this fn instead of all
 * of send().
 *
 * @param {String} path
 * @api private
 */ function decode(path) {
    try {
        return decodeURIComponent(path);
    } catch (err) {
        return -1;
    }
}
/**
 * Determine if emitter has listeners of a given type.
 *
 * The way to do this check is done three different ways in Node.js >= 0.10
 * so this consolidates them into a minimal set using instance methods.
 *
 * @param {EventEmitter} emitter
 * @param {string} type
 * @returns {boolean}
 * @private
 */ function hasListeners(emitter, type) {
    var count = typeof emitter.listenerCount !== 'function' ? emitter.listeners(type).length : emitter.listenerCount(type);
    return count > 0;
}
/**
 * Normalize the index option into an array.
 *
 * @param {boolean|string|array} val
 * @param {string} name
 * @private
 */ function normalizeList(val, name) {
    var list = [].concat(val || []);
    for(var i = 0; i < list.length; i++){
        if (typeof list[i] !== 'string') {
            throw new TypeError(name + ' must be array of strings or false');
        }
    }
    return list;
}
/**
 * Parse an HTTP Date into a number.
 *
 * @param {string} date
 * @private
 */ function parseHttpDate(date) {
    var timestamp = date && Date.parse(date);
    return typeof timestamp === 'number' ? timestamp : NaN;
}
/**
 * Parse a HTTP token list.
 *
 * @param {string} str
 * @private
 */ function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;
    // gather tokens
    for(var i = 0, len = str.length; i < len; i++){
        switch(str.charCodeAt(i)){
            case 0x20:
                /*   */ if (start === end) {
                    start = end = i + 1;
                }
                break;
            case 0x2c:
                /* , */ if (start !== end) {
                    list.push(str.substring(start, end));
                }
                start = end = i + 1;
                break;
            default:
                end = i + 1;
                break;
        }
    }
    // final token
    if (start !== end) {
        list.push(str.substring(start, end));
    }
    return list;
}
/**
 * Set an object of headers on a response.
 *
 * @param {object} res
 * @param {object} headers
 * @private
 */ function setHeaders(res, headers) {
    var keys = Object.keys(headers);
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        res.setHeader(key, headers[key]);
    }
}
}}),
"[project]/node_modules/serve-static/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
'use strict';
/**
 * Module dependencies.
 * @private
 */ var encodeUrl = __turbopack_context__.r("[project]/node_modules/encodeurl/index.js [app-client] (ecmascript)");
var escapeHtml = __turbopack_context__.r("[project]/node_modules/escape-html/index.js [app-client] (ecmascript)");
var parseUrl = __turbopack_context__.r("[project]/node_modules/parseurl/index.js [app-client] (ecmascript)");
var resolve = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)").resolve;
var send = __turbopack_context__.r("[project]/node_modules/send/index.js [app-client] (ecmascript)");
var url = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/native-url/index.js [app-client] (ecmascript)");
/**
 * Module exports.
 * @public
 */ module.exports = serveStatic;
/**
 * @param {string} root
 * @param {object} [options]
 * @return {function}
 * @public
 */ function serveStatic(root, options) {
    if (!root) {
        throw new TypeError('root path required');
    }
    if (typeof root !== 'string') {
        throw new TypeError('root path must be a string');
    }
    // copy options object
    var opts = Object.create(options || null);
    // fall-though
    var fallthrough = opts.fallthrough !== false;
    // default redirect
    var redirect = opts.redirect !== false;
    // headers listener
    var setHeaders = opts.setHeaders;
    if (setHeaders && typeof setHeaders !== 'function') {
        throw new TypeError('option setHeaders must be function');
    }
    // setup options for send
    opts.maxage = opts.maxage || opts.maxAge || 0;
    opts.root = resolve(root);
    // construct directory listener
    var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
    return function serveStatic(req, res, next) {
        if (req.method !== 'GET' && req.method !== 'HEAD') {
            if (fallthrough) {
                return next();
            }
            // method not allowed
            res.statusCode = 405;
            res.setHeader('Allow', 'GET, HEAD');
            res.setHeader('Content-Length', '0');
            res.end();
            return;
        }
        var forwardError = !fallthrough;
        var originalUrl = parseUrl.original(req);
        var path = parseUrl(req).pathname;
        // make sure redirect occurs at mount
        if (path === '/' && originalUrl.pathname.substr(-1) !== '/') {
            path = '';
        }
        // create send stream
        var stream = send(req, path, opts);
        // add directory handler
        stream.on('directory', onDirectory);
        // add headers listener
        if (setHeaders) {
            stream.on('headers', setHeaders);
        }
        // add file listener for fallthrough
        if (fallthrough) {
            stream.on('file', function onFile() {
                // once file is determined, always forward error
                forwardError = true;
            });
        }
        // forward errors
        stream.on('error', function error(err) {
            if (forwardError || !(err.statusCode < 500)) {
                next(err);
                return;
            }
            next();
        });
        // pipe
        stream.pipe(res);
    };
}
/**
 * Collapse all leading slashes into a single slash
 * @private
 */ function collapseLeadingSlashes(str) {
    for(var i = 0; i < str.length; i++){
        if (str.charCodeAt(i) !== 0x2f /* / */ ) {
            break;
        }
    }
    return i > 1 ? '/' + str.substr(i) : str;
}
/**
 * Create a minimal HTML document.
 *
 * @param {string} title
 * @param {string} body
 * @private
 */ function createHtmlDocument(title, body) {
    return '<!DOCTYPE html>\n' + '<html lang="en">\n' + '<head>\n' + '<meta charset="utf-8">\n' + '<title>' + title + '</title>\n' + '</head>\n' + '<body>\n' + '<pre>' + body + '</pre>\n' + '</body>\n' + '</html>\n';
}
/**
 * Create a directory listener that just 404s.
 * @private
 */ function createNotFoundDirectoryListener() {
    return function notFound() {
        this.error(404);
    };
}
/**
 * Create a directory listener that performs a redirect.
 * @private
 */ function createRedirectDirectoryListener() {
    return function redirect(res) {
        if (this.hasTrailingSlash()) {
            this.error(404);
            return;
        }
        // get original URL
        var originalUrl = parseUrl.original(this.req);
        // append trailing slash
        originalUrl.path = null;
        originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/');
        // reformat the URL
        var loc = encodeUrl(url.format(originalUrl));
        var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc));
        // send redirect response
        res.statusCode = 301;
        res.setHeader('Content-Type', 'text/html; charset=UTF-8');
        res.setHeader('Content-Length', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].byteLength(doc));
        res.setHeader('Content-Security-Policy', "default-src 'none'");
        res.setHeader('X-Content-Type-Options', 'nosniff');
        res.setHeader('Location', loc);
        res.end(doc);
    };
}
}}),
"[project]/node_modules/bytes/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */ 'use strict';
/**
 * Module exports.
 * @public
 */ module.exports = bytes;
module.exports.format = format;
module.exports.parse = parse;
/**
 * Module variables.
 * @private
 */ var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
var map = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
};
var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
/**
 * Convert the given value in bytes into a string or parse to string to an integer in bytes.
 *
 * @param {string|number} value
 * @param {{
 *  case: [string],
 *  decimalPlaces: [number]
 *  fixedDecimals: [boolean]
 *  thousandsSeparator: [string]
 *  unitSeparator: [string]
 *  }} [options] bytes options.
 *
 * @returns {string|number|null}
 */ function bytes(value, options) {
    if (typeof value === 'string') {
        return parse(value);
    }
    if (typeof value === 'number') {
        return format(value, options);
    }
    return null;
}
/**
 * Format the given value in bytes into a string.
 *
 * If the value is negative, it is kept as such. If it is a float,
 * it is rounded.
 *
 * @param {number} value
 * @param {object} [options]
 * @param {number} [options.decimalPlaces=2]
 * @param {number} [options.fixedDecimals=false]
 * @param {string} [options.thousandsSeparator=]
 * @param {string} [options.unit=]
 * @param {string} [options.unitSeparator=]
 *
 * @returns {string|null}
 * @public
 */ function format(value, options) {
    if (!Number.isFinite(value)) {
        return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options && options.thousandsSeparator || '';
    var unitSeparator = options && options.unitSeparator || '';
    var decimalPlaces = options && options.decimalPlaces !== undefined ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = options && options.unit || '';
    if (!unit || !map[unit.toLowerCase()]) {
        if (mag >= map.pb) {
            unit = 'PB';
        } else if (mag >= map.tb) {
            unit = 'TB';
        } else if (mag >= map.gb) {
            unit = 'GB';
        } else if (mag >= map.mb) {
            unit = 'MB';
        } else if (mag >= map.kb) {
            unit = 'KB';
        } else {
            unit = 'B';
        }
    }
    var val = value / map[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, '$1');
    }
    if (thousandsSeparator) {
        str = str.split('.').map(function(s, i) {
            return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
        }).join('.');
    }
    return str + unitSeparator + unit;
}
/**
 * Parse the string value into an integer in bytes.
 *
 * If no unit is given, it is assumed the value is in bytes.
 *
 * @param {number|string} val
 *
 * @returns {number|null}
 * @public
 */ function parse(val) {
    if (typeof val === 'number' && !isNaN(val)) {
        return val;
    }
    if (typeof val !== 'string') {
        return null;
    }
    // Test if the string passed is valid
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = 'b';
    if (!results) {
        // Nothing could be extracted from the given string
        floatValue = parseInt(val, 10);
        unit = 'b';
    } else {
        // Retrieve the value and the unit
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
    }
    if (isNaN(floatValue)) {
        return null;
    }
    return Math.floor(map[unit] * floatValue);
}
}}),
"[project]/node_modules/safer-buffer/safer.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* eslint-disable node/no-deprecated-api */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
var buffer = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var Buffer = buffer.Buffer;
var safer = {};
var key;
for(key in buffer){
    if (!buffer.hasOwnProperty(key)) continue;
    if (key === 'SlowBuffer' || key === 'Buffer') continue;
    safer[key] = buffer[key];
}
var Safer = safer.Buffer = {};
for(key in Buffer){
    if (!Buffer.hasOwnProperty(key)) continue;
    if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue;
    Safer[key] = Buffer[key];
}
safer.Buffer.prototype = Buffer.prototype;
if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === 'number') {
            throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === 'undefined') {
            throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value);
        }
        return Buffer(value, encodingOrOffset, length);
    };
}
if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== 'number') {
            throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
            throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer(size);
        if (!fill || fill.length === 0) {
            buf.fill(0);
        } else if (typeof encoding === 'string') {
            buf.fill(fill, encoding);
        } else {
            buf.fill(fill);
        }
        return buf;
    };
}
if (!safer.kStringMaxLength) {
    try {
        safer.kStringMaxLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].binding('buffer').kStringMaxLength;
    } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
    }
}
if (!safer.constants) {
    safer.constants = {
        MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
}
module.exports = safer;
}}),
"[project]/node_modules/unpipe/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module exports.
 * @public
 */ module.exports = unpipe;
/**
 * Determine if there are Node.js pipe-like data listeners.
 * @private
 */ function hasPipeDataListeners(stream) {
    var listeners = stream.listeners('data');
    for(var i = 0; i < listeners.length; i++){
        if (listeners[i].name === 'ondata') {
            return true;
        }
    }
    return false;
}
/**
 * Unpipe a stream from all destinations.
 *
 * @param {object} stream
 * @public
 */ function unpipe(stream) {
    if (!stream) {
        throw new TypeError('argument stream is required');
    }
    if (typeof stream.unpipe === 'function') {
        // new-style
        stream.unpipe();
        return;
    }
    // Node.js 0.8 hack
    if (!hasPipeDataListeners(stream)) {
        return;
    }
    var listener;
    var listeners = stream.listeners('close');
    for(var i = 0; i < listeners.length; i++){
        listener = listeners[i];
        if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
            continue;
        }
        // invoke the listener
        listener.call(stream);
    }
}
}}),
"[project]/node_modules/raw-body/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
'use strict';
/**
 * Module dependencies.
 * @private
 */ var asyncHooks = tryRequireAsyncHooks();
var bytes = __turbopack_context__.r("[project]/node_modules/bytes/index.js [app-client] (ecmascript)");
var createError = __turbopack_context__.r("[project]/node_modules/http-errors/index.js [app-client] (ecmascript)");
var iconv = __turbopack_context__.r("[project]/node_modules/iconv-lite/lib/index.js [app-client] (ecmascript)");
var unpipe = __turbopack_context__.r("[project]/node_modules/unpipe/index.js [app-client] (ecmascript)");
/**
 * Module exports.
 * @public
 */ module.exports = getRawBody;
/**
 * Module variables.
 * @private
 */ var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
/**
 * Get the decoder for a given encoding.
 *
 * @param {string} encoding
 * @private
 */ function getDecoder(encoding) {
    if (!encoding) return null;
    try {
        return iconv.getDecoder(encoding);
    } catch (e) {
        // error getting decoder
        if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;
        // the encoding was not found
        throw createError(415, 'specified encoding unsupported', {
            encoding: encoding,
            type: 'encoding.unsupported'
        });
    }
}
/**
 * Get the raw body of a stream (typically HTTP).
 *
 * @param {object} stream
 * @param {object|string|function} [options]
 * @param {function} [callback]
 * @public
 */ function getRawBody(stream, options, callback) {
    var done = callback;
    var opts = options || {};
    // light validation
    if (stream === undefined) {
        throw new TypeError('argument stream is required');
    } else if (typeof stream !== 'object' || stream === null || typeof stream.on !== 'function') {
        throw new TypeError('argument stream must be a stream');
    }
    if (options === true || typeof options === 'string') {
        // short cut for encoding
        opts = {
            encoding: options
        };
    }
    if (typeof options === 'function') {
        done = options;
        opts = {};
    }
    // validate callback is a function, if provided
    if (done !== undefined && typeof done !== 'function') {
        throw new TypeError('argument callback must be a function');
    }
    // require the callback without promises
    if (!done && !global.Promise) {
        throw new TypeError('argument callback is required');
    }
    // get encoding
    var encoding = opts.encoding !== true ? opts.encoding : 'utf-8';
    // convert the limit to an integer
    var limit = bytes.parse(opts.limit);
    // convert the expected length to an integer
    var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done) {
        // classic callback style
        return readStream(stream, encoding, length, limit, wrap(done));
    }
    return new Promise(function executor(resolve, reject) {
        readStream(stream, encoding, length, limit, function onRead(err, buf) {
            if (err) return reject(err);
            resolve(buf);
        });
    });
}
/**
 * Halt a stream.
 *
 * @param {Object} stream
 * @private
 */ function halt(stream) {
    // unpipe everything from the stream
    unpipe(stream);
    // pause stream
    if (typeof stream.pause === 'function') {
        stream.pause();
    }
}
/**
 * Read the data from the stream.
 *
 * @param {object} stream
 * @param {string} encoding
 * @param {number} length
 * @param {number} limit
 * @param {function} callback
 * @public
 */ function readStream(stream, encoding, length, limit, callback) {
    var complete = false;
    var sync = true;
    // check the length and limit options.
    // note: we intentionally leave the stream paused,
    // so users should handle the stream themselves.
    if (limit !== null && length !== null && length > limit) {
        return done(createError(413, 'request entity too large', {
            expected: length,
            length: length,
            limit: limit,
            type: 'entity.too.large'
        }));
    }
    // streams1: assert request encoding is buffer.
    // streams2+: assert the stream encoding is buffer.
    //   stream._decoder: streams1
    //   state.encoding: streams2
    //   state.decoder: streams2, specifically < 0.10.6
    var state = stream._readableState;
    if (stream._decoder || state && (state.encoding || state.decoder)) {
        // developer error
        return done(createError(500, 'stream encoding should not be set', {
            type: 'stream.encoding.set'
        }));
    }
    if (typeof stream.readable !== 'undefined' && !stream.readable) {
        return done(createError(500, 'stream is not readable', {
            type: 'stream.not.readable'
        }));
    }
    var received = 0;
    var decoder;
    try {
        decoder = getDecoder(encoding);
    } catch (err) {
        return done(err);
    }
    var buffer = decoder ? '' : [];
    // attach listeners
    stream.on('aborted', onAborted);
    stream.on('close', cleanup);
    stream.on('data', onData);
    stream.on('end', onEnd);
    stream.on('error', onEnd);
    // mark sync section complete
    sync = false;
    function done() {
        var args = new Array(arguments.length);
        // copy arguments
        for(var i = 0; i < args.length; i++){
            args[i] = arguments[i];
        }
        // mark complete
        complete = true;
        if (sync) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(invokeCallback);
        } else {
            invokeCallback();
        }
        function invokeCallback() {
            cleanup();
            if (args[0]) {
                // halt the stream on error
                halt(stream);
            }
            callback.apply(null, args);
        }
    }
    function onAborted() {
        if (complete) return;
        done(createError(400, 'request aborted', {
            code: 'ECONNABORTED',
            expected: length,
            length: length,
            received: received,
            type: 'request.aborted'
        }));
    }
    function onData(chunk) {
        if (complete) return;
        received += chunk.length;
        if (limit !== null && received > limit) {
            done(createError(413, 'request entity too large', {
                limit: limit,
                received: received,
                type: 'entity.too.large'
            }));
        } else if (decoder) {
            buffer += decoder.write(chunk);
        } else {
            buffer.push(chunk);
        }
    }
    function onEnd(err) {
        if (complete) return;
        if (err) return done(err);
        if (length !== null && received !== length) {
            done(createError(400, 'request size did not match content length', {
                expected: length,
                length: length,
                received: received,
                type: 'request.size.invalid'
            }));
        } else {
            var string = decoder ? buffer + (decoder.end() || '') : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(buffer);
            done(null, string);
        }
    }
    function cleanup() {
        buffer = null;
        stream.removeListener('aborted', onAborted);
        stream.removeListener('data', onData);
        stream.removeListener('end', onEnd);
        stream.removeListener('error', onEnd);
        stream.removeListener('close', cleanup);
    }
}
/**
 * Try to require async_hooks
 * @private
 */ function tryRequireAsyncHooks() {
    try {
        return (()=>{
            const e = new Error("Cannot find module 'async_hooks'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
    } catch (e) {
        return {};
    }
}
/**
 * Wrap function with async resource, if possible.
 * AsyncResource.bind static method backported.
 * @private
 */ function wrap(fn) {
    var res;
    // create anonymous resource
    if (asyncHooks.AsyncResource) {
        res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');
    }
    // incompatible node.js
    if (!res || !res.runInAsyncScope) {
        return fn;
    }
    // return bound function
    return res.runInAsyncScope.bind(res, fn, null);
}
}}),
"[project]/node_modules/body-parser/lib/read.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ var createError = __turbopack_context__.r("[project]/node_modules/http-errors/index.js [app-client] (ecmascript)");
var getBody = __turbopack_context__.r("[project]/node_modules/raw-body/index.js [app-client] (ecmascript)");
var iconv = __turbopack_context__.r("[project]/node_modules/iconv-lite/lib/index.js [app-client] (ecmascript)");
var onFinished = __turbopack_context__.r("[project]/node_modules/on-finished/index.js [app-client] (ecmascript)");
var zlib = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/browserify-zlib/index.js [app-client] (ecmascript)");
/**
 * Module exports.
 */ module.exports = read;
/**
 * Read a request into a buffer and parse.
 *
 * @param {object} req
 * @param {object} res
 * @param {function} next
 * @param {function} parse
 * @param {function} debug
 * @param {object} options
 * @private
 */ function read(req, res, next, parse, debug, options) {
    var length;
    var opts = options;
    var stream;
    // read options
    var encoding = opts.encoding !== null ? opts.encoding : null;
    var verify = opts.verify;
    try {
        // get the content stream
        stream = contentstream(req, debug, opts.inflate);
        length = stream.length;
        stream.length = undefined;
    } catch (err) {
        return next(err);
    }
    // set raw-body options
    opts.length = length;
    opts.encoding = verify ? null : encoding;
    // assert charset is supported
    if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
        return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
            charset: encoding.toLowerCase(),
            type: 'charset.unsupported'
        }));
    }
    // read body
    debug('read body');
    getBody(stream, opts, function(error, body) {
        if (error) {
            var _error;
            if (error.type === 'encoding.unsupported') {
                // echo back charset
                _error = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
                    charset: encoding.toLowerCase(),
                    type: 'charset.unsupported'
                });
            } else {
                // set status code on error
                _error = createError(400, error);
            }
            // unpipe from stream and destroy
            if (stream !== req) {
                req.unpipe();
                stream.destroy();
            }
            // read off entire request
            dump(req, function onfinished() {
                next(createError(400, _error));
            });
            return;
        }
        // verify
        if (verify) {
            try {
                debug('verify body');
                verify(req, res, body, encoding);
            } catch (err) {
                next(createError(403, err, {
                    body: body,
                    type: err.type || 'entity.verify.failed'
                }));
                return;
            }
        }
        // parse
        var str = body;
        try {
            debug('parse body');
            str = typeof body !== 'string' && encoding !== null ? iconv.decode(body, encoding) : body;
            req.body = parse(str, encoding);
        } catch (err) {
            next(createError(400, err, {
                body: str,
                type: err.type || 'entity.parse.failed'
            }));
            return;
        }
        next();
    });
}
/**
 * Get the content stream of the request.
 *
 * @param {object} req
 * @param {function} debug
 * @param {boolean} [inflate=true]
 * @return {object}
 * @api private
 */ function contentstream(req, debug, inflate) {
    var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase();
    var length = req.headers['content-length'];
    debug('content-encoding "%s"', encoding);
    if (inflate === false && encoding !== 'identity') {
        throw createError(415, 'content encoding unsupported', {
            encoding: encoding,
            type: 'encoding.unsupported'
        });
    }
    if (encoding === 'identity') {
        req.length = length;
        return req;
    }
    var stream = createDecompressionStream(encoding, debug);
    req.pipe(stream);
    return stream;
}
/**
 * Create a decompression stream for the given encoding.
 * @param {string} encoding
 * @param {function} debug
 * @return {object}
 * @api private
 */ function createDecompressionStream(encoding, debug) {
    switch(encoding){
        case 'deflate':
            debug('inflate body');
            return zlib.createInflate();
        case 'gzip':
            debug('gunzip body');
            return zlib.createGunzip();
        case 'br':
            debug('brotli decompress body');
            return zlib.createBrotliDecompress();
        default:
            throw createError(415, 'unsupported content encoding "' + encoding + '"', {
                encoding: encoding,
                type: 'encoding.unsupported'
            });
    }
}
/**
 * Dump the contents of a request.
 *
 * @param {object} req
 * @param {function} callback
 * @api private
 */ function dump(req, callback) {
    if (onFinished.isFinished(req)) {
        callback(null);
    } else {
        onFinished(req, callback);
        req.resume();
    }
}
}}),
"[project]/node_modules/body-parser/lib/utils.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/**
 * Module dependencies.
 */ var bytes = __turbopack_context__.r("[project]/node_modules/bytes/index.js [app-client] (ecmascript)");
var contentType = __turbopack_context__.r("[project]/node_modules/content-type/index.js [app-client] (ecmascript)");
var typeis = __turbopack_context__.r("[project]/node_modules/type-is/index.js [app-client] (ecmascript)");
/**
 * Module exports.
 */ module.exports = {
    getCharset,
    normalizeOptions
};
/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */ function getCharset(req) {
    try {
        return (contentType.parse(req).parameters.charset || '').toLowerCase();
    } catch  {
        return undefined;
    }
}
/**
 * Get the simple type checker.
 *
 * @param {string | string[]} type
 * @return {function}
 */ function typeChecker(type) {
    return function checkType(req) {
        return Boolean(typeis(req, type));
    };
}
/**
 * Normalizes the common options for all parsers.
 *
 * @param {object} options options to normalize
 * @param {string | string[] | function} defaultType default content type(s) or a function to determine it
 * @returns {object}
 */ function normalizeOptions(options, defaultType) {
    if (!defaultType) {
        // Parsers must define a default content type
        throw new TypeError('defaultType must be provided');
    }
    var inflate = options?.inflate !== false;
    var limit = typeof options?.limit !== 'number' ? bytes.parse(options?.limit || '100kb') : options?.limit;
    var type = options?.type || defaultType;
    var verify = options?.verify || false;
    if (verify !== false && typeof verify !== 'function') {
        throw new TypeError('option verify must be function');
    }
    // create the appropriate type checking function
    var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;
    return {
        inflate,
        limit,
        verify,
        shouldParse
    };
}
}}),
"[project]/node_modules/body-parser/lib/types/json.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ var createError = __turbopack_context__.r("[project]/node_modules/http-errors/index.js [app-client] (ecmascript)");
var debug = __turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)")('body-parser:json');
var isFinished = __turbopack_context__.r("[project]/node_modules/on-finished/index.js [app-client] (ecmascript)").isFinished;
var read = __turbopack_context__.r("[project]/node_modules/body-parser/lib/read.js [app-client] (ecmascript)");
var typeis = __turbopack_context__.r("[project]/node_modules/type-is/index.js [app-client] (ecmascript)");
var { getCharset, normalizeOptions } = __turbopack_context__.r("[project]/node_modules/body-parser/lib/utils.js [app-client] (ecmascript)");
/**
 * Module exports.
 */ module.exports = json;
/**
 * RegExp to match the first non-space in a string.
 *
 * Allowed whitespace is defined in RFC 7159:
 *
 *    ws = *(
 *            %x20 /              ; Space
 *            %x09 /              ; Horizontal tab
 *            %x0A /              ; Line feed or New line
 *            %x0D )              ; Carriage return
 */ var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/ // eslint-disable-line no-control-regex
;
var JSON_SYNTAX_CHAR = '#';
var JSON_SYNTAX_REGEXP = /#+/g;
/**
 * Create a middleware to parse JSON bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @public
 */ function json(options) {
    var { inflate, limit, verify, shouldParse } = normalizeOptions(options, 'application/json');
    var reviver = options?.reviver;
    var strict = options?.strict !== false;
    function parse(body) {
        if (body.length === 0) {
            // special-case empty json body, as it's a common client-side mistake
            // TODO: maybe make this configurable or part of "strict" option
            return {};
        }
        if (strict) {
            var first = firstchar(body);
            if (first !== '{' && first !== '[') {
                debug('strict violation');
                throw createStrictSyntaxError(body, first);
            }
        }
        try {
            debug('parse json');
            return JSON.parse(body, reviver);
        } catch (e) {
            throw normalizeJsonSyntaxError(e, {
                message: e.message,
                stack: e.stack
            });
        }
    }
    return function jsonParser(req, res, next) {
        if (isFinished(req)) {
            debug('body already parsed');
            next();
            return;
        }
        if (!('body' in req)) {
            req.body = undefined;
        }
        // skip requests without bodies
        if (!typeis.hasBody(req)) {
            debug('skip empty body');
            next();
            return;
        }
        debug('content-type %j', req.headers['content-type']);
        // determine if request should be parsed
        if (!shouldParse(req)) {
            debug('skip parsing');
            next();
            return;
        }
        // assert charset per RFC 7159 sec 8.1
        var charset = getCharset(req) || 'utf-8';
        if (charset.slice(0, 4) !== 'utf-') {
            debug('invalid charset');
            next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
                charset: charset,
                type: 'charset.unsupported'
            }));
            return;
        }
        // read
        read(req, res, next, parse, debug, {
            encoding: charset,
            inflate,
            limit,
            verify
        });
    };
}
/**
 * Create strict violation syntax error matching native error.
 *
 * @param {string} str
 * @param {string} char
 * @return {Error}
 * @private
 */ function createStrictSyntaxError(str, char) {
    var index = str.indexOf(char);
    var partial = '';
    if (index !== -1) {
        partial = str.substring(0, index) + JSON_SYNTAX_CHAR;
        for(var i = index + 1; i < str.length; i++){
            partial += JSON_SYNTAX_CHAR;
        }
    }
    try {
        JSON.parse(partial); /* istanbul ignore next */ 
        throw new SyntaxError('strict violation');
    } catch (e) {
        return normalizeJsonSyntaxError(e, {
            message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
                return str.substring(index, index + placeholder.length);
            }),
            stack: e.stack
        });
    }
}
/**
 * Get the first non-whitespace character in a string.
 *
 * @param {string} str
 * @return {function}
 * @private
 */ function firstchar(str) {
    var match = FIRST_CHAR_REGEXP.exec(str);
    return match ? match[1] : undefined;
}
/**
 * Normalize a SyntaxError for JSON.parse.
 *
 * @param {SyntaxError} error
 * @param {object} obj
 * @return {SyntaxError}
 */ function normalizeJsonSyntaxError(error, obj) {
    var keys = Object.getOwnPropertyNames(error);
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        if (key !== 'stack' && key !== 'message') {
            delete error[key];
        }
    }
    // replace stack before message for Node.js 0.10 and below
    error.stack = obj.stack.replace(error.message, obj.message);
    error.message = obj.message;
    return error;
}
}}),
"[project]/node_modules/body-parser/lib/types/raw.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 */ var debug = __turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)")('body-parser:raw');
var isFinished = __turbopack_context__.r("[project]/node_modules/on-finished/index.js [app-client] (ecmascript)").isFinished;
var read = __turbopack_context__.r("[project]/node_modules/body-parser/lib/read.js [app-client] (ecmascript)");
var typeis = __turbopack_context__.r("[project]/node_modules/type-is/index.js [app-client] (ecmascript)");
var { normalizeOptions } = __turbopack_context__.r("[project]/node_modules/body-parser/lib/utils.js [app-client] (ecmascript)");
/**
 * Module exports.
 */ module.exports = raw;
/**
 * Create a middleware to parse raw bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @api public
 */ function raw(options) {
    var { inflate, limit, verify, shouldParse } = normalizeOptions(options, 'application/octet-stream');
    function parse(buf) {
        return buf;
    }
    return function rawParser(req, res, next) {
        if (isFinished(req)) {
            debug('body already parsed');
            next();
            return;
        }
        if (!('body' in req)) {
            req.body = undefined;
        }
        // skip requests without bodies
        if (!typeis.hasBody(req)) {
            debug('skip empty body');
            next();
            return;
        }
        debug('content-type %j', req.headers['content-type']);
        // determine if request should be parsed
        if (!shouldParse(req)) {
            debug('skip parsing');
            next();
            return;
        }
        // read
        read(req, res, next, parse, debug, {
            encoding: null,
            inflate,
            limit,
            verify
        });
    };
}
}}),
"[project]/node_modules/body-parser/lib/types/text.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 */ var debug = __turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)")('body-parser:text');
var isFinished = __turbopack_context__.r("[project]/node_modules/on-finished/index.js [app-client] (ecmascript)").isFinished;
var read = __turbopack_context__.r("[project]/node_modules/body-parser/lib/read.js [app-client] (ecmascript)");
var typeis = __turbopack_context__.r("[project]/node_modules/type-is/index.js [app-client] (ecmascript)");
var { getCharset, normalizeOptions } = __turbopack_context__.r("[project]/node_modules/body-parser/lib/utils.js [app-client] (ecmascript)");
/**
 * Module exports.
 */ module.exports = text;
/**
 * Create a middleware to parse text bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @api public
 */ function text(options) {
    var { inflate, limit, verify, shouldParse } = normalizeOptions(options, 'text/plain');
    var defaultCharset = options?.defaultCharset || 'utf-8';
    function parse(buf) {
        return buf;
    }
    return function textParser(req, res, next) {
        if (isFinished(req)) {
            debug('body already parsed');
            next();
            return;
        }
        if (!('body' in req)) {
            req.body = undefined;
        }
        // skip requests without bodies
        if (!typeis.hasBody(req)) {
            debug('skip empty body');
            next();
            return;
        }
        debug('content-type %j', req.headers['content-type']);
        // determine if request should be parsed
        if (!shouldParse(req)) {
            debug('skip parsing');
            next();
            return;
        }
        // get charset
        var charset = getCharset(req) || defaultCharset;
        // read
        read(req, res, next, parse, debug, {
            encoding: charset,
            inflate,
            limit,
            verify
        });
    };
}
}}),
"[project]/node_modules/body-parser/lib/types/urlencoded.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ var createError = __turbopack_context__.r("[project]/node_modules/http-errors/index.js [app-client] (ecmascript)");
var debug = __turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)")('body-parser:urlencoded');
var isFinished = __turbopack_context__.r("[project]/node_modules/on-finished/index.js [app-client] (ecmascript)").isFinished;
var read = __turbopack_context__.r("[project]/node_modules/body-parser/lib/read.js [app-client] (ecmascript)");
var typeis = __turbopack_context__.r("[project]/node_modules/type-is/index.js [app-client] (ecmascript)");
var qs = __turbopack_context__.r("[project]/node_modules/qs/lib/index.js [app-client] (ecmascript)");
var { getCharset, normalizeOptions } = __turbopack_context__.r("[project]/node_modules/body-parser/lib/utils.js [app-client] (ecmascript)");
/**
 * Module exports.
 */ module.exports = urlencoded;
/**
 * Create a middleware to parse urlencoded bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @public
 */ function urlencoded(options) {
    var { inflate, limit, verify, shouldParse } = normalizeOptions(options, 'application/x-www-form-urlencoded');
    var defaultCharset = options?.defaultCharset || 'utf-8';
    if (defaultCharset !== 'utf-8' && defaultCharset !== 'iso-8859-1') {
        throw new TypeError('option defaultCharset must be either utf-8 or iso-8859-1');
    }
    // create the appropriate query parser
    var queryparse = createQueryParser(options);
    function parse(body, encoding) {
        return body.length ? queryparse(body, encoding) : {};
    }
    return function urlencodedParser(req, res, next) {
        if (isFinished(req)) {
            debug('body already parsed');
            next();
            return;
        }
        if (!('body' in req)) {
            req.body = undefined;
        }
        // skip requests without bodies
        if (!typeis.hasBody(req)) {
            debug('skip empty body');
            next();
            return;
        }
        debug('content-type %j', req.headers['content-type']);
        // determine if request should be parsed
        if (!shouldParse(req)) {
            debug('skip parsing');
            next();
            return;
        }
        // assert charset
        var charset = getCharset(req) || defaultCharset;
        if (charset !== 'utf-8' && charset !== 'iso-8859-1') {
            debug('invalid charset');
            next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
                charset: charset,
                type: 'charset.unsupported'
            }));
            return;
        }
        // read
        read(req, res, next, parse, debug, {
            encoding: charset,
            inflate,
            limit,
            verify
        });
    };
}
/**
 * Get the extended query parser.
 *
 * @param {object} options
 */ function createQueryParser(options) {
    var extended = Boolean(options?.extended);
    var parameterLimit = options?.parameterLimit !== undefined ? options?.parameterLimit : 1000;
    var charsetSentinel = options?.charsetSentinel;
    var interpretNumericEntities = options?.interpretNumericEntities;
    var depth = extended ? options?.depth !== undefined ? options?.depth : 32 : 0;
    if (isNaN(parameterLimit) || parameterLimit < 1) {
        throw new TypeError('option parameterLimit must be a positive number');
    }
    if (isNaN(depth) || depth < 0) {
        throw new TypeError('option depth must be a zero or a positive number');
    }
    if (isFinite(parameterLimit)) {
        parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body, encoding) {
        var paramCount = parameterCount(body, parameterLimit);
        if (paramCount === undefined) {
            debug('too many parameters');
            throw createError(413, 'too many parameters', {
                type: 'parameters.too.many'
            });
        }
        var arrayLimit = extended ? Math.max(100, paramCount) : 0;
        debug('parse ' + (extended ? 'extended ' : '') + 'urlencoding');
        try {
            return qs.parse(body, {
                allowPrototypes: true,
                arrayLimit: arrayLimit,
                depth: depth,
                charsetSentinel: charsetSentinel,
                interpretNumericEntities: interpretNumericEntities,
                charset: encoding,
                parameterLimit: parameterLimit,
                strictDepth: true
            });
        } catch (err) {
            if (err instanceof RangeError) {
                throw createError(400, 'The input exceeded the depth', {
                    type: 'querystring.parse.rangeError'
                });
            } else {
                throw err;
            }
        }
    };
}
/**
 * Count the number of parameters, stopping once limit reached
 *
 * @param {string} body
 * @param {number} limit
 * @api private
 */ function parameterCount(body, limit) {
    var len = body.split('&').length;
    return len > limit ? undefined : len - 1;
}
}}),
"[project]/node_modules/body-parser/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * @typedef Parsers
 * @type {function}
 * @property {function} json
 * @property {function} raw
 * @property {function} text
 * @property {function} urlencoded
 */ /**
 * Module exports.
 * @type {Parsers}
 */ exports = module.exports = bodyParser;
/**
 * JSON parser.
 * @public
 */ Object.defineProperty(exports, 'json', {
    configurable: true,
    enumerable: true,
    get: ()=>__turbopack_context__.r("[project]/node_modules/body-parser/lib/types/json.js [app-client] (ecmascript)")
});
/**
 * Raw parser.
 * @public
 */ Object.defineProperty(exports, 'raw', {
    configurable: true,
    enumerable: true,
    get: ()=>__turbopack_context__.r("[project]/node_modules/body-parser/lib/types/raw.js [app-client] (ecmascript)")
});
/**
 * Text parser.
 * @public
 */ Object.defineProperty(exports, 'text', {
    configurable: true,
    enumerable: true,
    get: ()=>__turbopack_context__.r("[project]/node_modules/body-parser/lib/types/text.js [app-client] (ecmascript)")
});
/**
 * URL-encoded parser.
 * @public
 */ Object.defineProperty(exports, 'urlencoded', {
    configurable: true,
    enumerable: true,
    get: ()=>__turbopack_context__.r("[project]/node_modules/body-parser/lib/types/urlencoded.js [app-client] (ecmascript)")
});
/**
 * Create a middleware to parse json and urlencoded bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @deprecated
 * @public
 */ function bodyParser() {
    throw new Error('The bodyParser() generic has been split into individual middleware to use instead.');
}
}}),
"[project]/node_modules/content-type/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
 *
 * parameter     = token "=" ( token / quoted-string )
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
 * obs-text      = %x80-FF
 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
 */ var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g // eslint-disable-line no-control-regex
;
var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/ // eslint-disable-line no-control-regex
;
var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
/**
 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
 *
 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
 * obs-text    = %x80-FF
 */ var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g // eslint-disable-line no-control-regex
;
/**
 * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
 */ var QUOTE_REGEXP = /([\\"])/g;
/**
 * RegExp to match type in RFC 7231 sec 3.1.1.1
 *
 * media-type = type "/" subtype
 * type       = token
 * subtype    = token
 */ var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
/**
 * Module exports.
 * @public
 */ exports.format = format;
exports.parse = parse;
/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @public
 */ function format(obj) {
    if (!obj || typeof obj !== 'object') {
        throw new TypeError('argument obj is required');
    }
    var parameters = obj.parameters;
    var type = obj.type;
    if (!type || !TYPE_REGEXP.test(type)) {
        throw new TypeError('invalid type');
    }
    var string = type;
    // append parameters
    if (parameters && typeof parameters === 'object') {
        var param;
        var params = Object.keys(parameters).sort();
        for(var i = 0; i < params.length; i++){
            param = params[i];
            if (!TOKEN_REGEXP.test(param)) {
                throw new TypeError('invalid parameter name');
            }
            string += '; ' + param + '=' + qstring(parameters[param]);
        }
    }
    return string;
}
/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @public
 */ function parse(string) {
    if (!string) {
        throw new TypeError('argument string is required');
    }
    // support req/res-like objects as argument
    var header = typeof string === 'object' ? getcontenttype(string) : string;
    if (typeof header !== 'string') {
        throw new TypeError('argument string is required to be a string');
    }
    var index = header.indexOf(';');
    var type = index !== -1 ? header.slice(0, index).trim() : header.trim();
    if (!TYPE_REGEXP.test(type)) {
        throw new TypeError('invalid media type');
    }
    var obj = new ContentType(type.toLowerCase());
    // parse parameters
    if (index !== -1) {
        var key;
        var match;
        var value;
        PARAM_REGEXP.lastIndex = index;
        while(match = PARAM_REGEXP.exec(header)){
            if (match.index !== index) {
                throw new TypeError('invalid parameter format');
            }
            index += match[0].length;
            key = match[1].toLowerCase();
            value = match[2];
            if (value.charCodeAt(0) === 0x22 /* " */ ) {
                // remove quotes
                value = value.slice(1, -1);
                // remove escapes
                if (value.indexOf('\\') !== -1) {
                    value = value.replace(QESC_REGEXP, '$1');
                }
            }
            obj.parameters[key] = value;
        }
        if (index !== header.length) {
            throw new TypeError('invalid parameter format');
        }
    }
    return obj;
}
/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @private
 */ function getcontenttype(obj) {
    var header;
    if (typeof obj.getHeader === 'function') {
        // res-like
        header = obj.getHeader('content-type');
    } else if (typeof obj.headers === 'object') {
        // req-like
        header = obj.headers && obj.headers['content-type'];
    }
    if (typeof header !== 'string') {
        throw new TypeError('content-type header is missing from object');
    }
    return header;
}
/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @private
 */ function qstring(val) {
    var str = String(val);
    // no need to quote tokens
    if (TOKEN_REGEXP.test(str)) {
        return str;
    }
    if (str.length > 0 && !TEXT_REGEXP.test(str)) {
        throw new TypeError('invalid parameter value');
    }
    return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
}
/**
 * Class to represent a content type.
 * @private
 */ function ContentType(type) {
    this.parameters = Object.create(null);
    this.type = type;
}
}}),
"[project]/node_modules/media-typer/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * media-typer
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * RegExp to match type in RFC 6838
 *
 * type-name = restricted-name
 * subtype-name = restricted-name
 * restricted-name = restricted-name-first *126restricted-name-chars
 * restricted-name-first  = ALPHA / DIGIT
 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
 *                          "$" / "&" / "-" / "^" / "_"
 * restricted-name-chars =/ "." ; Characters before first dot always
 *                              ; specify a facet name
 * restricted-name-chars =/ "+" ; Characters after last plus always
 *                              ; specify a structured syntax suffix
 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
 * DIGIT =  %x30-39             ; 0-9
 */ var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
var TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
var TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
/**
 * Module exports.
 */ exports.format = format;
exports.parse = parse;
exports.test = test;
/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @public
 */ function format(obj) {
    if (!obj || typeof obj !== 'object') {
        throw new TypeError('argument obj is required');
    }
    var subtype = obj.subtype;
    var suffix = obj.suffix;
    var type = obj.type;
    if (!type || !TYPE_NAME_REGEXP.test(type)) {
        throw new TypeError('invalid type');
    }
    if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype)) {
        throw new TypeError('invalid subtype');
    }
    // format as type/subtype
    var string = type + '/' + subtype;
    // append +suffix
    if (suffix) {
        if (!TYPE_NAME_REGEXP.test(suffix)) {
            throw new TypeError('invalid suffix');
        }
        string += '+' + suffix;
    }
    return string;
}
/**
 * Test media type.
 *
 * @param {string} string
 * @return {object}
 * @public
 */ function test(string) {
    if (!string) {
        throw new TypeError('argument string is required');
    }
    if (typeof string !== 'string') {
        throw new TypeError('argument string is required to be a string');
    }
    return TYPE_REGEXP.test(string.toLowerCase());
}
/**
 * Parse media type to object.
 *
 * @param {string} string
 * @return {object}
 * @public
 */ function parse(string) {
    if (!string) {
        throw new TypeError('argument string is required');
    }
    if (typeof string !== 'string') {
        throw new TypeError('argument string is required to be a string');
    }
    var match = TYPE_REGEXP.exec(string.toLowerCase());
    if (!match) {
        throw new TypeError('invalid media type');
    }
    var type = match[1];
    var subtype = match[2];
    var suffix;
    // suffix after last +
    var index = subtype.lastIndexOf('+');
    if (index !== -1) {
        suffix = subtype.substr(index + 1);
        subtype = subtype.substr(0, index);
    }
    return new MediaType(type, subtype, suffix);
}
/**
 * Class for MediaType object.
 * @public
 */ function MediaType(type, subtype, suffix) {
    this.type = type;
    this.subtype = subtype;
    this.suffix = suffix;
}
}}),
"[project]/node_modules/type-is/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ var contentType = __turbopack_context__.r("[project]/node_modules/content-type/index.js [app-client] (ecmascript)");
var mime = __turbopack_context__.r("[project]/node_modules/type-is/node_modules/mime-types/index.js [app-client] (ecmascript)");
var typer = __turbopack_context__.r("[project]/node_modules/media-typer/index.js [app-client] (ecmascript)");
/**
 * Module exports.
 * @public
 */ module.exports = typeofrequest;
module.exports.is = typeis;
module.exports.hasBody = hasbody;
module.exports.normalize = normalize;
module.exports.match = mimeMatch;
/**
 * Compare a `value` content-type with `types`.
 * Each `type` can be an extension like `html`,
 * a special shortcut like `multipart` or `urlencoded`,
 * or a mime type.
 *
 * If no types match, `false` is returned.
 * Otherwise, the first `type` that matches is returned.
 *
 * @param {String} value
 * @param {Array} types
 * @public
 */ function typeis(value, types_) {
    var i;
    var types = types_;
    // remove parameters and normalize
    var val = tryNormalizeType(value);
    // no type or invalid
    if (!val) {
        return false;
    }
    // support flattened arguments
    if (types && !Array.isArray(types)) {
        types = new Array(arguments.length - 1);
        for(i = 0; i < types.length; i++){
            types[i] = arguments[i + 1];
        }
    }
    // no types, return the content type
    if (!types || !types.length) {
        return val;
    }
    var type;
    for(i = 0; i < types.length; i++){
        if (mimeMatch(normalize(type = types[i]), val)) {
            return type[0] === '+' || type.indexOf('*') !== -1 ? val : type;
        }
    }
    // no matches
    return false;
}
/**
 * Check if a request has a request body.
 * A request with a body __must__ either have `transfer-encoding`
 * or `content-length` headers set.
 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
 *
 * @param {Object} request
 * @return {Boolean}
 * @public
 */ function hasbody(req) {
    return req.headers['transfer-encoding'] !== undefined || !isNaN(req.headers['content-length']);
}
/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains any of the give mime `type`s.
 * If there is no request body, `null` is returned.
 * If there is no content type, `false` is returned.
 * Otherwise, it returns the first `type` that matches.
 *
 * Examples:
 *
 *     // With Content-Type: text/html; charset=utf-8
 *     this.is('html'); // => 'html'
 *     this.is('text/html'); // => 'text/html'
 *     this.is('text/*', 'application/json'); // => 'text/html'
 *
 *     // When Content-Type is application/json
 *     this.is('json', 'urlencoded'); // => 'json'
 *     this.is('application/json'); // => 'application/json'
 *     this.is('html', 'application/*'); // => 'application/json'
 *
 *     this.is('html'); // => false
 *
 * @param {Object} req
 * @param {(String|Array)} types...
 * @return {(String|false|null)}
 * @public
 */ function typeofrequest(req, types_) {
    // no body
    if (!hasbody(req)) return null;
    // support flattened arguments
    var types = arguments.length > 2 ? Array.prototype.slice.call(arguments, 1) : types_;
    // request content type
    var value = req.headers['content-type'];
    return typeis(value, types);
}
/**
 * Normalize a mime type.
 * If it's a shorthand, expand it to a valid mime type.
 *
 * In general, you probably want:
 *
 *   var type = is(req, ['urlencoded', 'json', 'multipart']);
 *
 * Then use the appropriate body parsers.
 * These three are the most common request body types
 * and are thus ensured to work.
 *
 * @param {String} type
 * @return {String|false|null}
 * @public
 */ function normalize(type) {
    if (typeof type !== 'string') {
        // invalid type
        return false;
    }
    switch(type){
        case 'urlencoded':
            return 'application/x-www-form-urlencoded';
        case 'multipart':
            return 'multipart/*';
    }
    if (type[0] === '+') {
        // "+json" -> "*/*+json" expando
        return '*/*' + type;
    }
    return type.indexOf('/') === -1 ? mime.lookup(type) : type;
}
/**
 * Check if `expected` mime type
 * matches `actual` mime type with
 * wildcard and +suffix support.
 *
 * @param {String} expected
 * @param {String} actual
 * @return {Boolean}
 * @public
 */ function mimeMatch(expected, actual) {
    // invalid type
    if (expected === false) {
        return false;
    }
    // split types
    var actualParts = actual.split('/');
    var expectedParts = expected.split('/');
    // invalid format
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
        return false;
    }
    // validate type
    if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
        return false;
    }
    // validate suffix wildcard
    if (expectedParts[1].slice(0, 2) === '*+') {
        return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].slice(1) === actualParts[1].slice(1 - expectedParts[1].length);
    }
    // validate subtype
    if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
        return false;
    }
    return true;
}
/**
 * Normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {(string|null)}
 * @private
 */ function normalizeType(value) {
    // Parse the type
    var type = contentType.parse(value).type;
    return typer.test(type) ? type : null;
}
/**
 * Try to normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {(string|null)}
 * @private
 */ function tryNormalizeType(value) {
    try {
        return value ? normalizeType(value) : null;
    } catch (err) {
        return null;
    }
}
}}),
"[project]/node_modules/es-errors/type.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./type')} */ module.exports = TypeError;
}}),
"[project]/node_modules/es-errors/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('.')} */ module.exports = Error;
}}),
"[project]/node_modules/es-errors/eval.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./eval')} */ module.exports = EvalError;
}}),
"[project]/node_modules/es-errors/range.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./range')} */ module.exports = RangeError;
}}),
"[project]/node_modules/es-errors/ref.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./ref')} */ module.exports = ReferenceError;
}}),
"[project]/node_modules/es-errors/syntax.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./syntax')} */ module.exports = SyntaxError;
}}),
"[project]/node_modules/es-errors/uri.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./uri')} */ module.exports = URIError;
}}),
"[project]/node_modules/object-inspect/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol') ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype // eslint-disable-line no-proto
 ? function(O) {
    return O.__proto__; // eslint-disable-line no-proto
} : null);
function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}
var utilInspect = {};
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
var quotes = {
    __proto__: null,
    'double': '"',
    single: "'"
};
var quoteREs = {
    __proto__: null,
    'double': /(["\\])/g,
    single: /(['\\])/g
};
module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number' ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }
    if (has(opts, 'indent') && opts.indent !== null && opts.indent !== '\t' && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }
    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') {
        depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }
    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === 'function' && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for(var i = 0; i < attrs.length; i++){
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) {
            s += '...';
        }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) {
            return '[]';
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) {
            return '[' + String(obj) + ']';
        }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, {
                depth: maxDepth - depth
            });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function(value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function(value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */ if (typeof window !== 'undefined' && obj === window) {
        return '{ [object Window] }';
    }
    if (typeof globalThis !== 'undefined' && obj === globalThis || typeof global !== 'undefined' && obj === global) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) {
            return tag + '{}';
        }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};
function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
}
function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}
function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));
}
function isArray(obj) {
    return toStr(obj) === '[object Array]' && canTrustToString(obj);
}
function isDate(obj) {
    return toStr(obj) === '[object Date]' && canTrustToString(obj);
}
function isRegExp(obj) {
    return toStr(obj) === '[object RegExp]' && canTrustToString(obj);
}
function isError(obj) {
    return toStr(obj) === '[object Error]' && canTrustToString(obj);
}
function isString(obj) {
    return toStr(obj) === '[object String]' && canTrustToString(obj);
}
function isNumber(obj) {
    return toStr(obj) === '[object Number]' && canTrustToString(obj);
}
function isBoolean(obj) {
    return toStr(obj) === '[object Boolean]' && canTrustToString(obj);
}
// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}
function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}
var hasOwn = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
};
function has(obj, key) {
    return hasOwn.call(obj, key);
}
function toStr(obj) {
    return objectToString.call(obj);
}
function nameOf(f) {
    if (f.name) {
        return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
        return m[1];
    }
    return null;
}
function indexOf(xs, x) {
    if (xs.indexOf) {
        return xs.indexOf(x);
    }
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) {
            return i;
        }
    }
    return -1;
}
function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}
function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}
function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}
function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}
function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}
function isElement(x) {
    if (!x || typeof x !== 'object') {
        return false;
    }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}
function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || 'single'];
    quoteRE.lastIndex = 0;
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}
function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) {
        return '\\' + x;
    }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}
function markBoxed(str) {
    return 'Object(' + str + ')';
}
function weakCollectionOf(type) {
    return type + ' { ? }';
}
function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}
function singleLineValues(xs) {
    for(var i = 0; i < xs.length; i++){
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}
function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}
function indentedJoin(xs, indent) {
    if (xs.length === 0) {
        return '';
    }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}
function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for(var i = 0; i < obj.length; i++){
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for(var k = 0; k < syms.length; k++){
            symMap['$' + syms[k]] = syms[k];
        }
    }
    for(var key in obj){
        if (!has(obj, key)) {
            continue;
        } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) {
            continue;
        } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for(var j = 0; j < syms.length; j++){
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}
}}),
"[project]/node_modules/side-channel-list/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var inspect = __turbopack_context__.r("[project]/node_modules/object-inspect/index.js [app-client] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-client] (ecmascript)");
/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
* By doing so, all the recently used nodes can be accessed relatively quickly.
*/ /** @type {import('./list.d.ts').listGetNode} */ // eslint-disable-next-line consistent-return
var listGetNode = function(list, key, isDelete) {
    /** @type {typeof list | NonNullable<(typeof list)['next']>} */ var prev = list;
    /** @type {(typeof list)['next']} */ var curr;
    // eslint-disable-next-line eqeqeq
    for(; (curr = prev.next) != null; prev = curr){
        if (curr.key === key) {
            prev.next = curr.next;
            if (!isDelete) {
                // eslint-disable-next-line no-extra-parens
                curr.next = list.next;
                list.next = curr; // eslint-disable-line no-param-reassign
            }
            return curr;
        }
    }
};
/** @type {import('./list.d.ts').listGet} */ var listGet = function(objects, key) {
    if (!objects) {
        return void undefined;
    }
    var node = listGetNode(objects, key);
    return node && node.value;
};
/** @type {import('./list.d.ts').listSet} */ var listSet = function(objects, key, value) {
    var node = listGetNode(objects, key);
    if (node) {
        node.value = value;
    } else {
        // Prepend the new node to the beginning of the list
        objects.next = {
            key: key,
            next: objects.next,
            value: value
        };
    }
};
/** @type {import('./list.d.ts').listHas} */ var listHas = function(objects, key) {
    if (!objects) {
        return false;
    }
    return !!listGetNode(objects, key);
};
/** @type {import('./list.d.ts').listDelete} */ // eslint-disable-next-line consistent-return
var listDelete = function(objects, key) {
    if (objects) {
        return listGetNode(objects, key, true);
    }
};
/** @type {import('.')} */ module.exports = function getSideChannelList() {
    /** @typedef {ReturnType<typeof getSideChannelList>} Channel */ /** @typedef {Parameters<Channel['get']>[0]} K */ /** @typedef {Parameters<Channel['set']>[1]} V */ /** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;
    /** @type {Channel} */ var channel = {
        assert: function(key) {
            if (!channel.has(key)) {
                throw new $TypeError('Side channel does not contain ' + inspect(key));
            }
        },
        'delete': function(key) {
            var root = $o && $o.next;
            var deletedNode = listDelete($o, key);
            if (deletedNode && root && root === deletedNode) {
                $o = void undefined;
            }
            return !!deletedNode;
        },
        get: function(key) {
            return listGet($o, key);
        },
        has: function(key) {
            return listHas($o, key);
        },
        set: function(key, value) {
            if (!$o) {
                // Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
                $o = {
                    next: void undefined
                };
            }
            // eslint-disable-next-line no-extra-parens
            listSet($o, key, value);
        }
    };
    // @ts-expect-error TODO: figure out why this is erroring
    return channel;
};
}}),
"[project]/node_modules/es-object-atoms/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('.')} */ module.exports = Object;
}}),
"[project]/node_modules/math-intrinsics/abs.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./abs')} */ module.exports = Math.abs;
}}),
"[project]/node_modules/math-intrinsics/floor.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./floor')} */ module.exports = Math.floor;
}}),
"[project]/node_modules/math-intrinsics/max.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./max')} */ module.exports = Math.max;
}}),
"[project]/node_modules/math-intrinsics/min.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./min')} */ module.exports = Math.min;
}}),
"[project]/node_modules/math-intrinsics/pow.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./pow')} */ module.exports = Math.pow;
}}),
"[project]/node_modules/math-intrinsics/round.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./round')} */ module.exports = Math.round;
}}),
"[project]/node_modules/math-intrinsics/isNaN.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./isNaN')} */ module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
};
}}),
"[project]/node_modules/math-intrinsics/sign.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var $isNaN = __turbopack_context__.r("[project]/node_modules/math-intrinsics/isNaN.js [app-client] (ecmascript)");
/** @type {import('./sign')} */ module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
        return number;
    }
    return number < 0 ? -1 : +1;
};
}}),
"[project]/node_modules/gopd/gOPD.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./gOPD')} */ module.exports = Object.getOwnPropertyDescriptor;
}}),
"[project]/node_modules/gopd/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('.')} */ var $gOPD = __turbopack_context__.r("[project]/node_modules/gopd/gOPD.js [app-client] (ecmascript)");
if ($gOPD) {
    try {
        $gOPD([], 'length');
    } catch (e) {
        // IE 8 has a broken gOPD
        $gOPD = null;
    }
}
module.exports = $gOPD;
}}),
"[project]/node_modules/es-define-property/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('.')} */ var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
    try {
        $defineProperty({}, 'a', {
            value: 1
        });
    } catch (e) {
        // IE 8 has a broken defineProperty
        $defineProperty = false;
    }
}
module.exports = $defineProperty;
}}),
"[project]/node_modules/has-symbols/shams.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./shams')} */ /* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
        return false;
    }
    if (typeof Symbol.iterator === 'symbol') {
        return true;
    }
    /** @type {{ [k in symbol]?: unknown }} */ var obj = {};
    var sym = Symbol('test');
    var symObj = Object(sym);
    if (typeof sym === 'string') {
        return false;
    }
    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
        return false;
    }
    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
        return false;
    }
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(var _ in obj){
        return false;
    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
        return false;
    }
    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
        return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === 'function') {
        // eslint-disable-next-line no-extra-parens
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
        }
    }
    return true;
};
}}),
"[project]/node_modules/has-symbols/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __turbopack_context__.r("[project]/node_modules/has-symbols/shams.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== 'function') {
        return false;
    }
    if (typeof Symbol !== 'function') {
        return false;
    }
    if (typeof origSymbol('foo') !== 'symbol') {
        return false;
    }
    if (typeof Symbol('bar') !== 'symbol') {
        return false;
    }
    return hasSymbolSham();
};
}}),
"[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./Reflect.getPrototypeOf')} */ module.exports = typeof Reflect !== 'undefined' && Reflect.getPrototypeOf || null;
}}),
"[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var $Object = __turbopack_context__.r("[project]/node_modules/es-object-atoms/index.js [app-client] (ecmascript)");
/** @type {import('./Object.getPrototypeOf')} */ module.exports = $Object.getPrototypeOf || null;
}}),
"[project]/node_modules/get-proto/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var reflectGetProto = __turbopack_context__.r("[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-client] (ecmascript)");
var originalGetProto = __turbopack_context__.r("[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-client] (ecmascript)");
var getDunderProto = __turbopack_context__.r("[project]/node_modules/dunder-proto/get.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = reflectGetProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return reflectGetProto(O);
} : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== 'object' && typeof O !== 'function') {
        throw new TypeError('getProto: not an object');
    }
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return originalGetProto(O);
} : getDunderProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return getDunderProto(O);
} : null;
}}),
"[project]/node_modules/function-bind/implementation.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';
var concatty = function concatty(a, b) {
    var arr = [];
    for(var i = 0; i < a.length; i += 1){
        arr[i] = a[i];
    }
    for(var j = 0; j < b.length; j += 1){
        arr[j + a.length] = b[j];
    }
    return arr;
};
var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1){
        arr[j] = arrLike[i];
    }
    return arr;
};
var joiny = function(arr, joiner) {
    var str = '';
    for(var i = 0; i < arr.length; i += 1){
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};
module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(this, concatty(args, arguments));
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for(var i = 0; i < boundLength; i++){
        boundArgs[i] = '$' + i;
    }
    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
};
}}),
"[project]/node_modules/function-bind/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var implementation = __turbopack_context__.r("[project]/node_modules/function-bind/implementation.js [app-client] (ecmascript)");
module.exports = Function.prototype.bind || implementation;
}}),
"[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./functionCall')} */ module.exports = Function.prototype.call;
}}),
"[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./functionApply')} */ module.exports = Function.prototype.apply;
}}),
"[project]/node_modules/call-bind-apply-helpers/reflectApply.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./reflectApply')} */ module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;
}}),
"[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-client] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-client] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-client] (ecmascript)");
var $reflectApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/reflectApply.js [app-client] (ecmascript)");
/** @type {import('./actualApply')} */ module.exports = $reflectApply || bind.call($call, $apply);
}}),
"[project]/node_modules/call-bind-apply-helpers/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-client] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-client] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-client] (ecmascript)");
var $actualApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-client] (ecmascript)");
/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */ module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== 'function') {
        throw new $TypeError('a function is required');
    }
    return $actualApply(bind, $call, args);
};
}}),
"[project]/node_modules/dunder-proto/get.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var callBind = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/index.js [app-client] (ecmascript)");
var gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-client] (ecmascript)");
var hasProtoAccessor;
try {
    // eslint-disable-next-line no-extra-parens, no-proto
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ [].__proto__ === Array.prototype;
} catch (e) {
    if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
        throw e;
    }
}
// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, '__proto__');
var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;
/** @type {import('./get')} */ module.exports = desc && typeof desc.get === 'function' ? callBind([
    desc.get
]) : typeof $getPrototypeOf === 'function' ? /** @type {import('./get')} */ function getDunder(value) {
    // eslint-disable-next-line eqeqeq
    return $getPrototypeOf(value == null ? value : $Object(value));
} : false;
}}),
"[project]/node_modules/hasown/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = bind.call(call, $hasOwn);
}}),
"[project]/node_modules/get-intrinsic/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var undefined1;
var $Object = __turbopack_context__.r("[project]/node_modules/es-object-atoms/index.js [app-client] (ecmascript)");
var $Error = __turbopack_context__.r("[project]/node_modules/es-errors/index.js [app-client] (ecmascript)");
var $EvalError = __turbopack_context__.r("[project]/node_modules/es-errors/eval.js [app-client] (ecmascript)");
var $RangeError = __turbopack_context__.r("[project]/node_modules/es-errors/range.js [app-client] (ecmascript)");
var $ReferenceError = __turbopack_context__.r("[project]/node_modules/es-errors/ref.js [app-client] (ecmascript)");
var $SyntaxError = __turbopack_context__.r("[project]/node_modules/es-errors/syntax.js [app-client] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-client] (ecmascript)");
var $URIError = __turbopack_context__.r("[project]/node_modules/es-errors/uri.js [app-client] (ecmascript)");
var abs = __turbopack_context__.r("[project]/node_modules/math-intrinsics/abs.js [app-client] (ecmascript)");
var floor = __turbopack_context__.r("[project]/node_modules/math-intrinsics/floor.js [app-client] (ecmascript)");
var max = __turbopack_context__.r("[project]/node_modules/math-intrinsics/max.js [app-client] (ecmascript)");
var min = __turbopack_context__.r("[project]/node_modules/math-intrinsics/min.js [app-client] (ecmascript)");
var pow = __turbopack_context__.r("[project]/node_modules/math-intrinsics/pow.js [app-client] (ecmascript)");
var round = __turbopack_context__.r("[project]/node_modules/math-intrinsics/round.js [app-client] (ecmascript)");
var sign = __turbopack_context__.r("[project]/node_modules/math-intrinsics/sign.js [app-client] (ecmascript)");
var $Function = Function;
// eslint-disable-next-line consistent-return
var getEvalledConstructor = function(expressionSyntax) {
    try {
        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    } catch (e) {}
};
var $gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-client] (ecmascript)");
var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-client] (ecmascript)");
var throwTypeError = function() {
    throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
    try {
        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
        arguments.callee; // IE 8 does not throw here
        return throwTypeError;
    } catch (calleeThrows) {
        try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, 'callee').get;
        } catch (gOPDthrows) {
            return throwTypeError;
        }
    }
}() : throwTypeError;
var hasSymbols = __turbopack_context__.r("[project]/node_modules/has-symbols/index.js [app-client] (ecmascript)")();
var getProto = __turbopack_context__.r("[project]/node_modules/get-proto/index.js [app-client] (ecmascript)");
var $ObjectGPO = __turbopack_context__.r("[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-client] (ecmascript)");
var $ReflectGPO = __turbopack_context__.r("[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-client] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-client] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-client] (ecmascript)");
var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
    __proto__: null,
    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
    '%AsyncFromSyncIteratorPrototype%': undefined,
    '%AsyncFunction%': needsEval,
    '%AsyncGenerator%': needsEval,
    '%AsyncGeneratorFunction%': needsEval,
    '%AsyncIteratorPrototype%': needsEval,
    '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
    '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': $Error,
    '%eval%': eval,
    '%EvalError%': $EvalError,
    '%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
    '%Function%': $Function,
    '%GeneratorFunction%': needsEval,
    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
    '%JSON%': typeof JSON === 'object' ? JSON : undefined,
    '%Map%': typeof Map === 'undefined' ? undefined : Map,
    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': $Object,
    '%Object.getOwnPropertyDescriptor%': $gOPD,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
    '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
    '%RangeError%': $RangeError,
    '%ReferenceError%': $ReferenceError,
    '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set === 'undefined' ? undefined : Set,
    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
    '%Symbol%': hasSymbols ? Symbol : undefined,
    '%SyntaxError%': $SyntaxError,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%TypeError%': $TypeError,
    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
    '%URIError%': $URIError,
    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
    '%Function.prototype.call%': $call,
    '%Function.prototype.apply%': $apply,
    '%Object.defineProperty%': $defineProperty,
    '%Object.getPrototypeOf%': $ObjectGPO,
    '%Math.abs%': abs,
    '%Math.floor%': floor,
    '%Math.max%': max,
    '%Math.min%': min,
    '%Math.pow%': pow,
    '%Math.round%': round,
    '%Math.sign%': sign,
    '%Reflect.getPrototypeOf%': $ReflectGPO
};
if (getProto) {
    try {
        null.error; // eslint-disable-line no-unused-expressions
    } catch (e) {
        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
        var errorProto = getProto(getProto(e));
        INTRINSICS['%Error.prototype%'] = errorProto;
    }
}
var doEval = function doEval(name) {
    var value;
    if (name === '%AsyncFunction%') {
        value = getEvalledConstructor('async function () {}');
    } else if (name === '%GeneratorFunction%') {
        value = getEvalledConstructor('function* () {}');
    } else if (name === '%AsyncGeneratorFunction%') {
        value = getEvalledConstructor('async function* () {}');
    } else if (name === '%AsyncGenerator%') {
        var fn = doEval('%AsyncGeneratorFunction%');
        if (fn) {
            value = fn.prototype;
        }
    } else if (name === '%AsyncIteratorPrototype%') {
        var gen = doEval('%AsyncGenerator%');
        if (gen && getProto) {
            value = getProto(gen.prototype);
        }
    }
    INTRINSICS[name] = value;
    return value;
};
var LEGACY_ALIASES = {
    __proto__: null,
    '%ArrayBufferPrototype%': [
        'ArrayBuffer',
        'prototype'
    ],
    '%ArrayPrototype%': [
        'Array',
        'prototype'
    ],
    '%ArrayProto_entries%': [
        'Array',
        'prototype',
        'entries'
    ],
    '%ArrayProto_forEach%': [
        'Array',
        'prototype',
        'forEach'
    ],
    '%ArrayProto_keys%': [
        'Array',
        'prototype',
        'keys'
    ],
    '%ArrayProto_values%': [
        'Array',
        'prototype',
        'values'
    ],
    '%AsyncFunctionPrototype%': [
        'AsyncFunction',
        'prototype'
    ],
    '%AsyncGenerator%': [
        'AsyncGeneratorFunction',
        'prototype'
    ],
    '%AsyncGeneratorPrototype%': [
        'AsyncGeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%BooleanPrototype%': [
        'Boolean',
        'prototype'
    ],
    '%DataViewPrototype%': [
        'DataView',
        'prototype'
    ],
    '%DatePrototype%': [
        'Date',
        'prototype'
    ],
    '%ErrorPrototype%': [
        'Error',
        'prototype'
    ],
    '%EvalErrorPrototype%': [
        'EvalError',
        'prototype'
    ],
    '%Float32ArrayPrototype%': [
        'Float32Array',
        'prototype'
    ],
    '%Float64ArrayPrototype%': [
        'Float64Array',
        'prototype'
    ],
    '%FunctionPrototype%': [
        'Function',
        'prototype'
    ],
    '%Generator%': [
        'GeneratorFunction',
        'prototype'
    ],
    '%GeneratorPrototype%': [
        'GeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%Int8ArrayPrototype%': [
        'Int8Array',
        'prototype'
    ],
    '%Int16ArrayPrototype%': [
        'Int16Array',
        'prototype'
    ],
    '%Int32ArrayPrototype%': [
        'Int32Array',
        'prototype'
    ],
    '%JSONParse%': [
        'JSON',
        'parse'
    ],
    '%JSONStringify%': [
        'JSON',
        'stringify'
    ],
    '%MapPrototype%': [
        'Map',
        'prototype'
    ],
    '%NumberPrototype%': [
        'Number',
        'prototype'
    ],
    '%ObjectPrototype%': [
        'Object',
        'prototype'
    ],
    '%ObjProto_toString%': [
        'Object',
        'prototype',
        'toString'
    ],
    '%ObjProto_valueOf%': [
        'Object',
        'prototype',
        'valueOf'
    ],
    '%PromisePrototype%': [
        'Promise',
        'prototype'
    ],
    '%PromiseProto_then%': [
        'Promise',
        'prototype',
        'then'
    ],
    '%Promise_all%': [
        'Promise',
        'all'
    ],
    '%Promise_reject%': [
        'Promise',
        'reject'
    ],
    '%Promise_resolve%': [
        'Promise',
        'resolve'
    ],
    '%RangeErrorPrototype%': [
        'RangeError',
        'prototype'
    ],
    '%ReferenceErrorPrototype%': [
        'ReferenceError',
        'prototype'
    ],
    '%RegExpPrototype%': [
        'RegExp',
        'prototype'
    ],
    '%SetPrototype%': [
        'Set',
        'prototype'
    ],
    '%SharedArrayBufferPrototype%': [
        'SharedArrayBuffer',
        'prototype'
    ],
    '%StringPrototype%': [
        'String',
        'prototype'
    ],
    '%SymbolPrototype%': [
        'Symbol',
        'prototype'
    ],
    '%SyntaxErrorPrototype%': [
        'SyntaxError',
        'prototype'
    ],
    '%TypedArrayPrototype%': [
        'TypedArray',
        'prototype'
    ],
    '%TypeErrorPrototype%': [
        'TypeError',
        'prototype'
    ],
    '%Uint8ArrayPrototype%': [
        'Uint8Array',
        'prototype'
    ],
    '%Uint8ClampedArrayPrototype%': [
        'Uint8ClampedArray',
        'prototype'
    ],
    '%Uint16ArrayPrototype%': [
        'Uint16Array',
        'prototype'
    ],
    '%Uint32ArrayPrototype%': [
        'Uint32Array',
        'prototype'
    ],
    '%URIErrorPrototype%': [
        'URIError',
        'prototype'
    ],
    '%WeakMapPrototype%': [
        'WeakMap',
        'prototype'
    ],
    '%WeakSetPrototype%': [
        'WeakSet',
        'prototype'
    ]
};
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-client] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/hasown/index.js [app-client] (ecmascript)");
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === '%' && last !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
    } else if (last === '%' && first !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    });
    return result;
};
/* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = '%' + alias[0] + '%';
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
            value = doEval(intrinsicName);
        }
        if (typeof value === 'undefined' && !allowMissing) {
            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
        }
        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }
    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== 'string' || name.length === 0) {
        throw new $TypeError('intrinsic name must be a non-empty string');
    }
    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
        throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([
            0,
            1
        ], alias));
    }
    for(var i = 1, isOwn = true; i < parts.length; i += 1){
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
            throw new $SyntaxError('property names with quotes must have matching quotes');
        }
        if (part === 'constructor' || !isOwn) {
            skipFurtherCaching = true;
        }
        intrinsicBaseName += '.' + part;
        intrinsicRealName = '%' + intrinsicBaseName + '%';
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) {
                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                }
                return void undefined;
            }
            if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                    value = desc.get;
                } else {
                    value = value[part];
                }
            } else {
                isOwn = hasOwn(value, part);
                value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
                INTRINSICS[intrinsicRealName] = value;
            }
        }
    }
    return value;
};
}}),
"[project]/node_modules/call-bound/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/get-intrinsic/index.js [app-client] (ecmascript)");
var callBindBasic = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/index.js [app-client] (ecmascript)");
/** @type {(thisArg: string, searchString: string, position?: number) => number} */ var $indexOf = callBindBasic([
    GetIntrinsic('%String.prototype.indexOf%')
]);
/** @type {import('.')} */ module.exports = function callBoundIntrinsic(name, allowMissing) {
    /* eslint no-extra-parens: 0 */ var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
        return callBindBasic([
            intrinsic
        ]);
    }
    return intrinsic;
};
}}),
"[project]/node_modules/side-channel-map/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/get-intrinsic/index.js [app-client] (ecmascript)");
var callBound = __turbopack_context__.r("[project]/node_modules/call-bound/index.js [app-client] (ecmascript)");
var inspect = __turbopack_context__.r("[project]/node_modules/object-inspect/index.js [app-client] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-client] (ecmascript)");
var $Map = GetIntrinsic('%Map%', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */ var $mapGet = callBound('Map.prototype.get', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */ var $mapSet = callBound('Map.prototype.set', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */ var $mapHas = callBound('Map.prototype.has', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */ var $mapDelete = callBound('Map.prototype.delete', true);
/** @type {<K, V>(thisArg: Map<K, V>) => number} */ var $mapSize = callBound('Map.prototype.size', true);
/** @type {import('.')} */ module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */ function getSideChannelMap() {
    /** @typedef {ReturnType<typeof getSideChannelMap>} Channel */ /** @typedef {Parameters<Channel['get']>[0]} K */ /** @typedef {Parameters<Channel['set']>[1]} V */ /** @type {Map<K, V> | undefined} */ var $m;
    /** @type {Channel} */ var channel = {
        assert: function(key) {
            if (!channel.has(key)) {
                throw new $TypeError('Side channel does not contain ' + inspect(key));
            }
        },
        'delete': function(key) {
            if ($m) {
                var result = $mapDelete($m, key);
                if ($mapSize($m) === 0) {
                    $m = void undefined;
                }
                return result;
            }
            return false;
        },
        get: function(key) {
            if ($m) {
                return $mapGet($m, key);
            }
        },
        has: function(key) {
            if ($m) {
                return $mapHas($m, key);
            }
            return false;
        },
        set: function(key, value) {
            if (!$m) {
                // @ts-expect-error TS can't handle narrowing a variable inside a closure
                $m = new $Map();
            }
            $mapSet($m, key, value);
        }
    };
    // @ts-expect-error TODO: figure out why TS is erroring here
    return channel;
};
}}),
"[project]/node_modules/side-channel-weakmap/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/get-intrinsic/index.js [app-client] (ecmascript)");
var callBound = __turbopack_context__.r("[project]/node_modules/call-bound/index.js [app-client] (ecmascript)");
var inspect = __turbopack_context__.r("[project]/node_modules/object-inspect/index.js [app-client] (ecmascript)");
var getSideChannelMap = __turbopack_context__.r("[project]/node_modules/side-channel-map/index.js [app-client] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-client] (ecmascript)");
var $WeakMap = GetIntrinsic('%WeakMap%', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */ var $weakMapGet = callBound('WeakMap.prototype.get', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */ var $weakMapSet = callBound('WeakMap.prototype.set', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */ var $weakMapHas = callBound('WeakMap.prototype.has', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */ var $weakMapDelete = callBound('WeakMap.prototype.delete', true);
/** @type {import('.')} */ module.exports = $WeakMap ? /** @type {Exclude<import('.'), false>} */ function getSideChannelWeakMap() {
    /** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */ /** @typedef {Parameters<Channel['get']>[0]} K */ /** @typedef {Parameters<Channel['set']>[1]} V */ /** @type {WeakMap<K & object, V> | undefined} */ var $wm;
    /** @type {Channel | undefined} */ var $m;
    /** @type {Channel} */ var channel = {
        assert: function(key) {
            if (!channel.has(key)) {
                throw new $TypeError('Side channel does not contain ' + inspect(key));
            }
        },
        'delete': function(key) {
            if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                if ($wm) {
                    return $weakMapDelete($wm, key);
                }
            } else if (getSideChannelMap) {
                if ($m) {
                    return $m['delete'](key);
                }
            }
            return false;
        },
        get: function(key) {
            if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                if ($wm) {
                    return $weakMapGet($wm, key);
                }
            }
            return $m && $m.get(key);
        },
        has: function(key) {
            if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                if ($wm) {
                    return $weakMapHas($wm, key);
                }
            }
            return !!$m && $m.has(key);
        },
        set: function(key, value) {
            if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                if (!$wm) {
                    $wm = new $WeakMap();
                }
                $weakMapSet($wm, key, value);
            } else if (getSideChannelMap) {
                if (!$m) {
                    $m = getSideChannelMap();
                }
                // eslint-disable-next-line no-extra-parens
                /** @type {NonNullable<typeof $m>} */ $m.set(key, value);
            }
        }
    };
    // @ts-expect-error TODO: figure out why this is erroring
    return channel;
} : getSideChannelMap;
}}),
"[project]/node_modules/side-channel/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-client] (ecmascript)");
var inspect = __turbopack_context__.r("[project]/node_modules/object-inspect/index.js [app-client] (ecmascript)");
var getSideChannelList = __turbopack_context__.r("[project]/node_modules/side-channel-list/index.js [app-client] (ecmascript)");
var getSideChannelMap = __turbopack_context__.r("[project]/node_modules/side-channel-map/index.js [app-client] (ecmascript)");
var getSideChannelWeakMap = __turbopack_context__.r("[project]/node_modules/side-channel-weakmap/index.js [app-client] (ecmascript)");
var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
/** @type {import('.')} */ module.exports = function getSideChannel() {
    /** @typedef {ReturnType<typeof getSideChannel>} Channel */ /** @type {Channel | undefined} */ var $channelData;
    /** @type {Channel} */ var channel = {
        assert: function(key) {
            if (!channel.has(key)) {
                throw new $TypeError('Side channel does not contain ' + inspect(key));
            }
        },
        'delete': function(key) {
            return !!$channelData && $channelData['delete'](key);
        },
        get: function(key) {
            return $channelData && $channelData.get(key);
        },
        has: function(key) {
            return !!$channelData && $channelData.has(key);
        },
        set: function(key, value) {
            if (!$channelData) {
                $channelData = makeChannel();
            }
            $channelData.set(key, value);
        }
    };
    // @ts-expect-error TODO: figure out why this is erroring
    return channel;
};
}}),
"[project]/node_modules/qs/lib/formats.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};
module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function(value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function(value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};
}}),
"[project]/node_modules/qs/lib/utils.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var formats = __turbopack_context__.r("[project]/node_modules/qs/lib/formats.js [app-client] (ecmascript)");
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var hexTable = function() {
    var array = [];
    for(var i = 0; i < 256; ++i){
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }
    return array;
}();
var compactQueue = function compactQueue(queue) {
    while(queue.length > 1){
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
            var compacted = [];
            for(var j = 0; j < obj.length; ++j){
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }
            item.obj[item.prop] = compacted;
        }
    }
};
var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? {
        __proto__: null
    } : {};
    for(var i = 0; i < source.length; ++i){
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }
    return obj;
};
var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */ if (!source) {
        return target;
    }
    if (typeof source !== 'object' && typeof source !== 'function') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [
                target,
                source
            ];
        }
        return target;
    }
    if (!target || typeof target !== 'object') {
        return [
            target
        ].concat(source);
    }
    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }
    if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};
var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};
var decode = function(str, defaultDecoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};
var limit = 1024;
/* eslint operator-linebreak: [2, "before"] */ var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }
    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }
    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }
    var out = '';
    for(var j = 0; j < string.length; j += limit){
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for(var i = 0; i < segment.length; ++i){
            var c = segment.charCodeAt(i);
            if (c === 0x2D // -
             || c === 0x2E // .
             || c === 0x5F // _
             || c === 0x7E // ~
             || c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A || format === formats.RFC1738 && (c === 0x28 || c === 0x29) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }
            if (c < 0x80) {
                arr[arr.length] = hexTable[c];
                continue;
            }
            if (c < 0x800) {
                arr[arr.length] = hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F];
                continue;
            }
            if (c < 0xD800 || c >= 0xE000) {
                arr[arr.length] = hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
                continue;
            }
            i += 1;
            c = 0x10000 + ((c & 0x3FF) << 10 | segment.charCodeAt(i) & 0x3FF);
            arr[arr.length] = hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
        }
        out += arr.join('');
    }
    return out;
};
var compact = function compact(value) {
    var queue = [
        {
            obj: {
                o: value
            },
            prop: 'o'
        }
    ];
    var refs = [];
    for(var i = 0; i < queue.length; ++i){
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for(var j = 0; j < keys.length; ++j){
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({
                    obj: obj,
                    prop: key
                });
                refs.push(val);
            }
        }
    }
    compactQueue(queue);
    return value;
};
var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};
var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine(a, b) {
    return [].concat(a, b);
};
var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for(var i = 0; i < val.length; i += 1){
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};
module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};
}}),
"[project]/node_modules/qs/lib/stringify.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var getSideChannel = __turbopack_context__.r("[project]/node_modules/side-channel/index.js [app-client] (ecmascript)");
var utils = __turbopack_context__.r("[project]/node_modules/qs/lib/utils.js [app-client] (ecmascript)");
var formats = __turbopack_context__.r("[project]/node_modules/qs/lib/formats.js [app-client] (ecmascript)");
var has = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};
var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [
        valueOrArray
    ]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    filter: void undefined,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || typeof v === 'symbol' || typeof v === 'bigint';
};
var sentinel = {};
var stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
    var obj = object;
    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag){
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }
    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }
        obj = '';
    }
    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [
                formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))
            ];
        }
        return [
            formatter(prefix) + '=' + formatter(String(obj))
        ];
    }
    var values = [];
    if (typeof obj === 'undefined') {
        return values;
    }
    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [
            {
                value: obj.length > 0 ? obj.join(',') || null : void undefined
            }
        ];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }
    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, '%2E') : String(prefix);
    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;
    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + '[]';
    }
    for(var j = 0; j < objKeys.length; ++j){
        var key = objKeys[j];
        var value = typeof key === 'object' && key && typeof key.value !== 'undefined' ? key.value : obj[key];
        if (skipNulls && value === null) {
            continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, '%2E') : String(key);
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
    }
    return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }
    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }
    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }
    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }
    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];
    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults.arrayFormat;
    }
    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }
    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};
module.exports = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;
    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== 'object' || obj === null) {
        return '';
    }
    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;
    if (!objKeys) {
        objKeys = Object.keys(obj);
    }
    if (options.sort) {
        objKeys.sort(options.sort);
    }
    var sideChannel = getSideChannel();
    for(var i = 0; i < objKeys.length; ++i){
        var key = objKeys[i];
        var value = obj[key];
        if (options.skipNulls && value === null) {
            continue;
        }
        pushToArray(keys, stringify(value, key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';
    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }
    return joined.length > 0 ? prefix + joined : '';
};
}}),
"[project]/node_modules/qs/lib/parse.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var utils = __turbopack_context__.r("[project]/node_modules/qs/lib/utils.js [app-client] (ecmascript)");
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
};
var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};
var parseArrayValue = function(val, options, currentArrayLength) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }
    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');
    }
    return val;
};
// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')
// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')
var parseValues = function parseQueryStringValues(str, options) {
    var obj = {
        __proto__: null
    };
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, options.throwOnLimitExceeded ? limit + 1 : limit);
    if (options.throwOnLimitExceeded && parts.length > limit) {
        throw new RangeError('Parameter limit exceeded. Only ' + limit + ' parameter' + (limit === 1 ? '' : 's') + ' allowed.');
    }
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;
    var charset = options.charset;
    if (options.charsetSentinel) {
        for(i = 0; i < parts.length; ++i){
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }
    for(i = 0; i < parts.length; ++i){
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;
        var key;
        var val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options, isArray(obj[key]) ? obj[key].length : 0), function(encodedVal) {
                return options.decoder(encodedVal, defaults.decoder, charset, 'value');
            });
        }
        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(String(val));
        }
        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [
                val
            ] : val;
        }
        var existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }
    return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
    var currentArrayLength = 0;
    if (chain.length > 0 && chain[chain.length - 1] === '[]') {
        var parentKey = chain.slice(0, -1).join('');
        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
    }
    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
    for(var i = chain.length - 1; i >= 0; --i){
        var obj;
        var root = chain[i];
        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && (leaf === '' || options.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf);
        } else {
            obj = options.plainObjects ? {
                __proto__: null
            } : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = {
                    0: leaf
                };
            } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }
        leaf = obj;
    }
    return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }
    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;
    // The regex chunks
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    // Get the parent
    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    // Stash the parent if it exists
    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(parent);
    }
    // Loop through children appending to the array until we hit depth
    var i = 0;
    while(options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth){
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }
    // If there's a remainder, check strictDepth option for throw, else just add whatever is left
    if (segment) {
        if (options.strictDepth === true) {
            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
        }
        keys.push('[' + key.slice(segment.index) + ']');
    }
    return parseObject(keys, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }
    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }
    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }
    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    if (typeof opts.throwOnLimitExceeded !== 'undefined' && typeof opts.throwOnLimitExceeded !== 'boolean') {
        throw new TypeError('`throwOnLimitExceeded` option must be a boolean');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;
    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;
    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }
    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === 'number' || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,
        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === 'boolean' ? opts.throwOnLimitExceeded : false
    };
};
module.exports = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? {
            __proto__: null
        } : {};
    }
    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? {
        __proto__: null
    } : {};
    // Iterate over the keys and setup the new object
    var keys = Object.keys(tempObj);
    for(var i = 0; i < keys.length; ++i){
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
        return obj;
    }
    return utils.compact(obj);
};
}}),
"[project]/node_modules/qs/lib/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var stringify = __turbopack_context__.r("[project]/node_modules/qs/lib/stringify.js [app-client] (ecmascript)");
var parse = __turbopack_context__.r("[project]/node_modules/qs/lib/parse.js [app-client] (ecmascript)");
var formats = __turbopack_context__.r("[project]/node_modules/qs/lib/formats.js [app-client] (ecmascript)");
module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};
}}),
"[project]/node_modules/merge-descriptors/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
function mergeDescriptors(destination, source, overwrite = true) {
    if (!destination) {
        throw new TypeError('The `destination` argument is required.');
    }
    if (!source) {
        throw new TypeError('The `source` argument is required.');
    }
    for (const name of Object.getOwnPropertyNames(source)){
        if (!overwrite && Object.hasOwn(destination, name)) {
            continue;
        }
        // Copy descriptor
        const descriptor = Object.getOwnPropertyDescriptor(source, name);
        Object.defineProperty(destination, name, descriptor);
    }
    return destination;
}
module.exports = mergeDescriptors;
}}),
"[project]/node_modules/finalhandler/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
'use strict';
/**
 * Module dependencies.
 * @private
 */ var debug = __turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)")('finalhandler');
var encodeUrl = __turbopack_context__.r("[project]/node_modules/encodeurl/index.js [app-client] (ecmascript)");
var escapeHtml = __turbopack_context__.r("[project]/node_modules/escape-html/index.js [app-client] (ecmascript)");
var onFinished = __turbopack_context__.r("[project]/node_modules/on-finished/index.js [app-client] (ecmascript)");
var parseUrl = __turbopack_context__.r("[project]/node_modules/parseurl/index.js [app-client] (ecmascript)");
var statuses = __turbopack_context__.r("[project]/node_modules/statuses/index.js [app-client] (ecmascript)");
/**
 * Module variables.
 * @private
 */ var isFinished = onFinished.isFinished;
/**
 * Create a minimal HTML document.
 *
 * @param {string} message
 * @private
 */ function createHtmlDocument(message) {
    var body = escapeHtml(message).replaceAll('\n', '<br>').replaceAll('  ', ' &nbsp;');
    return '<!DOCTYPE html>\n' + '<html lang="en">\n' + '<head>\n' + '<meta charset="utf-8">\n' + '<title>Error</title>\n' + '</head>\n' + '<body>\n' + '<pre>' + body + '</pre>\n' + '</body>\n' + '</html>\n';
}
/**
 * Module exports.
 * @public
 */ module.exports = finalhandler;
/**
 * Create a function to handle the final response.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {Object} [options]
 * @return {Function}
 * @public
 */ function finalhandler(req, res, options) {
    var opts = options || {};
    // get environment
    var env = opts.env || ("TURBOPACK compile-time value", "development") || 'development';
    // get error callback
    var onerror = opts.onerror;
    return function(err) {
        var headers;
        var msg;
        var status;
        // ignore 404 on in-flight response
        if (!err && res.headersSent) {
            debug('cannot 404 after headers sent');
            return;
        }
        // unhandled error
        if (err) {
            // respect status code from error
            status = getErrorStatusCode(err);
            if (status === undefined) {
                // fallback to status code on response
                status = getResponseStatusCode(res);
            } else {
                // respect headers from error
                headers = getErrorHeaders(err);
            }
            // get error message
            msg = getErrorMessage(err, status, env);
        } else {
            // not found
            status = 404;
            msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req));
        }
        debug('default %s', status);
        // schedule onerror callback
        if (err && onerror) {
            setImmediate(onerror, err, req, res);
        }
        // cannot actually respond
        if (res.headersSent) {
            debug('cannot %d after headers sent', status);
            if (req.socket) {
                req.socket.destroy();
            }
            return;
        }
        // send response
        send(req, res, status, headers, msg);
    };
}
/**
 * Get headers from Error object.
 *
 * @param {Error} err
 * @return {object}
 * @private
 */ function getErrorHeaders(err) {
    if (!err.headers || typeof err.headers !== 'object') {
        return undefined;
    }
    return {
        ...err.headers
    };
}
/**
 * Get message from Error object, fallback to status message.
 *
 * @param {Error} err
 * @param {number} status
 * @param {string} env
 * @return {string}
 * @private
 */ function getErrorMessage(err, status, env) {
    var msg;
    if (env !== 'production') {
        // use err.stack, which typically includes err.message
        msg = err.stack;
        // fallback to err.toString() when possible
        if (!msg && typeof err.toString === 'function') {
            msg = err.toString();
        }
    }
    return msg || statuses.message[status];
}
/**
 * Get status code from Error object.
 *
 * @param {Error} err
 * @return {number}
 * @private
 */ function getErrorStatusCode(err) {
    // check err.status
    if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) {
        return err.status;
    }
    // check err.statusCode
    if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) {
        return err.statusCode;
    }
    return undefined;
}
/**
 * Get resource name for the request.
 *
 * This is typically just the original pathname of the request
 * but will fallback to "resource" is that cannot be determined.
 *
 * @param {IncomingMessage} req
 * @return {string}
 * @private
 */ function getResourceName(req) {
    try {
        return parseUrl.original(req).pathname;
    } catch (e) {
        return 'resource';
    }
}
/**
 * Get status code from response.
 *
 * @param {OutgoingMessage} res
 * @return {number}
 * @private
 */ function getResponseStatusCode(res) {
    var status = res.statusCode;
    // default status code to 500 if outside valid range
    if (typeof status !== 'number' || status < 400 || status > 599) {
        status = 500;
    }
    return status;
}
/**
 * Send response.
 *
 * @param {IncomingMessage} req
 * @param {OutgoingMessage} res
 * @param {number} status
 * @param {object} headers
 * @param {string} message
 * @private
 */ function send(req, res, status, headers, message) {
    function write() {
        // response body
        var body = createHtmlDocument(message);
        // response status
        res.statusCode = status;
        if (req.httpVersionMajor < 2) {
            res.statusMessage = statuses.message[status];
        }
        // remove any content headers
        res.removeHeader('Content-Encoding');
        res.removeHeader('Content-Language');
        res.removeHeader('Content-Range');
        // response headers
        for (const [key, value] of Object.entries(headers ?? {})){
            res.setHeader(key, value);
        }
        // security headers
        res.setHeader('Content-Security-Policy', "default-src 'none'");
        res.setHeader('X-Content-Type-Options', 'nosniff');
        // standard headers
        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        res.setHeader('Content-Length', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].byteLength(body, 'utf8'));
        if (req.method === 'HEAD') {
            res.end();
            return;
        }
        res.end(body, 'utf8');
    }
    if (isFinished(req)) {
        write();
        return;
    }
    // unpipe everything from the request
    req.unpipe();
    // flush the request
    onFinished(req, write);
    req.resume();
}
}}),
"[project]/node_modules/express/lib/view.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
/**
 * Module dependencies.
 * @private
 */ var debug = __turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)")('express:view');
var path = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)");
var fs = (()=>{
    const e = new Error("Cannot find module 'node:fs': Unsupported external type Url for commonjs reference");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
/**
 * Module variables.
 * @private
 */ var dirname = path.dirname;
var basename = path.basename;
var extname = path.extname;
var join = path.join;
var resolve = path.resolve;
/**
 * Module exports.
 * @public
 */ module.exports = View;
/**
 * Initialize a new `View` with the given `name`.
 *
 * Options:
 *
 *   - `defaultEngine` the default template engine name
 *   - `engines` template engine require() cache
 *   - `root` root path for view lookup
 *
 * @param {string} name
 * @param {object} options
 * @public
 */ function View(name, options) {
    var opts = options || {};
    this.defaultEngine = opts.defaultEngine;
    this.ext = extname(name);
    this.name = name;
    this.root = opts.root;
    if (!this.ext && !this.defaultEngine) {
        throw new Error('No default engine was specified and no extension was provided.');
    }
    var fileName = name;
    if (!this.ext) {
        // get extension from default engine name
        this.ext = this.defaultEngine[0] !== '.' ? '.' + this.defaultEngine : this.defaultEngine;
        fileName += this.ext;
    }
    if (!opts.engines[this.ext]) {
        // load engine
        var mod = this.ext.slice(1);
        debug('require "%s"', mod);
        // default engine export
        var fn = (()=>{
            const e = new Error("Cannot find module 'unknown'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })().__express;
        if (typeof fn !== 'function') {
            throw new Error('Module "' + mod + '" does not provide a view engine.');
        }
        opts.engines[this.ext] = fn;
    }
    // store loaded engine
    this.engine = opts.engines[this.ext];
    // lookup path
    this.path = this.lookup(fileName);
}
/**
 * Lookup view by the given `name`
 *
 * @param {string} name
 * @private
 */ View.prototype.lookup = function lookup(name) {
    var path;
    var roots = [].concat(this.root);
    debug('lookup "%s"', name);
    for(var i = 0; i < roots.length && !path; i++){
        var root = roots[i];
        // resolve the path
        var loc = resolve(root, name);
        var dir = dirname(loc);
        var file = basename(loc);
        // resolve the file
        path = this.resolve(dir, file);
    }
    return path;
};
/**
 * Render with the given options.
 *
 * @param {object} options
 * @param {function} callback
 * @private
 */ View.prototype.render = function render(options, callback) {
    var sync = true;
    debug('render "%s"', this.path);
    // render, normalizing sync callbacks
    this.engine(this.path, options, function onRender() {
        if (!sync) {
            return callback.apply(this, arguments);
        }
        // copy arguments
        var args = new Array(arguments.length);
        var cntx = this;
        for(var i = 0; i < arguments.length; i++){
            args[i] = arguments[i];
        }
        // force callback to be async
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function renderTick() {
            return callback.apply(cntx, args);
        });
    });
    sync = false;
};
/**
 * Resolve the file within the given directory.
 *
 * @param {string} dir
 * @param {string} file
 * @private
 */ View.prototype.resolve = function resolve(dir, file) {
    var ext = this.ext;
    // <path>.<ext>
    var path = join(dir, file);
    var stat = tryStat(path);
    if (stat && stat.isFile()) {
        return path;
    }
    // <path>/index.<ext>
    path = join(dir, basename(file, ext), 'index' + ext);
    stat = tryStat(path);
    if (stat && stat.isFile()) {
        return path;
    }
};
/**
 * Return a stat, maybe.
 *
 * @param {string} path
 * @return {fs.Stats}
 * @private
 */ function tryStat(path) {
    debug('stat "%s"', path);
    try {
        return fs.statSync(path);
    } catch (e) {
        return undefined;
    }
}
}}),
"[project]/node_modules/express/lib/utils.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
'use strict';
/**
 * Module dependencies.
 * @api private
 */ var { METHODS } = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-http/index.js [app-client] (ecmascript)");
var contentType = __turbopack_context__.r("[project]/node_modules/content-type/index.js [app-client] (ecmascript)");
var etag = __turbopack_context__.r("[project]/node_modules/etag/index.js [app-client] (ecmascript)");
var mime = __turbopack_context__.r("[project]/node_modules/express/node_modules/mime-types/index.js [app-client] (ecmascript)");
var proxyaddr = __turbopack_context__.r("[project]/node_modules/proxy-addr/index.js [app-client] (ecmascript)");
var qs = __turbopack_context__.r("[project]/node_modules/qs/lib/index.js [app-client] (ecmascript)");
var querystring = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/querystring-es3/index.js [app-client] (ecmascript)");
/**
 * A list of lowercased HTTP methods that are supported by Node.js.
 * @api private
 */ exports.methods = METHODS.map((method)=>method.toLowerCase());
/**
 * Return strong ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */ exports.etag = createETagGenerator({
    weak: false
});
/**
 * Return weak ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */ exports.wetag = createETagGenerator({
    weak: true
});
/**
 * Normalize the given `type`, for example "html" becomes "text/html".
 *
 * @param {String} type
 * @return {Object}
 * @api private
 */ exports.normalizeType = function(type) {
    return ~type.indexOf('/') ? acceptParams(type) : {
        value: mime.lookup(type) || 'application/octet-stream',
        params: {}
    };
};
/**
 * Normalize `types`, for example "html" becomes "text/html".
 *
 * @param {Array} types
 * @return {Array}
 * @api private
 */ exports.normalizeTypes = function(types) {
    return types.map(exports.normalizeType);
};
/**
 * Parse accept params `str` returning an
 * object with `.value`, `.quality` and `.params`.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */ function acceptParams(str) {
    var length = str.length;
    var colonIndex = str.indexOf(';');
    var index = colonIndex === -1 ? length : colonIndex;
    var ret = {
        value: str.slice(0, index).trim(),
        quality: 1,
        params: {}
    };
    while(index < length){
        var splitIndex = str.indexOf('=', index);
        if (splitIndex === -1) break;
        var colonIndex = str.indexOf(';', index);
        var endIndex = colonIndex === -1 ? length : colonIndex;
        if (splitIndex > endIndex) {
            index = str.lastIndexOf(';', splitIndex - 1) + 1;
            continue;
        }
        var key = str.slice(index, splitIndex).trim();
        var value = str.slice(splitIndex + 1, endIndex).trim();
        if (key === 'q') {
            ret.quality = parseFloat(value);
        } else {
            ret.params[key] = value;
        }
        index = endIndex + 1;
    }
    return ret;
}
/**
 * Compile "etag" value to function.
 *
 * @param  {Boolean|String|Function} val
 * @return {Function}
 * @api private
 */ exports.compileETag = function(val) {
    var fn;
    if (typeof val === 'function') {
        return val;
    }
    switch(val){
        case true:
        case 'weak':
            fn = exports.wetag;
            break;
        case false:
            break;
        case 'strong':
            fn = exports.etag;
            break;
        default:
            throw new TypeError('unknown value for etag function: ' + val);
    }
    return fn;
};
/**
 * Compile "query parser" value to function.
 *
 * @param  {String|Function} val
 * @return {Function}
 * @api private
 */ exports.compileQueryParser = function compileQueryParser(val) {
    var fn;
    if (typeof val === 'function') {
        return val;
    }
    switch(val){
        case true:
        case 'simple':
            fn = querystring.parse;
            break;
        case false:
            break;
        case 'extended':
            fn = parseExtendedQueryString;
            break;
        default:
            throw new TypeError('unknown value for query parser function: ' + val);
    }
    return fn;
};
/**
 * Compile "proxy trust" value to function.
 *
 * @param  {Boolean|String|Number|Array|Function} val
 * @return {Function}
 * @api private
 */ exports.compileTrust = function(val) {
    if (typeof val === 'function') return val;
    if (val === true) {
        // Support plain true/false
        return function() {
            return true;
        };
    }
    if (typeof val === 'number') {
        // Support trusting hop count
        return function(a, i) {
            return i < val;
        };
    }
    if (typeof val === 'string') {
        // Support comma-separated values
        val = val.split(',').map(function(v) {
            return v.trim();
        });
    }
    return proxyaddr.compile(val || []);
};
/**
 * Set the charset in a given Content-Type string.
 *
 * @param {String} type
 * @param {String} charset
 * @return {String}
 * @api private
 */ exports.setCharset = function setCharset(type, charset) {
    if (!type || !charset) {
        return type;
    }
    // parse type
    var parsed = contentType.parse(type);
    // set charset
    parsed.parameters.charset = charset;
    // format type
    return contentType.format(parsed);
};
/**
 * Create an ETag generator function, generating ETags with
 * the given options.
 *
 * @param {object} options
 * @return {function}
 * @private
 */ function createETagGenerator(options) {
    return function generateETag(body, encoding) {
        var buf = !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(body) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(body, encoding) : body;
        return etag(buf, options);
    };
}
/**
 * Parse an extended query string with qs.
 *
 * @param {String} str
 * @return {Object}
 * @private
 */ function parseExtendedQueryString(str) {
    return qs.parse(str, {
        allowPrototypes: true
    });
}
}}),
"[project]/node_modules/express/lib/application.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
/**
 * Module dependencies.
 * @private
 */ var finalhandler = __turbopack_context__.r("[project]/node_modules/finalhandler/index.js [app-client] (ecmascript)");
var debug = __turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)")('express:application');
var View = __turbopack_context__.r("[project]/node_modules/express/lib/view.js [app-client] (ecmascript)");
var http = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-http/index.js [app-client] (ecmascript)");
var methods = __turbopack_context__.r("[project]/node_modules/express/lib/utils.js [app-client] (ecmascript)").methods;
var compileETag = __turbopack_context__.r("[project]/node_modules/express/lib/utils.js [app-client] (ecmascript)").compileETag;
var compileQueryParser = __turbopack_context__.r("[project]/node_modules/express/lib/utils.js [app-client] (ecmascript)").compileQueryParser;
var compileTrust = __turbopack_context__.r("[project]/node_modules/express/lib/utils.js [app-client] (ecmascript)").compileTrust;
var resolve = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)").resolve;
var once = __turbopack_context__.r("[project]/node_modules/once/once.js [app-client] (ecmascript)");
var Router = __turbopack_context__.r("[project]/node_modules/router/index.js [app-client] (ecmascript)");
/**
 * Module variables.
 * @private
 */ var slice = Array.prototype.slice;
var flatten = Array.prototype.flat;
/**
 * Application prototype.
 */ var app = exports = module.exports = {};
/**
 * Variable for trust proxy inheritance back-compat
 * @private
 */ var trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';
/**
 * Initialize the server.
 *
 *   - setup default configuration
 *   - setup default middleware
 *   - setup route reflection methods
 *
 * @private
 */ app.init = function init() {
    var router = null;
    this.cache = Object.create(null);
    this.engines = Object.create(null);
    this.settings = Object.create(null);
    this.defaultConfiguration();
    // Setup getting to lazily add base router
    Object.defineProperty(this, 'router', {
        configurable: true,
        enumerable: true,
        get: function getrouter() {
            if (router === null) {
                router = new Router({
                    caseSensitive: this.enabled('case sensitive routing'),
                    strict: this.enabled('strict routing')
                });
            }
            return router;
        }
    });
};
/**
 * Initialize application configuration.
 * @private
 */ app.defaultConfiguration = function defaultConfiguration() {
    var env = ("TURBOPACK compile-time value", "development") || 'development';
    // default settings
    this.enable('x-powered-by');
    this.set('etag', 'weak');
    this.set('env', env);
    this.set('query parser', 'simple');
    this.set('subdomain offset', 2);
    this.set('trust proxy', false);
    // trust proxy inherit back-compat
    Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: true
    });
    debug('booting in %s mode', env);
    this.on('mount', function onmount(parent) {
        // inherit trust proxy
        if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings['trust proxy fn'] === 'function') {
            delete this.settings['trust proxy'];
            delete this.settings['trust proxy fn'];
        }
        // inherit protos
        Object.setPrototypeOf(this.request, parent.request);
        Object.setPrototypeOf(this.response, parent.response);
        Object.setPrototypeOf(this.engines, parent.engines);
        Object.setPrototypeOf(this.settings, parent.settings);
    });
    // setup locals
    this.locals = Object.create(null);
    // top-most app is mounted at /
    this.mountpath = '/';
    // default locals
    this.locals.settings = this.settings;
    // default configuration
    this.set('view', View);
    this.set('views', resolve('views'));
    this.set('jsonp callback name', 'callback');
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
};
/**
 * Dispatch a req, res pair into the application. Starts pipeline processing.
 *
 * If no callback is provided, then default error handlers will respond
 * in the event of an error bubbling through the stack.
 *
 * @private
 */ app.handle = function handle(req, res, callback) {
    // final handler
    var done = callback || finalhandler(req, res, {
        env: this.get('env'),
        onerror: logerror.bind(this)
    });
    // set powered by header
    if (this.enabled('x-powered-by')) {
        res.setHeader('X-Powered-By', 'Express');
    }
    // set circular references
    req.res = res;
    res.req = req;
    // alter the prototypes
    Object.setPrototypeOf(req, this.request);
    Object.setPrototypeOf(res, this.response);
    // setup locals
    if (!res.locals) {
        res.locals = Object.create(null);
    }
    this.router.handle(req, res, done);
};
/**
 * Proxy `Router#use()` to add middleware to the app router.
 * See Router#use() documentation for details.
 *
 * If the _fn_ parameter is an express app, then it will be
 * mounted at the _route_ specified.
 *
 * @public
 */ app.use = function use(fn) {
    var offset = 0;
    var path = '/';
    // default path to '/'
    // disambiguate app.use([fn])
    if (typeof fn !== 'function') {
        var arg = fn;
        while(Array.isArray(arg) && arg.length !== 0){
            arg = arg[0];
        }
        // first arg is the path
        if (typeof arg !== 'function') {
            offset = 1;
            path = fn;
        }
    }
    var fns = flatten.call(slice.call(arguments, offset), Infinity);
    if (fns.length === 0) {
        throw new TypeError('app.use() requires a middleware function');
    }
    // get router
    var router = this.router;
    fns.forEach(function(fn) {
        // non-express app
        if (!fn || !fn.handle || !fn.set) {
            return router.use(path, fn);
        }
        debug('.use app under %s', path);
        fn.mountpath = path;
        fn.parent = this;
        // restore .app property on req and res
        router.use(path, function mounted_app(req, res, next) {
            var orig = req.app;
            fn.handle(req, res, {
                "use.use.mounted_app": function(err) {
                    Object.setPrototypeOf(req, orig.request);
                    Object.setPrototypeOf(res, orig.response);
                    next(err);
                }
            }["use.use.mounted_app"]);
        });
        // mounted an app
        fn.emit('mount', this);
    }, this);
    return this;
};
/**
 * Proxy to the app `Router#route()`
 * Returns a new `Route` instance for the _path_.
 *
 * Routes are isolated middleware stacks for specific paths.
 * See the Route api docs for details.
 *
 * @public
 */ app.route = function route(path) {
    return this.router.route(path);
};
/**
 * Register the given template engine callback `fn`
 * as `ext`.
 *
 * By default will `require()` the engine based on the
 * file extension. For example if you try to render
 * a "foo.ejs" file Express will invoke the following internally:
 *
 *     app.engine('ejs', require('ejs').__express);
 *
 * For engines that do not provide `.__express` out of the box,
 * or if you wish to "map" a different extension to the template engine
 * you may use this method. For example mapping the EJS template engine to
 * ".html" files:
 *
 *     app.engine('html', require('ejs').renderFile);
 *
 * In this case EJS provides a `.renderFile()` method with
 * the same signature that Express expects: `(path, options, callback)`,
 * though note that it aliases this method as `ejs.__express` internally
 * so if you're using ".ejs" extensions you don't need to do anything.
 *
 * Some template engines do not follow this convention, the
 * [Consolidate.js](https://github.com/tj/consolidate.js)
 * library was created to map all of node's popular template
 * engines to follow this convention, thus allowing them to
 * work seamlessly within Express.
 *
 * @param {String} ext
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */ app.engine = function engine(ext, fn) {
    if (typeof fn !== 'function') {
        throw new Error('callback function required');
    }
    // get file extension
    var extension = ext[0] !== '.' ? '.' + ext : ext;
    // store engine
    this.engines[extension] = fn;
    return this;
};
/**
 * Proxy to `Router#param()` with one added api feature. The _name_ parameter
 * can be an array of names.
 *
 * See the Router#param() docs for more details.
 *
 * @param {String|Array} name
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */ app.param = function param(name, fn) {
    if (Array.isArray(name)) {
        for(var i = 0; i < name.length; i++){
            this.param(name[i], fn);
        }
        return this;
    }
    this.router.param(name, fn);
    return this;
};
/**
 * Assign `setting` to `val`, or return `setting`'s value.
 *
 *    app.set('foo', 'bar');
 *    app.set('foo');
 *    // => "bar"
 *
 * Mounted servers inherit their parent server's settings.
 *
 * @param {String} setting
 * @param {*} [val]
 * @return {Server} for chaining
 * @public
 */ app.set = function set(setting, val) {
    if (arguments.length === 1) {
        // app.get(setting)
        return this.settings[setting];
    }
    debug('set "%s" to %o', setting, val);
    // set value
    this.settings[setting] = val;
    // trigger matched settings
    switch(setting){
        case 'etag':
            this.set('etag fn', compileETag(val));
            break;
        case 'query parser':
            this.set('query parser fn', compileQueryParser(val));
            break;
        case 'trust proxy':
            this.set('trust proxy fn', compileTrust(val));
            // trust proxy inherit back-compat
            Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
                configurable: true,
                value: false
            });
            break;
    }
    return this;
};
/**
 * Return the app's absolute pathname
 * based on the parent(s) that have
 * mounted it.
 *
 * For example if the application was
 * mounted as "/admin", which itself
 * was mounted as "/blog" then the
 * return value would be "/blog/admin".
 *
 * @return {String}
 * @private
 */ app.path = function path() {
    return this.parent ? this.parent.path() + this.mountpath : '';
};
/**
 * Check if `setting` is enabled (truthy).
 *
 *    app.enabled('foo')
 *    // => false
 *
 *    app.enable('foo')
 *    app.enabled('foo')
 *    // => true
 *
 * @param {String} setting
 * @return {Boolean}
 * @public
 */ app.enabled = function enabled(setting) {
    return Boolean(this.set(setting));
};
/**
 * Check if `setting` is disabled.
 *
 *    app.disabled('foo')
 *    // => true
 *
 *    app.enable('foo')
 *    app.disabled('foo')
 *    // => false
 *
 * @param {String} setting
 * @return {Boolean}
 * @public
 */ app.disabled = function disabled(setting) {
    return !this.set(setting);
};
/**
 * Enable `setting`.
 *
 * @param {String} setting
 * @return {app} for chaining
 * @public
 */ app.enable = function enable(setting) {
    return this.set(setting, true);
};
/**
 * Disable `setting`.
 *
 * @param {String} setting
 * @return {app} for chaining
 * @public
 */ app.disable = function disable(setting) {
    return this.set(setting, false);
};
/**
 * Delegate `.VERB(...)` calls to `router.VERB(...)`.
 */ methods.forEach(function(method) {
    app[method] = function(path) {
        if (method === 'get' && arguments.length === 1) {
            // app.get(setting)
            return this.set(path);
        }
        var route = this.route(path);
        route[method].apply(route, slice.call(arguments, 1));
        return this;
    };
});
/**
 * Special-cased "all" method, applying the given route `path`,
 * middleware, and callback to _every_ HTTP method.
 *
 * @param {String} path
 * @param {Function} ...
 * @return {app} for chaining
 * @public
 */ app.all = function all(path) {
    var route = this.route(path);
    var args = slice.call(arguments, 1);
    for(var i = 0; i < methods.length; i++){
        route[methods[i]].apply(route, args);
    }
    return this;
};
/**
 * Render the given view `name` name with `options`
 * and a callback accepting an error and the
 * rendered template string.
 *
 * Example:
 *
 *    app.render('email', { name: 'Tobi' }, function(err, html){
 *      // ...
 *    })
 *
 * @param {String} name
 * @param {Object|Function} options or fn
 * @param {Function} callback
 * @public
 */ app.render = function render(name, options, callback) {
    var cache = this.cache;
    var done = callback;
    var engines = this.engines;
    var opts = options;
    var view;
    // support callback function as second arg
    if (typeof options === 'function') {
        done = options;
        opts = {};
    }
    // merge options
    var renderOptions = {
        ...this.locals,
        ...opts._locals,
        ...opts
    };
    // set .cache unless explicitly provided
    if (renderOptions.cache == null) {
        renderOptions.cache = this.enabled('view cache');
    }
    // primed cache
    if (renderOptions.cache) {
        view = cache[name];
    }
    // view
    if (!view) {
        var View = this.get('view');
        view = new View(name, {
            defaultEngine: this.get('view engine'),
            root: this.get('views'),
            engines: engines
        });
        if (!view.path) {
            var dirs = Array.isArray(view.root) && view.root.length > 1 ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"' : 'directory "' + view.root + '"';
            var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
            err.view = view;
            return done(err);
        }
        // prime the cache
        if (renderOptions.cache) {
            cache[name] = view;
        }
    }
    // render
    tryRender(view, renderOptions, done);
};
/**
 * Listen for connections.
 *
 * A node `http.Server` is returned, with this
 * application (which is a `Function`) as its
 * callback. If you wish to create both an HTTP
 * and HTTPS server you may do so with the "http"
 * and "https" modules as shown here:
 *
 *    var http = require('node:http')
 *      , https = require('node:https')
 *      , express = require('express')
 *      , app = express();
 *
 *    http.createServer(app).listen(80);
 *    https.createServer({ ... }, app).listen(443);
 *
 * @return {http.Server}
 * @public
 */ app.listen = function listen() {
    var server = http.createServer(this);
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[args.length - 1] === 'function') {
        var done = args[args.length - 1] = once(args[args.length - 1]);
        server.once('error', done);
    }
    return server.listen.apply(server, args);
};
/**
 * Log error using console.error.
 *
 * @param {Error} err
 * @private
 */ function logerror(err) {
    /* istanbul ignore next */ if (this.get('env') !== 'test') console.error(err.stack || err.toString());
}
/**
 * Try rendering a view.
 * @private
 */ function tryRender(view, options, callback) {
    try {
        view.render(options, callback);
    } catch (err) {
        callback(err);
    }
}
}}),
"[project]/node_modules/express/lib/request.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ var accepts = __turbopack_context__.r("[project]/node_modules/accepts/index.js [app-client] (ecmascript)");
var isIP = (()=>{
    const e = new Error("Cannot find module 'node:net': Unsupported external type Url for commonjs reference");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})().isIP;
var typeis = __turbopack_context__.r("[project]/node_modules/type-is/index.js [app-client] (ecmascript)");
var http = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-http/index.js [app-client] (ecmascript)");
var fresh = __turbopack_context__.r("[project]/node_modules/fresh/index.js [app-client] (ecmascript)");
var parseRange = __turbopack_context__.r("[project]/node_modules/range-parser/index.js [app-client] (ecmascript)");
var parse = __turbopack_context__.r("[project]/node_modules/parseurl/index.js [app-client] (ecmascript)");
var proxyaddr = __turbopack_context__.r("[project]/node_modules/proxy-addr/index.js [app-client] (ecmascript)");
/**
 * Request prototype.
 * @public
 */ var req = Object.create(http.IncomingMessage.prototype);
/**
 * Module exports.
 * @public
 */ module.exports = req;
/**
 * Return request header.
 *
 * The `Referrer` header field is special-cased,
 * both `Referrer` and `Referer` are interchangeable.
 *
 * Examples:
 *
 *     req.get('Content-Type');
 *     // => "text/plain"
 *
 *     req.get('content-type');
 *     // => "text/plain"
 *
 *     req.get('Something');
 *     // => undefined
 *
 * Aliased as `req.header()`.
 *
 * @param {String} name
 * @return {String}
 * @public
 */ req.get = req.header = function header(name) {
    if (!name) {
        throw new TypeError('name argument is required to req.get');
    }
    if (typeof name !== 'string') {
        throw new TypeError('name must be a string to req.get');
    }
    var lc = name.toLowerCase();
    switch(lc){
        case 'referer':
        case 'referrer':
            return this.headers.referrer || this.headers.referer;
        default:
            return this.headers[lc];
    }
};
/**
 * To do: update docs.
 *
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single MIME type string
 * such as "application/json", an extension name
 * such as "json", a comma-delimited list such as "json, html, text/plain",
 * an argument list such as `"json", "html", "text/plain"`,
 * or an array `["json", "html", "text/plain"]`. When a list
 * or array is given, the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     req.accepts('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     req.accepts('html');
 *     // => "html"
 *     req.accepts('text/html');
 *     // => "text/html"
 *     req.accepts('json, text');
 *     // => "json"
 *     req.accepts('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     req.accepts('image/png');
 *     req.accepts('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     req.accepts(['html', 'json']);
 *     req.accepts('html', 'json');
 *     req.accepts('html, json');
 *     // => "json"
 *
 * @param {String|Array} type(s)
 * @return {String|Array|Boolean}
 * @public
 */ req.accepts = function() {
    var accept = accepts(this);
    return accept.types.apply(accept, arguments);
};
/**
 * Check if the given `encoding`s are accepted.
 *
 * @param {String} ...encoding
 * @return {String|Array}
 * @public
 */ req.acceptsEncodings = function() {
    var accept = accepts(this);
    return accept.encodings.apply(accept, arguments);
};
/**
 * Check if the given `charset`s are acceptable,
 * otherwise you should respond with 406 "Not Acceptable".
 *
 * @param {String} ...charset
 * @return {String|Array}
 * @public
 */ req.acceptsCharsets = function() {
    var accept = accepts(this);
    return accept.charsets.apply(accept, arguments);
};
/**
 * Check if the given `lang`s are acceptable,
 * otherwise you should respond with 406 "Not Acceptable".
 *
 * @param {String} ...lang
 * @return {String|Array}
 * @public
 */ req.acceptsLanguages = function() {
    var accept = accepts(this);
    return accept.languages.apply(accept, arguments);
};
/**
 * Parse Range header field, capping to the given `size`.
 *
 * Unspecified ranges such as "0-" require knowledge of your resource length. In
 * the case of a byte range this is of course the total number of bytes. If the
 * Range header field is not given `undefined` is returned, `-1` when unsatisfiable,
 * and `-2` when syntactically invalid.
 *
 * When ranges are returned, the array has a "type" property which is the type of
 * range that is required (most commonly, "bytes"). Each array element is an object
 * with a "start" and "end" property for the portion of the range.
 *
 * The "combine" option can be set to `true` and overlapping & adjacent ranges
 * will be combined into a single range.
 *
 * NOTE: remember that ranges are inclusive, so for example "Range: users=0-3"
 * should respond with 4 users when available, not 3.
 *
 * @param {number} size
 * @param {object} [options]
 * @param {boolean} [options.combine=false]
 * @return {number|array}
 * @public
 */ req.range = function range(size, options) {
    var range = this.get('Range');
    if (!range) return;
    return parseRange(size, range, options);
};
/**
 * Parse the query string of `req.url`.
 *
 * This uses the "query parser" setting to parse the raw
 * string into an object.
 *
 * @return {String}
 * @api public
 */ defineGetter(req, 'query', function query() {
    var queryparse = this.app.get('query parser fn');
    if (!queryparse) {
        // parsing is disabled
        return Object.create(null);
    }
    var querystring = parse(this).query;
    return queryparse(querystring);
});
/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains the given mime `type`.
 *
 * Examples:
 *
 *      // With Content-Type: text/html; charset=utf-8
 *      req.is('html');
 *      req.is('text/html');
 *      req.is('text/*');
 *      // => true
 *
 *      // When Content-Type is application/json
 *      req.is('json');
 *      req.is('application/json');
 *      req.is('application/*');
 *      // => true
 *
 *      req.is('html');
 *      // => false
 *
 * @param {String|Array} types...
 * @return {String|false|null}
 * @public
 */ req.is = function is(types) {
    var arr = types;
    // support flattened arguments
    if (!Array.isArray(types)) {
        arr = new Array(arguments.length);
        for(var i = 0; i < arr.length; i++){
            arr[i] = arguments[i];
        }
    }
    return typeis(this, arr);
};
/**
 * Return the protocol string "http" or "https"
 * when requested with TLS. When the "trust proxy"
 * setting trusts the socket address, the
 * "X-Forwarded-Proto" header field will be trusted
 * and used if present.
 *
 * If you're running behind a reverse proxy that
 * supplies https for you this may be enabled.
 *
 * @return {String}
 * @public
 */ defineGetter(req, 'protocol', function protocol() {
    var proto = this.connection.encrypted ? 'https' : 'http';
    var trust = this.app.get('trust proxy fn');
    if (!trust(this.connection.remoteAddress, 0)) {
        return proto;
    }
    // Note: X-Forwarded-Proto is normally only ever a
    //       single value, but this is to be safe.
    var header = this.get('X-Forwarded-Proto') || proto;
    var index = header.indexOf(',');
    return index !== -1 ? header.substring(0, index).trim() : header.trim();
});
/**
 * Short-hand for:
 *
 *    req.protocol === 'https'
 *
 * @return {Boolean}
 * @public
 */ defineGetter(req, 'secure', function secure() {
    return this.protocol === 'https';
});
/**
 * Return the remote address from the trusted proxy.
 *
 * The is the remote address on the socket unless
 * "trust proxy" is set.
 *
 * @return {String}
 * @public
 */ defineGetter(req, 'ip', function ip() {
    var trust = this.app.get('trust proxy fn');
    return proxyaddr(this, trust);
});
/**
 * When "trust proxy" is set, trusted proxy addresses + client.
 *
 * For example if the value were "client, proxy1, proxy2"
 * you would receive the array `["client", "proxy1", "proxy2"]`
 * where "proxy2" is the furthest down-stream and "proxy1" and
 * "proxy2" were trusted.
 *
 * @return {Array}
 * @public
 */ defineGetter(req, 'ips', function ips() {
    var trust = this.app.get('trust proxy fn');
    var addrs = proxyaddr.all(this, trust);
    // reverse the order (to farthest -> closest)
    // and remove socket address
    addrs.reverse().pop();
    return addrs;
});
/**
 * Return subdomains as an array.
 *
 * Subdomains are the dot-separated parts of the host before the main domain of
 * the app. By default, the domain of the app is assumed to be the last two
 * parts of the host. This can be changed by setting "subdomain offset".
 *
 * For example, if the domain is "tobi.ferrets.example.com":
 * If "subdomain offset" is not set, req.subdomains is `["ferrets", "tobi"]`.
 * If "subdomain offset" is 3, req.subdomains is `["tobi"]`.
 *
 * @return {Array}
 * @public
 */ defineGetter(req, 'subdomains', function subdomains() {
    var hostname = this.hostname;
    if (!hostname) return [];
    var offset = this.app.get('subdomain offset');
    var subdomains = !isIP(hostname) ? hostname.split('.').reverse() : [
        hostname
    ];
    return subdomains.slice(offset);
});
/**
 * Short-hand for `url.parse(req.url).pathname`.
 *
 * @return {String}
 * @public
 */ defineGetter(req, 'path', function path() {
    return parse(this).pathname;
});
/**
 * Parse the "Host" header field to a host.
 *
 * When the "trust proxy" setting trusts the socket
 * address, the "X-Forwarded-Host" header field will
 * be trusted.
 *
 * @return {String}
 * @public
 */ defineGetter(req, 'host', function host() {
    var trust = this.app.get('trust proxy fn');
    var val = this.get('X-Forwarded-Host');
    if (!val || !trust(this.connection.remoteAddress, 0)) {
        val = this.get('Host');
    } else if (val.indexOf(',') !== -1) {
        // Note: X-Forwarded-Host is normally only ever a
        //       single value, but this is to be safe.
        val = val.substring(0, val.indexOf(',')).trimRight();
    }
    return val || undefined;
});
/**
 * Parse the "Host" header field to a hostname.
 *
 * When the "trust proxy" setting trusts the socket
 * address, the "X-Forwarded-Host" header field will
 * be trusted.
 *
 * @return {String}
 * @api public
 */ defineGetter(req, 'hostname', function hostname() {
    var host = this.host;
    if (!host) return;
    // IPv6 literal support
    var offset = host[0] === '[' ? host.indexOf(']') + 1 : 0;
    var index = host.indexOf(':', offset);
    return index !== -1 ? host.substring(0, index) : host;
});
/**
 * Check if the request is fresh, aka
 * Last-Modified or the ETag
 * still match.
 *
 * @return {Boolean}
 * @public
 */ defineGetter(req, 'fresh', function() {
    var method = this.method;
    var res = this.res;
    var status = res.statusCode;
    // GET or HEAD for weak freshness validation only
    if ('GET' !== method && 'HEAD' !== method) return false;
    // 2xx or 304 as per rfc2616 14.26
    if (status >= 200 && status < 300 || 304 === status) {
        return fresh(this.headers, {
            'etag': res.get('ETag'),
            'last-modified': res.get('Last-Modified')
        });
    }
    return false;
});
/**
 * Check if the request is stale, aka
 * "Last-Modified" and / or the "ETag" for the
 * resource has changed.
 *
 * @return {Boolean}
 * @public
 */ defineGetter(req, 'stale', function stale() {
    return !this.fresh;
});
/**
 * Check if the request was an _XMLHttpRequest_.
 *
 * @return {Boolean}
 * @public
 */ defineGetter(req, 'xhr', function xhr() {
    var val = this.get('X-Requested-With') || '';
    return val.toLowerCase() === 'xmlhttprequest';
});
/**
 * Helper function for creating a getter on an object.
 *
 * @param {Object} obj
 * @param {String} name
 * @param {Function} getter
 * @private
 */ function defineGetter(obj, name, getter) {
    Object.defineProperty(obj, name, {
        configurable: true,
        enumerable: true,
        get: getter
    });
}
}}),
"[project]/node_modules/express/lib/response.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
'use strict';
/**
 * Module dependencies.
 * @private
 */ var contentDisposition = __turbopack_context__.r("[project]/node_modules/content-disposition/index.js [app-client] (ecmascript)");
var createError = __turbopack_context__.r("[project]/node_modules/http-errors/index.js [app-client] (ecmascript)");
var encodeUrl = __turbopack_context__.r("[project]/node_modules/encodeurl/index.js [app-client] (ecmascript)");
var escapeHtml = __turbopack_context__.r("[project]/node_modules/escape-html/index.js [app-client] (ecmascript)");
var http = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-http/index.js [app-client] (ecmascript)");
var onFinished = __turbopack_context__.r("[project]/node_modules/on-finished/index.js [app-client] (ecmascript)");
var mime = __turbopack_context__.r("[project]/node_modules/express/node_modules/mime-types/index.js [app-client] (ecmascript)");
var path = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)");
var pathIsAbsolute = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)").isAbsolute;
var statuses = __turbopack_context__.r("[project]/node_modules/statuses/index.js [app-client] (ecmascript)");
var sign = __turbopack_context__.r("[project]/node_modules/cookie-signature/index.js [app-client] (ecmascript)").sign;
var normalizeType = __turbopack_context__.r("[project]/node_modules/express/lib/utils.js [app-client] (ecmascript)").normalizeType;
var normalizeTypes = __turbopack_context__.r("[project]/node_modules/express/lib/utils.js [app-client] (ecmascript)").normalizeTypes;
var setCharset = __turbopack_context__.r("[project]/node_modules/express/lib/utils.js [app-client] (ecmascript)").setCharset;
var cookie = __turbopack_context__.r("[project]/node_modules/cookie/index.js [app-client] (ecmascript)");
var send = __turbopack_context__.r("[project]/node_modules/send/index.js [app-client] (ecmascript)");
var extname = path.extname;
var resolve = path.resolve;
var vary = __turbopack_context__.r("[project]/node_modules/vary/index.js [app-client] (ecmascript)");
/**
 * Response prototype.
 * @public
 */ var res = Object.create(http.ServerResponse.prototype);
/**
 * Module exports.
 * @public
 */ module.exports = res;
/**
 * Set the HTTP status code for the response.
 *
 * Expects an integer value between 100 and 999 inclusive.
 * Throws an error if the provided status code is not an integer or if it's outside the allowable range.
 *
 * @param {number} code - The HTTP status code to set.
 * @return {ServerResponse} - Returns itself for chaining methods.
 * @throws {TypeError} If `code` is not an integer.
 * @throws {RangeError} If `code` is outside the range 100 to 999.
 * @public
 */ res.status = function status(code) {
    // Check if the status code is not an integer
    if (!Number.isInteger(code)) {
        throw new TypeError(`Invalid status code: ${JSON.stringify(code)}. Status code must be an integer.`);
    }
    // Check if the status code is outside of Node's valid range
    if (code < 100 || code > 999) {
        throw new RangeError(`Invalid status code: ${JSON.stringify(code)}. Status code must be greater than 99 and less than 1000.`);
    }
    this.statusCode = code;
    return this;
};
/**
 * Set Link header field with the given `links`.
 *
 * Examples:
 *
 *    res.links({
 *      next: 'http://api.example.com/users?page=2',
 *      last: 'http://api.example.com/users?page=5',
 *      pages: [
 *        'http://api.example.com/users?page=1',
 *        'http://api.example.com/users?page=2'
 *      ]
 *    });
 *
 * @param {Object} links
 * @return {ServerResponse}
 * @public
 */ res.links = function(links) {
    var link = this.get('Link') || '';
    if (link) link += ', ';
    return this.set('Link', link + Object.keys(links).map(function(rel) {
        // Allow multiple links if links[rel] is an array
        if (Array.isArray(links[rel])) {
            return links[rel].map(function(singleLink) {
                return `<${singleLink}>; rel="${rel}"`;
            }).join(', ');
        } else {
            return `<${links[rel]}>; rel="${rel}"`;
        }
    }).join(', '));
};
/**
 * Send a response.
 *
 * Examples:
 *
 *     res.send(Buffer.from('wahoo'));
 *     res.send({ some: 'json' });
 *     res.send('<p>some html</p>');
 *
 * @param {string|number|boolean|object|Buffer} body
 * @public
 */ res.send = function send(body) {
    var chunk = body;
    var encoding;
    var req = this.req;
    var type;
    // settings
    var app = this.app;
    switch(typeof chunk){
        // string defaulting to html
        case 'string':
            if (!this.get('Content-Type')) {
                this.type('html');
            }
            break;
        case 'boolean':
        case 'number':
        case 'object':
            if (chunk === null) {
                chunk = '';
            } else if (ArrayBuffer.isView(chunk)) {
                if (!this.get('Content-Type')) {
                    this.type('bin');
                }
            } else {
                return this.json(chunk);
            }
            break;
    }
    // write strings in utf-8
    if (typeof chunk === 'string') {
        encoding = 'utf8';
        type = this.get('Content-Type');
        // reflect this in content-type
        if (typeof type === 'string') {
            this.set('Content-Type', setCharset(type, 'utf-8'));
        }
    }
    // determine if ETag should be generated
    var etagFn = app.get('etag fn');
    var generateETag = !this.get('ETag') && typeof etagFn === 'function';
    // populate Content-Length
    var len;
    if (chunk !== undefined) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(chunk)) {
            // get length of Buffer
            len = chunk.length;
        } else if (!generateETag && chunk.length < 1000) {
            // just calculate length when no ETag + small chunk
            len = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].byteLength(chunk, encoding);
        } else {
            // convert chunk to Buffer and calculate
            chunk = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(chunk, encoding);
            encoding = undefined;
            len = chunk.length;
        }
        this.set('Content-Length', len);
    }
    // populate ETag
    var etag;
    if (generateETag && len !== undefined) {
        if (etag = etagFn(chunk, encoding)) {
            this.set('ETag', etag);
        }
    }
    // freshness
    if (req.fresh) this.status(304);
    // strip irrelevant headers
    if (204 === this.statusCode || 304 === this.statusCode) {
        this.removeHeader('Content-Type');
        this.removeHeader('Content-Length');
        this.removeHeader('Transfer-Encoding');
        chunk = '';
    }
    // alter headers for 205
    if (this.statusCode === 205) {
        this.set('Content-Length', '0');
        this.removeHeader('Transfer-Encoding');
        chunk = '';
    }
    if (req.method === 'HEAD') {
        // skip body for HEAD
        this.end();
    } else {
        // respond
        this.end(chunk, encoding);
    }
    return this;
};
/**
 * Send JSON response.
 *
 * Examples:
 *
 *     res.json(null);
 *     res.json({ user: 'tj' });
 *
 * @param {string|number|boolean|object} obj
 * @public
 */ res.json = function json(obj) {
    // settings
    var app = this.app;
    var escape = app.get('json escape');
    var replacer = app.get('json replacer');
    var spaces = app.get('json spaces');
    var body = stringify(obj, replacer, spaces, escape);
    // content-type
    if (!this.get('Content-Type')) {
        this.set('Content-Type', 'application/json');
    }
    return this.send(body);
};
/**
 * Send JSON response with JSONP callback support.
 *
 * Examples:
 *
 *     res.jsonp(null);
 *     res.jsonp({ user: 'tj' });
 *
 * @param {string|number|boolean|object} obj
 * @public
 */ res.jsonp = function jsonp(obj) {
    // settings
    var app = this.app;
    var escape = app.get('json escape');
    var replacer = app.get('json replacer');
    var spaces = app.get('json spaces');
    var body = stringify(obj, replacer, spaces, escape);
    var callback = this.req.query[app.get('jsonp callback name')];
    // content-type
    if (!this.get('Content-Type')) {
        this.set('X-Content-Type-Options', 'nosniff');
        this.set('Content-Type', 'application/json');
    }
    // fixup callback
    if (Array.isArray(callback)) {
        callback = callback[0];
    }
    // jsonp
    if (typeof callback === 'string' && callback.length !== 0) {
        this.set('X-Content-Type-Options', 'nosniff');
        this.set('Content-Type', 'text/javascript');
        // restrict callback charset
        callback = callback.replace(/[^\[\]\w$.]/g, '');
        if (body === undefined) {
            // empty argument
            body = '';
        } else if (typeof body === 'string') {
            // replace chars not allowed in JavaScript that are in JSON
            body = body.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
        }
        // the /**/ is a specific security mitigation for "Rosetta Flash JSONP abuse"
        // the typeof check is just to reduce client error noise
        body = '/**/ typeof ' + callback + ' === \'function\' && ' + callback + '(' + body + ');';
    }
    return this.send(body);
};
/**
 * Send given HTTP status code.
 *
 * Sets the response status to `statusCode` and the body of the
 * response to the standard description from node's http.STATUS_CODES
 * or the statusCode number if no description.
 *
 * Examples:
 *
 *     res.sendStatus(200);
 *
 * @param {number} statusCode
 * @public
 */ res.sendStatus = function sendStatus(statusCode) {
    var body = statuses.message[statusCode] || String(statusCode);
    this.status(statusCode);
    this.type('txt');
    return this.send(body);
};
/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `callback(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.headersSent`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
 *
 * Other options are passed along to `send`.
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendFile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendFile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get('/user/:uid/photos/:file', function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendFile('/uploads/' + uid + '/' + file);
 *         } else {
 *           res.send(403, 'Sorry! you cant see that.');
 *         }
 *       });
 *     });
 *
 * @public
 */ res.sendFile = function sendFile(path, options, callback) {
    var done = callback;
    var req = this.req;
    var res = this;
    var next = req.next;
    var opts = options || {};
    if (!path) {
        throw new TypeError('path argument is required to res.sendFile');
    }
    if (typeof path !== 'string') {
        throw new TypeError('path must be a string to res.sendFile');
    }
    // support function as second arg
    if (typeof options === 'function') {
        done = options;
        opts = {};
    }
    if (!opts.root && !pathIsAbsolute(path)) {
        throw new TypeError('path must be absolute or specify root to res.sendFile');
    }
    // create file stream
    var pathname = encodeURI(path);
    // wire application etag option to send
    opts.etag = this.app.enabled('etag');
    var file = send(req, pathname, opts);
    // transfer
    sendfile(res, file, opts, function(err) {
        if (done) return done(err);
        if (err && err.code === 'EISDIR') return next();
        // next() all but write errors
        if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
            next(err);
        }
    });
};
/**
 * Transfer the file at the given `path` as an attachment.
 *
 * Optionally providing an alternate attachment `filename`,
 * and optional callback `callback(err)`. The callback is invoked
 * when the data transfer is complete, or when an error has
 * occurred. Be sure to check `res.headersSent` if you plan to respond.
 *
 * Optionally providing an `options` object to use with `res.sendFile()`.
 * This function will set the `Content-Disposition` header, overriding
 * any `Content-Disposition` header passed as header options in order
 * to set the attachment and filename.
 *
 * This method uses `res.sendFile()`.
 *
 * @public
 */ res.download = function download(path, filename, options, callback) {
    var done = callback;
    var name = filename;
    var opts = options || null;
    // support function as second or third arg
    if (typeof filename === 'function') {
        done = filename;
        name = null;
        opts = null;
    } else if (typeof options === 'function') {
        done = options;
        opts = null;
    }
    // support optional filename, where options may be in it's place
    if (typeof filename === 'object' && (typeof options === 'function' || options === undefined)) {
        name = null;
        opts = filename;
    }
    // set Content-Disposition when file is sent
    var headers = {
        'Content-Disposition': contentDisposition(name || path)
    };
    // merge user-provided headers
    if (opts && opts.headers) {
        var keys = Object.keys(opts.headers);
        for(var i = 0; i < keys.length; i++){
            var key = keys[i];
            if (key.toLowerCase() !== 'content-disposition') {
                headers[key] = opts.headers[key];
            }
        }
    }
    // merge user-provided options
    opts = Object.create(opts);
    opts.headers = headers;
    // Resolve the full path for sendFile
    var fullPath = !opts.root ? resolve(path) : path;
    // send file
    return this.sendFile(fullPath, opts, done);
};
/**
 * Set _Content-Type_ response header with `type` through `mime.contentType()`
 * when it does not contain "/", or set the Content-Type to `type` otherwise.
 * When no mapping is found though `mime.contentType()`, the type is set to
 * "application/octet-stream".
 *
 * Examples:
 *
 *     res.type('.html');
 *     res.type('html');
 *     res.type('json');
 *     res.type('application/json');
 *     res.type('png');
 *
 * @param {String} type
 * @return {ServerResponse} for chaining
 * @public
 */ res.contentType = res.type = function contentType(type) {
    var ct = type.indexOf('/') === -1 ? mime.contentType(type) || 'application/octet-stream' : type;
    return this.set('Content-Type', ct);
};
/**
 * Respond to the Acceptable formats using an `obj`
 * of mime-type callbacks.
 *
 * This method uses `req.accepted`, an array of
 * acceptable types ordered by their quality values.
 * When "Accept" is not present the _first_ callback
 * is invoked, otherwise the first match is used. When
 * no match is performed the server responds with
 * 406 "Not Acceptable".
 *
 * Content-Type is set for you, however if you choose
 * you may alter this within the callback using `res.type()`
 * or `res.set('Content-Type', ...)`.
 *
 *    res.format({
 *      'text/plain': function(){
 *        res.send('hey');
 *      },
 *
 *      'text/html': function(){
 *        res.send('<p>hey</p>');
 *      },
 *
 *      'application/json': function () {
 *        res.send({ message: 'hey' });
 *      }
 *    });
 *
 * In addition to canonicalized MIME types you may
 * also use extnames mapped to these types:
 *
 *    res.format({
 *      text: function(){
 *        res.send('hey');
 *      },
 *
 *      html: function(){
 *        res.send('<p>hey</p>');
 *      },
 *
 *      json: function(){
 *        res.send({ message: 'hey' });
 *      }
 *    });
 *
 * By default Express passes an `Error`
 * with a `.status` of 406 to `next(err)`
 * if a match is not made. If you provide
 * a `.default` callback it will be invoked
 * instead.
 *
 * @param {Object} obj
 * @return {ServerResponse} for chaining
 * @public
 */ res.format = function(obj) {
    var req = this.req;
    var next = req.next;
    var keys = Object.keys(obj).filter(function(v) {
        return v !== 'default';
    });
    var key = keys.length > 0 ? req.accepts(keys) : false;
    this.vary("Accept");
    if (key) {
        this.set('Content-Type', normalizeType(key).value);
        obj[key](req, this, next);
    } else if (obj.default) {
        obj.default(req, this, next);
    } else {
        next(createError(406, {
            types: normalizeTypes(keys).map(function(o) {
                return o.value;
            })
        }));
    }
    return this;
};
/**
 * Set _Content-Disposition_ header to _attachment_ with optional `filename`.
 *
 * @param {String} filename
 * @return {ServerResponse}
 * @public
 */ res.attachment = function attachment(filename) {
    if (filename) {
        this.type(extname(filename));
    }
    this.set('Content-Disposition', contentDisposition(filename));
    return this;
};
/**
 * Append additional header `field` with value `val`.
 *
 * Example:
 *
 *    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
 *    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
 *    res.append('Warning', '199 Miscellaneous warning');
 *
 * @param {String} field
 * @param {String|Array} val
 * @return {ServerResponse} for chaining
 * @public
 */ res.append = function append(field, val) {
    var prev = this.get(field);
    var value = val;
    if (prev) {
        // concat the new and prev vals
        value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [
            prev
        ].concat(val) : [
            prev,
            val
        ];
    }
    return this.set(field, value);
};
/**
 * Set header `field` to `val`, or pass
 * an object of header fields.
 *
 * Examples:
 *
 *    res.set('Foo', ['bar', 'baz']);
 *    res.set('Accept', 'application/json');
 *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
 *
 * Aliased as `res.header()`.
 *
 * When the set header is "Content-Type", the type is expanded to include
 * the charset if not present using `mime.contentType()`.
 *
 * @param {String|Object} field
 * @param {String|Array} val
 * @return {ServerResponse} for chaining
 * @public
 */ res.set = res.header = function header(field, val) {
    if (arguments.length === 2) {
        var value = Array.isArray(val) ? val.map(String) : String(val);
        // add charset to content-type
        if (field.toLowerCase() === 'content-type') {
            if (Array.isArray(value)) {
                throw new TypeError('Content-Type cannot be set to an Array');
            }
            value = mime.contentType(value);
        }
        this.setHeader(field, value);
    } else {
        for(var key in field){
            this.set(key, field[key]);
        }
    }
    return this;
};
/**
 * Get value for header `field`.
 *
 * @param {String} field
 * @return {String}
 * @public
 */ res.get = function(field) {
    return this.getHeader(field);
};
/**
 * Clear cookie `name`.
 *
 * @param {String} name
 * @param {Object} [options]
 * @return {ServerResponse} for chaining
 * @public
 */ res.clearCookie = function clearCookie(name, options) {
    // Force cookie expiration by setting expires to the past
    const opts = {
        path: '/',
        ...options,
        expires: new Date(1)
    };
    // ensure maxAge is not passed
    delete opts.maxAge;
    return this.cookie(name, '', opts);
};
/**
 * Set cookie `name` to `value`, with the given `options`.
 *
 * Options:
 *
 *    - `maxAge`   max-age in milliseconds, converted to `expires`
 *    - `signed`   sign the cookie
 *    - `path`     defaults to "/"
 *
 * Examples:
 *
 *    // "Remember Me" for 15 minutes
 *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
 *
 *    // same as above
 *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
 *
 * @param {String} name
 * @param {String|Object} value
 * @param {Object} [options]
 * @return {ServerResponse} for chaining
 * @public
 */ res.cookie = function(name, value, options) {
    var opts = {
        ...options
    };
    var secret = this.req.secret;
    var signed = opts.signed;
    if (signed && !secret) {
        throw new Error('cookieParser("secret") required for signed cookies');
    }
    var val = typeof value === 'object' ? 'j:' + JSON.stringify(value) : String(value);
    if (signed) {
        val = 's:' + sign(val, secret);
    }
    if (opts.maxAge != null) {
        var maxAge = opts.maxAge - 0;
        if (!isNaN(maxAge)) {
            opts.expires = new Date(Date.now() + maxAge);
            opts.maxAge = Math.floor(maxAge / 1000);
        }
    }
    if (opts.path == null) {
        opts.path = '/';
    }
    this.append('Set-Cookie', cookie.serialize(name, String(val), opts));
    return this;
};
/**
 * Set the location header to `url`.
 *
 * The given `url` can also be "back", which redirects
 * to the _Referrer_ or _Referer_ headers or "/".
 *
 * Examples:
 *
 *    res.location('/foo/bar').;
 *    res.location('http://example.com');
 *    res.location('../login');
 *
 * @param {String} url
 * @return {ServerResponse} for chaining
 * @public
 */ res.location = function location(url) {
    return this.set('Location', encodeUrl(url));
};
/**
 * Redirect to the given `url` with optional response `status`
 * defaulting to 302.
 *
 * Examples:
 *
 *    res.redirect('/foo/bar');
 *    res.redirect('http://example.com');
 *    res.redirect(301, 'http://example.com');
 *    res.redirect('../login'); // /blog/post/1 -> /blog/login
 *
 * @public
 */ res.redirect = function redirect(url) {
    var address = url;
    var body;
    var status = 302;
    // allow status / url
    if (arguments.length === 2) {
        status = arguments[0];
        address = arguments[1];
    }
    // Set location header
    address = this.location(address).get('Location');
    // Support text/{plain,html} by default
    this.format({
        text: function() {
            body = statuses.message[status] + '. Redirecting to ' + address;
        },
        html: function() {
            var u = escapeHtml(address);
            body = '<p>' + statuses.message[status] + '. Redirecting to ' + u + '</p>';
        },
        default: function() {
            body = '';
        }
    });
    // Respond
    this.status(status);
    this.set('Content-Length', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].byteLength(body));
    if (this.req.method === 'HEAD') {
        this.end();
    } else {
        this.end(body);
    }
};
/**
 * Add `field` to Vary. If already present in the Vary set, then
 * this call is simply ignored.
 *
 * @param {Array|String} field
 * @return {ServerResponse} for chaining
 * @public
 */ res.vary = function(field) {
    vary(this, field);
    return this;
};
/**
 * Render `view` with the given `options` and optional callback `fn`.
 * When a callback function is given a response will _not_ be made
 * automatically, otherwise a response of _200_ and _text/html_ is given.
 *
 * Options:
 *
 *  - `cache`     boolean hinting to the engine it should cache
 *  - `filename`  filename of the view being rendered
 *
 * @public
 */ res.render = function render(view, options, callback) {
    var app = this.req.app;
    var done = callback;
    var opts = options || {};
    var req = this.req;
    var self = this;
    // support callback function as second arg
    if (typeof options === 'function') {
        done = options;
        opts = {};
    }
    // merge res.locals
    opts._locals = self.locals;
    // default callback to respond
    done = done || function(err, str) {
        if (err) return req.next(err);
        self.send(str);
    };
    // render
    app.render(view, opts, done);
};
// pipe the send file stream
function sendfile(res, file, options, callback) {
    var done = false;
    var streaming;
    // request aborted
    function onaborted() {
        if (done) return;
        done = true;
        var err = new Error('Request aborted');
        err.code = 'ECONNABORTED';
        callback(err);
    }
    // directory
    function ondirectory() {
        if (done) return;
        done = true;
        var err = new Error('EISDIR, read');
        err.code = 'EISDIR';
        callback(err);
    }
    // errors
    function onerror(err) {
        if (done) return;
        done = true;
        callback(err);
    }
    // ended
    function onend() {
        if (done) return;
        done = true;
        callback();
    }
    // file
    function onfile() {
        streaming = false;
    }
    // finished
    function onfinish(err) {
        if (err && err.code === 'ECONNRESET') return onaborted();
        if (err) return onerror(err);
        if (done) return;
        setImmediate(function() {
            if (streaming !== false && !done) {
                onaborted();
                return;
            }
            if (done) return;
            done = true;
            callback();
        });
    }
    // streaming
    function onstream() {
        streaming = true;
    }
    file.on('directory', ondirectory);
    file.on('end', onend);
    file.on('error', onerror);
    file.on('file', onfile);
    file.on('stream', onstream);
    onFinished(res, onfinish);
    if (options.headers) {
        // set headers on successful transfer
        file.on('headers', function headers(res) {
            var obj = options.headers;
            var keys = Object.keys(obj);
            for(var i = 0; i < keys.length; i++){
                var k = keys[i];
                res.setHeader(k, obj[k]);
            }
        });
    }
    // pipe
    file.pipe(res);
}
/**
 * Stringify JSON, like JSON.stringify, but v8 optimized, with the
 * ability to escape characters that can trigger HTML sniffing.
 *
 * @param {*} value
 * @param {function} replacer
 * @param {number} spaces
 * @param {boolean} escape
 * @returns {string}
 * @private
 */ function stringify(value, replacer, spaces, escape) {
    // v8 checks arguments.length for optimizing simple call
    // https://bugs.chromium.org/p/v8/issues/detail?id=4730
    var json = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
    if (escape && typeof json === 'string') {
        json = json.replace(/[<>&]/g, function(c) {
            switch(c.charCodeAt(0)){
                case 0x3c:
                    return '\\u003c';
                case 0x3e:
                    return '\\u003e';
                case 0x26:
                    return '\\u0026';
                /* istanbul ignore next: unreachable default */ default:
                    return c;
            }
        });
    }
    return json;
}
}}),
"[project]/node_modules/express/lib/express.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 */ var bodyParser = __turbopack_context__.r("[project]/node_modules/body-parser/index.js [app-client] (ecmascript)");
var EventEmitter = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)").EventEmitter;
var mixin = __turbopack_context__.r("[project]/node_modules/merge-descriptors/index.js [app-client] (ecmascript)");
var proto = __turbopack_context__.r("[project]/node_modules/express/lib/application.js [app-client] (ecmascript)");
var Router = __turbopack_context__.r("[project]/node_modules/router/index.js [app-client] (ecmascript)");
var req = __turbopack_context__.r("[project]/node_modules/express/lib/request.js [app-client] (ecmascript)");
var res = __turbopack_context__.r("[project]/node_modules/express/lib/response.js [app-client] (ecmascript)");
/**
 * Expose `createApplication()`.
 */ exports = module.exports = createApplication;
/**
 * Create an express application.
 *
 * @return {Function}
 * @api public
 */ function createApplication() {
    var app = function(req, res, next) {
        app.handle(req, res, next);
    };
    mixin(app, EventEmitter.prototype, false);
    mixin(app, proto, false);
    // expose the prototype that will get set on requests
    app.request = Object.create(req, {
        app: {
            configurable: true,
            enumerable: true,
            writable: true,
            value: app
        }
    });
    // expose the prototype that will get set on responses
    app.response = Object.create(res, {
        app: {
            configurable: true,
            enumerable: true,
            writable: true,
            value: app
        }
    });
    app.init();
    return app;
}
/**
 * Expose the prototypes.
 */ exports.application = proto;
exports.request = req;
exports.response = res;
/**
 * Expose constructors.
 */ exports.Route = Router.Route;
exports.Router = Router;
/**
 * Expose middleware
 */ exports.json = bodyParser.json;
exports.raw = bodyParser.raw;
exports.static = __turbopack_context__.r("[project]/node_modules/serve-static/index.js [app-client] (ecmascript)");
exports.text = bodyParser.text;
exports.urlencoded = bodyParser.urlencoded;
}}),
"[project]/node_modules/express/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
module.exports = __turbopack_context__.r("[project]/node_modules/express/lib/express.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/forwarded/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module exports.
 * @public
 */ module.exports = forwarded;
/**
 * Get all addresses in the request, using the `X-Forwarded-For` header.
 *
 * @param {object} req
 * @return {array}
 * @public
 */ function forwarded(req) {
    if (!req) {
        throw new TypeError('argument req is required');
    }
    // simple header parsing
    var proxyAddrs = parse(req.headers['x-forwarded-for'] || '');
    var socketAddr = getSocketAddr(req);
    var addrs = [
        socketAddr
    ].concat(proxyAddrs);
    // return all addresses
    return addrs;
}
/**
 * Get the socket address for a request.
 *
 * @param {object} req
 * @return {string}
 * @private
 */ function getSocketAddr(req) {
    return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
}
/**
 * Parse the X-Forwarded-For header.
 *
 * @param {string} header
 * @private
 */ function parse(header) {
    var end = header.length;
    var list = [];
    var start = header.length;
    // gather addresses, backwards
    for(var i = header.length - 1; i >= 0; i--){
        switch(header.charCodeAt(i)){
            case 0x20:
                /*   */ if (start === end) {
                    start = end = i;
                }
                break;
            case 0x2c:
                /* , */ if (start !== end) {
                    list.push(header.substring(start, end));
                }
                start = end = i;
                break;
            default:
                start = i;
                break;
        }
    }
    // final address
    if (start !== end) {
        list.push(header.substring(start, end));
    }
    return list;
}
}}),
"[project]/node_modules/ipaddr.js/lib/ipaddr.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function() {
    var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
    ipaddr = {};
    root = this;
    if (("TURBOPACK compile-time value", "object") !== "undefined" && module !== null && module.exports) {
        module.exports = ipaddr;
    } else {
        root['ipaddr'] = ipaddr;
    }
    matchCIDR = function(first, second, partSize, cidrBits) {
        var part, shift;
        if (first.length !== second.length) {
            throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        part = 0;
        while(cidrBits > 0){
            shift = partSize - cidrBits;
            if (shift < 0) {
                shift = 0;
            }
            if (first[part] >> shift !== second[part] >> shift) {
                return false;
            }
            cidrBits -= partSize;
            part += 1;
        }
        return true;
    };
    ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        var k, len, rangeName, rangeSubnets, subnet;
        if (defaultName == null) {
            defaultName = 'unicast';
        }
        for(rangeName in rangeList){
            rangeSubnets = rangeList[rangeName];
            if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
                rangeSubnets = [
                    rangeSubnets
                ];
            }
            for(k = 0, len = rangeSubnets.length; k < len; k++){
                subnet = rangeSubnets[k];
                if (address.kind() === subnet[0].kind()) {
                    if (address.match.apply(address, subnet)) {
                        return rangeName;
                    }
                }
            }
        }
        return defaultName;
    };
    ipaddr.IPv4 = function() {
        function IPv4(octets) {
            var k, len, octet;
            if (octets.length !== 4) {
                throw new Error("ipaddr: ipv4 octet count should be 4");
            }
            for(k = 0, len = octets.length; k < len; k++){
                octet = octets[k];
                if (!(0 <= octet && octet <= 255)) {
                    throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
                }
            }
            this.octets = octets;
        }
        IPv4.prototype.kind = function() {
            return 'ipv4';
        };
        IPv4.prototype.toString = function() {
            return this.octets.join(".");
        };
        IPv4.prototype.toNormalizedString = function() {
            return this.toString();
        };
        IPv4.prototype.toByteArray = function() {
            return this.octets.slice(0);
        };
        IPv4.prototype.match = function(other, cidrRange) {
            var ref;
            if (cidrRange === void 0) {
                ref = other, other = ref[0], cidrRange = ref[1];
            }
            if (other.kind() !== 'ipv4') {
                throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
            }
            return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.SpecialRanges = {
            unspecified: [
                [
                    new IPv4([
                        0,
                        0,
                        0,
                        0
                    ]),
                    8
                ]
            ],
            broadcast: [
                [
                    new IPv4([
                        255,
                        255,
                        255,
                        255
                    ]),
                    32
                ]
            ],
            multicast: [
                [
                    new IPv4([
                        224,
                        0,
                        0,
                        0
                    ]),
                    4
                ]
            ],
            linkLocal: [
                [
                    new IPv4([
                        169,
                        254,
                        0,
                        0
                    ]),
                    16
                ]
            ],
            loopback: [
                [
                    new IPv4([
                        127,
                        0,
                        0,
                        0
                    ]),
                    8
                ]
            ],
            carrierGradeNat: [
                [
                    new IPv4([
                        100,
                        64,
                        0,
                        0
                    ]),
                    10
                ]
            ],
            "private": [
                [
                    new IPv4([
                        10,
                        0,
                        0,
                        0
                    ]),
                    8
                ],
                [
                    new IPv4([
                        172,
                        16,
                        0,
                        0
                    ]),
                    12
                ],
                [
                    new IPv4([
                        192,
                        168,
                        0,
                        0
                    ]),
                    16
                ]
            ],
            reserved: [
                [
                    new IPv4([
                        192,
                        0,
                        0,
                        0
                    ]),
                    24
                ],
                [
                    new IPv4([
                        192,
                        0,
                        2,
                        0
                    ]),
                    24
                ],
                [
                    new IPv4([
                        192,
                        88,
                        99,
                        0
                    ]),
                    24
                ],
                [
                    new IPv4([
                        198,
                        51,
                        100,
                        0
                    ]),
                    24
                ],
                [
                    new IPv4([
                        203,
                        0,
                        113,
                        0
                    ]),
                    24
                ],
                [
                    new IPv4([
                        240,
                        0,
                        0,
                        0
                    ]),
                    4
                ]
            ]
        };
        IPv4.prototype.range = function() {
            return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
            return ipaddr.IPv6.parse("::ffff:" + this.toString());
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
            var cidr, i, k, octet, stop, zeros, zerotable;
            zerotable = {
                0: 8,
                128: 7,
                192: 6,
                224: 5,
                240: 4,
                248: 3,
                252: 2,
                254: 1,
                255: 0
            };
            cidr = 0;
            stop = false;
            for(i = k = 3; k >= 0; i = k += -1){
                octet = this.octets[i];
                if (octet in zerotable) {
                    zeros = zerotable[octet];
                    if (stop && zeros !== 0) {
                        return null;
                    }
                    if (zeros !== 8) {
                        stop = true;
                    }
                    cidr += zeros;
                } else {
                    return null;
                }
            }
            return 32 - cidr;
        };
        return IPv4;
    }();
    ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
    ipv4Regexes = {
        fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
        longValue: new RegExp("^" + ipv4Part + "$", 'i')
    };
    ipaddr.IPv4.parser = function(string) {
        var match, parseIntAuto, part, shift, value;
        parseIntAuto = function(string) {
            if (string[0] === "0" && string[1] !== "x") {
                return parseInt(string, 8);
            } else {
                return parseInt(string);
            }
        };
        if (match = string.match(ipv4Regexes.fourOctet)) {
            return function() {
                var k, len, ref, results;
                ref = match.slice(1, 6);
                results = [];
                for(k = 0, len = ref.length; k < len; k++){
                    part = ref[k];
                    results.push(parseIntAuto(part));
                }
                return results;
            }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
            value = parseIntAuto(match[1]);
            if (value > 0xffffffff || value < 0) {
                throw new Error("ipaddr: address outside defined range");
            }
            return (function() {
                var k, results;
                results = [];
                for(shift = k = 0; k <= 24; shift = k += 8){
                    results.push(value >> shift & 0xff);
                }
                return results;
            })().reverse();
        } else {
            return null;
        }
    };
    ipaddr.IPv6 = function() {
        function IPv6(parts, zoneId) {
            var i, k, l, len, part, ref;
            if (parts.length === 16) {
                this.parts = [];
                for(i = k = 0; k <= 14; i = k += 2){
                    this.parts.push(parts[i] << 8 | parts[i + 1]);
                }
            } else if (parts.length === 8) {
                this.parts = parts;
            } else {
                throw new Error("ipaddr: ipv6 part count should be 8 or 16");
            }
            ref = this.parts;
            for(l = 0, len = ref.length; l < len; l++){
                part = ref[l];
                if (!(0 <= part && part <= 0xffff)) {
                    throw new Error("ipaddr: ipv6 part should fit in 16 bits");
                }
            }
            if (zoneId) {
                this.zoneId = zoneId;
            }
        }
        IPv6.prototype.kind = function() {
            return 'ipv6';
        };
        IPv6.prototype.toString = function() {
            return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');
        };
        IPv6.prototype.toRFC5952String = function() {
            var bestMatchIndex, bestMatchLength, match, regex, string;
            regex = /((^|:)(0(:|$)){2,})/g;
            string = this.toNormalizedString();
            bestMatchIndex = 0;
            bestMatchLength = -1;
            while(match = regex.exec(string)){
                if (match[0].length > bestMatchLength) {
                    bestMatchIndex = match.index;
                    bestMatchLength = match[0].length;
                }
            }
            if (bestMatchLength < 0) {
                return string;
            }
            return string.substring(0, bestMatchIndex) + '::' + string.substring(bestMatchIndex + bestMatchLength);
        };
        IPv6.prototype.toByteArray = function() {
            var bytes, k, len, part, ref;
            bytes = [];
            ref = this.parts;
            for(k = 0, len = ref.length; k < len; k++){
                part = ref[k];
                bytes.push(part >> 8);
                bytes.push(part & 0xff);
            }
            return bytes;
        };
        IPv6.prototype.toNormalizedString = function() {
            var addr, part, suffix;
            addr = (function() {
                var k, len, ref, results;
                ref = this.parts;
                results = [];
                for(k = 0, len = ref.length; k < len; k++){
                    part = ref[k];
                    results.push(part.toString(16));
                }
                return results;
            }).call(this).join(":");
            suffix = '';
            if (this.zoneId) {
                suffix = '%' + this.zoneId;
            }
            return addr + suffix;
        };
        IPv6.prototype.toFixedLengthString = function() {
            var addr, part, suffix;
            addr = (function() {
                var k, len, ref, results;
                ref = this.parts;
                results = [];
                for(k = 0, len = ref.length; k < len; k++){
                    part = ref[k];
                    results.push(part.toString(16).padStart(4, '0'));
                }
                return results;
            }).call(this).join(":");
            suffix = '';
            if (this.zoneId) {
                suffix = '%' + this.zoneId;
            }
            return addr + suffix;
        };
        IPv6.prototype.match = function(other, cidrRange) {
            var ref;
            if (cidrRange === void 0) {
                ref = other, other = ref[0], cidrRange = ref[1];
            }
            if (other.kind() !== 'ipv6') {
                throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
            }
            return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.SpecialRanges = {
            unspecified: [
                new IPv6([
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                128
            ],
            linkLocal: [
                new IPv6([
                    0xfe80,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                10
            ],
            multicast: [
                new IPv6([
                    0xff00,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                8
            ],
            loopback: [
                new IPv6([
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1
                ]),
                128
            ],
            uniqueLocal: [
                new IPv6([
                    0xfc00,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                7
            ],
            ipv4Mapped: [
                new IPv6([
                    0,
                    0,
                    0,
                    0,
                    0,
                    0xffff,
                    0,
                    0
                ]),
                96
            ],
            rfc6145: [
                new IPv6([
                    0,
                    0,
                    0,
                    0,
                    0xffff,
                    0,
                    0,
                    0
                ]),
                96
            ],
            rfc6052: [
                new IPv6([
                    0x64,
                    0xff9b,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                96
            ],
            '6to4': [
                new IPv6([
                    0x2002,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                16
            ],
            teredo: [
                new IPv6([
                    0x2001,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                32
            ],
            reserved: [
                [
                    new IPv6([
                        0x2001,
                        0xdb8,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    32
                ]
            ]
        };
        IPv6.prototype.range = function() {
            return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
            return this.range() === 'ipv4Mapped';
        };
        IPv6.prototype.toIPv4Address = function() {
            var high, low, ref;
            if (!this.isIPv4MappedAddress()) {
                throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
            }
            ref = this.parts.slice(-2), high = ref[0], low = ref[1];
            return new ipaddr.IPv4([
                high >> 8,
                high & 0xff,
                low >> 8,
                low & 0xff
            ]);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
            var cidr, i, k, part, stop, zeros, zerotable;
            zerotable = {
                0: 16,
                32768: 15,
                49152: 14,
                57344: 13,
                61440: 12,
                63488: 11,
                64512: 10,
                65024: 9,
                65280: 8,
                65408: 7,
                65472: 6,
                65504: 5,
                65520: 4,
                65528: 3,
                65532: 2,
                65534: 1,
                65535: 0
            };
            cidr = 0;
            stop = false;
            for(i = k = 7; k >= 0; i = k += -1){
                part = this.parts[i];
                if (part in zerotable) {
                    zeros = zerotable[part];
                    if (stop && zeros !== 0) {
                        return null;
                    }
                    if (zeros !== 16) {
                        stop = true;
                    }
                    cidr += zeros;
                } else {
                    return null;
                }
            }
            return 128 - cidr;
        };
        return IPv6;
    }();
    ipv6Part = "(?:[0-9a-f]+::?)+";
    zoneIndex = "%[0-9a-z]{1,}";
    ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, 'i'),
        "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", 'i'),
        transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), 'i')
    };
    expandIPv6 = function(string, parts) {
        var colonCount, lastColon, part, replacement, replacementCount, zoneId;
        if (string.indexOf('::') !== string.lastIndexOf('::')) {
            return null;
        }
        zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];
        if (zoneId) {
            zoneId = zoneId.substring(1);
            string = string.replace(/%.+$/, '');
        }
        colonCount = 0;
        lastColon = -1;
        while((lastColon = string.indexOf(':', lastColon + 1)) >= 0){
            colonCount++;
        }
        if (string.substr(0, 2) === '::') {
            colonCount--;
        }
        if (string.substr(-2, 2) === '::') {
            colonCount--;
        }
        if (colonCount > parts) {
            return null;
        }
        replacementCount = parts - colonCount;
        replacement = ':';
        while(replacementCount--){
            replacement += '0:';
        }
        string = string.replace('::', replacement);
        if (string[0] === ':') {
            string = string.slice(1);
        }
        if (string[string.length - 1] === ':') {
            string = string.slice(0, -1);
        }
        parts = function() {
            var k, len, ref, results;
            ref = string.split(":");
            results = [];
            for(k = 0, len = ref.length; k < len; k++){
                part = ref[k];
                results.push(parseInt(part, 16));
            }
            return results;
        }();
        return {
            parts: parts,
            zoneId: zoneId
        };
    };
    ipaddr.IPv6.parser = function(string) {
        var addr, k, len, match, octet, octets, zoneId;
        if (ipv6Regexes['native'].test(string)) {
            return expandIPv6(string, 8);
        } else if (match = string.match(ipv6Regexes['transitional'])) {
            zoneId = match[6] || '';
            addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
            if (addr.parts) {
                octets = [
                    parseInt(match[2]),
                    parseInt(match[3]),
                    parseInt(match[4]),
                    parseInt(match[5])
                ];
                for(k = 0, len = octets.length; k < len; k++){
                    octet = octets[k];
                    if (!(0 <= octet && octet <= 255)) {
                        return null;
                    }
                }
                addr.parts.push(octets[0] << 8 | octets[1]);
                addr.parts.push(octets[2] << 8 | octets[3]);
                return {
                    parts: addr.parts,
                    zoneId: addr.zoneId
                };
            }
        }
        return null;
    };
    ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
        return this.parser(string) !== null;
    };
    ipaddr.IPv4.isValid = function(string) {
        var e;
        try {
            new this(this.parser(string));
            return true;
        } catch (error1) {
            e = error1;
            return false;
        }
    };
    ipaddr.IPv4.isValidFourPartDecimal = function(string) {
        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
            return true;
        } else {
            return false;
        }
    };
    ipaddr.IPv6.isValid = function(string) {
        var addr, e;
        if (typeof string === "string" && string.indexOf(":") === -1) {
            return false;
        }
        try {
            addr = this.parser(string);
            new this(addr.parts, addr.zoneId);
            return true;
        } catch (error1) {
            e = error1;
            return false;
        }
    };
    ipaddr.IPv4.parse = function(string) {
        var parts;
        parts = this.parser(string);
        if (parts === null) {
            throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(parts);
    };
    ipaddr.IPv6.parse = function(string) {
        var addr;
        addr = this.parser(string);
        if (addr.parts === null) {
            throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(addr.parts, addr.zoneId);
    };
    ipaddr.IPv4.parseCIDR = function(string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
            maskLength = parseInt(match[2]);
            if (maskLength >= 0 && maskLength <= 32) {
                parsed = [
                    this.parse(match[1]),
                    maskLength
                ];
                Object.defineProperty(parsed, 'toString', {
                    value: function() {
                        return this.join('/');
                    }
                });
                return parsed;
            }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    };
    ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        var filledOctetCount, j, octets;
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
            throw new Error('ipaddr: invalid IPv4 prefix length');
        }
        octets = [
            0,
            0,
            0,
            0
        ];
        j = 0;
        filledOctetCount = Math.floor(prefix / 8);
        while(j < filledOctetCount){
            octets[j] = 255;
            j++;
        }
        if (filledOctetCount < 4) {
            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
    };
    ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
        var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
            cidr = this.parseCIDR(string);
            ipInterfaceOctets = cidr[0].toByteArray();
            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
            octets = [];
            i = 0;
            while(i < 4){
                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
                i++;
            }
            return new this(octets);
        } catch (error1) {
            error = error1;
            throw new Error('ipaddr: the address does not have IPv4 CIDR format');
        }
    };
    ipaddr.IPv4.networkAddressFromCIDR = function(string) {
        var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
            cidr = this.parseCIDR(string);
            ipInterfaceOctets = cidr[0].toByteArray();
            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
            octets = [];
            i = 0;
            while(i < 4){
                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
                i++;
            }
            return new this(octets);
        } catch (error1) {
            error = error1;
            throw new Error('ipaddr: the address does not have IPv4 CIDR format');
        }
    };
    ipaddr.IPv6.parseCIDR = function(string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
            maskLength = parseInt(match[2]);
            if (maskLength >= 0 && maskLength <= 128) {
                parsed = [
                    this.parse(match[1]),
                    maskLength
                ];
                Object.defineProperty(parsed, 'toString', {
                    value: function() {
                        return this.join('/');
                    }
                });
                return parsed;
            }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    };
    ipaddr.isValid = function(string) {
        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
    };
    ipaddr.parse = function(string) {
        if (ipaddr.IPv6.isValid(string)) {
            return ipaddr.IPv6.parse(string);
        } else if (ipaddr.IPv4.isValid(string)) {
            return ipaddr.IPv4.parse(string);
        } else {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
    };
    ipaddr.parseCIDR = function(string) {
        var e;
        try {
            return ipaddr.IPv6.parseCIDR(string);
        } catch (error1) {
            e = error1;
            try {
                return ipaddr.IPv4.parseCIDR(string);
            } catch (error1) {
                e = error1;
                throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
            }
        }
    };
    ipaddr.fromByteArray = function(bytes) {
        var length;
        length = bytes.length;
        if (length === 4) {
            return new ipaddr.IPv4(bytes);
        } else if (length === 16) {
            return new ipaddr.IPv6(bytes);
        } else {
            throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
    };
    ipaddr.process = function(string) {
        var addr;
        addr = this.parse(string);
        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
            return addr.toIPv4Address();
        } else {
            return addr;
        }
    };
}).call(this);
}}),
"[project]/node_modules/proxy-addr/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module exports.
 * @public
 */ module.exports = proxyaddr;
module.exports.all = alladdrs;
module.exports.compile = compile;
/**
 * Module dependencies.
 * @private
 */ var forwarded = __turbopack_context__.r("[project]/node_modules/forwarded/index.js [app-client] (ecmascript)");
var ipaddr = __turbopack_context__.r("[project]/node_modules/ipaddr.js/lib/ipaddr.js [app-client] (ecmascript)");
/**
 * Variables.
 * @private
 */ var DIGIT_REGEXP = /^[0-9]+$/;
var isip = ipaddr.isValid;
var parseip = ipaddr.parse;
/**
 * Pre-defined IP ranges.
 * @private
 */ var IP_RANGES = {
    linklocal: [
        '169.254.0.0/16',
        'fe80::/10'
    ],
    loopback: [
        '127.0.0.1/8',
        '::1/128'
    ],
    uniquelocal: [
        '10.0.0.0/8',
        '172.16.0.0/12',
        '192.168.0.0/16',
        'fc00::/7'
    ]
};
/**
 * Get all addresses in the request, optionally stopping
 * at the first untrusted.
 *
 * @param {Object} request
 * @param {Function|Array|String} [trust]
 * @public
 */ function alladdrs(req, trust) {
    // get addresses
    var addrs = forwarded(req);
    if (!trust) {
        // Return all addresses
        return addrs;
    }
    if (typeof trust !== 'function') {
        trust = compile(trust);
    }
    for(var i = 0; i < addrs.length - 1; i++){
        if (trust(addrs[i], i)) continue;
        addrs.length = i + 1;
    }
    return addrs;
}
/**
 * Compile argument into trust function.
 *
 * @param {Array|String} val
 * @private
 */ function compile(val) {
    if (!val) {
        throw new TypeError('argument is required');
    }
    var trust;
    if (typeof val === 'string') {
        trust = [
            val
        ];
    } else if (Array.isArray(val)) {
        trust = val.slice();
    } else {
        throw new TypeError('unsupported trust argument');
    }
    for(var i = 0; i < trust.length; i++){
        val = trust[i];
        if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
            continue;
        }
        // Splice in pre-defined range
        val = IP_RANGES[val];
        trust.splice.apply(trust, [
            i,
            1
        ].concat(val));
        i += val.length - 1;
    }
    return compileTrust(compileRangeSubnets(trust));
}
/**
 * Compile `arr` elements into range subnets.
 *
 * @param {Array} arr
 * @private
 */ function compileRangeSubnets(arr) {
    var rangeSubnets = new Array(arr.length);
    for(var i = 0; i < arr.length; i++){
        rangeSubnets[i] = parseipNotation(arr[i]);
    }
    return rangeSubnets;
}
/**
 * Compile range subnet array into trust function.
 *
 * @param {Array} rangeSubnets
 * @private
 */ function compileTrust(rangeSubnets) {
    // Return optimized function based on length
    var len = rangeSubnets.length;
    return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
}
/**
 * Parse IP notation string into range subnet.
 *
 * @param {String} note
 * @private
 */ function parseipNotation(note) {
    var pos = note.lastIndexOf('/');
    var str = pos !== -1 ? note.substring(0, pos) : note;
    if (!isip(str)) {
        throw new TypeError('invalid IP address: ' + str);
    }
    var ip = parseip(str);
    if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
        // Store as IPv4
        ip = ip.toIPv4Address();
    }
    var max = ip.kind() === 'ipv6' ? 128 : 32;
    var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
    if (range === null) {
        range = max;
    } else if (DIGIT_REGEXP.test(range)) {
        range = parseInt(range, 10);
    } else if (ip.kind() === 'ipv4' && isip(range)) {
        range = parseNetmask(range);
    } else {
        range = null;
    }
    if (range <= 0 || range > max) {
        throw new TypeError('invalid range on address: ' + note);
    }
    return [
        ip,
        range
    ];
}
/**
 * Parse netmask string into CIDR range.
 *
 * @param {String} netmask
 * @private
 */ function parseNetmask(netmask) {
    var ip = parseip(netmask);
    var kind = ip.kind();
    return kind === 'ipv4' ? ip.prefixLengthFromSubnetMask() : null;
}
/**
 * Determine address of proxied request.
 *
 * @param {Object} request
 * @param {Function|Array|String} trust
 * @public
 */ function proxyaddr(req, trust) {
    if (!req) {
        throw new TypeError('req argument is required');
    }
    if (!trust) {
        throw new TypeError('trust argument is required');
    }
    var addrs = alladdrs(req, trust);
    var addr = addrs[addrs.length - 1];
    return addr;
}
/**
 * Static trust function to trust nothing.
 *
 * @private
 */ function trustNone() {
    return false;
}
/**
 * Compile trust function for multiple subnets.
 *
 * @param {Array} subnets
 * @private
 */ function trustMulti(subnets) {
    return function trust(addr) {
        if (!isip(addr)) return false;
        var ip = parseip(addr);
        var ipconv;
        var kind = ip.kind();
        for(var i = 0; i < subnets.length; i++){
            var subnet = subnets[i];
            var subnetip = subnet[0];
            var subnetkind = subnetip.kind();
            var subnetrange = subnet[1];
            var trusted = ip;
            if (kind !== subnetkind) {
                if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {
                    continue;
                }
                if (!ipconv) {
                    // Convert IP to match subnet IP kind
                    ipconv = subnetkind === 'ipv4' ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
                }
                trusted = ipconv;
            }
            if (trusted.match(subnetip, subnetrange)) {
                return true;
            }
        }
        return false;
    };
}
/**
 * Compile trust function for single subnet.
 *
 * @param {Object} subnet
 * @private
 */ function trustSingle(subnet) {
    var subnetip = subnet[0];
    var subnetkind = subnetip.kind();
    var subnetisipv4 = subnetkind === 'ipv4';
    var subnetrange = subnet[1];
    return function trust(addr) {
        if (!isip(addr)) return false;
        var ip = parseip(addr);
        var kind = ip.kind();
        if (kind !== subnetkind) {
            if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
                // Incompatible IP addresses
                return false;
            }
            // Convert IP to match subnet IP kind
            ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
        }
        return ip.match(subnetip, subnetrange);
    };
}
}}),
"[project]/node_modules/wrappy/wrappy.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy;
function wrappy(fn, cb) {
    if (fn && cb) return wrappy(fn)(cb);
    if (typeof fn !== 'function') throw new TypeError('need wrapper function');
    Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
    });
    return wrapper;
    "TURBOPACK unreachable";
    function wrapper() {
        var args = new Array(arguments.length);
        for(var i = 0; i < args.length; i++){
            args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb = args[args.length - 1];
        if (typeof ret === 'function' && ret !== cb) {
            Object.keys(cb).forEach(function(k) {
                ret[k] = cb[k];
            });
        }
        return ret;
    }
}
}}),
"[project]/node_modules/once/once.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var wrappy = __turbopack_context__.r("[project]/node_modules/wrappy/wrappy.js [app-client] (ecmascript)");
module.exports = wrappy(once);
module.exports.strict = wrappy(onceStrict);
once.proto = once(function() {
    Object.defineProperty(Function.prototype, 'once', {
        value: function() {
            return once(this);
        },
        configurable: true
    });
    Object.defineProperty(Function.prototype, 'onceStrict', {
        value: function() {
            return onceStrict(this);
        },
        configurable: true
    });
});
function once(fn) {
    var f = function() {
        if (f.called) return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
}
function onceStrict(fn) {
    var f = function() {
        if (f.called) throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || 'Function wrapped with `once`';
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
}
}}),
"[project]/node_modules/router/node_modules/is-promise/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = isPromise;
module.exports.default = isPromise;
function isPromise(obj) {
    return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}
}}),
"[project]/node_modules/path-to-regexp/dist/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TokenData = void 0;
exports.parse = parse;
exports.compile = compile;
exports.match = match;
exports.pathToRegexp = pathToRegexp;
exports.stringify = stringify;
const DEFAULT_DELIMITER = "/";
const NOOP_VALUE = (value)=>value;
const ID_START = /^[$_\p{ID_Start}]$/u;
const ID_CONTINUE = /^[$\u200c\u200d\p{ID_Continue}]$/u;
const DEBUG_URL = "https://git.new/pathToRegexpError";
const SIMPLE_TOKENS = {
    // Groups.
    "{": "{",
    "}": "}",
    // Reserved.
    "(": "(",
    ")": ")",
    "[": "[",
    "]": "]",
    "+": "+",
    "?": "?",
    "!": "!"
};
/**
 * Escape text for stringify to path.
 */ function escapeText(str) {
    return str.replace(/[{}()\[\]+?!:*]/g, "\\$&");
}
/**
 * Escape a regular expression string.
 */ function escape(str) {
    return str.replace(/[.+*?^${}()[\]|/\\]/g, "\\$&");
}
/**
 * Tokenize input string.
 */ function* lexer(str) {
    const chars = [
        ...str
    ];
    let i = 0;
    function name() {
        let value = "";
        if (ID_START.test(chars[++i])) {
            value += chars[i];
            while(ID_CONTINUE.test(chars[++i])){
                value += chars[i];
            }
        } else if (chars[i] === '"') {
            let pos = i;
            while(i < chars.length){
                if (chars[++i] === '"') {
                    i++;
                    pos = 0;
                    break;
                }
                if (chars[i] === "\\") {
                    value += chars[++i];
                } else {
                    value += chars[i];
                }
            }
            if (pos) {
                throw new TypeError(`Unterminated quote at ${pos}: ${DEBUG_URL}`);
            }
        }
        if (!value) {
            throw new TypeError(`Missing parameter name at ${i}: ${DEBUG_URL}`);
        }
        return value;
    }
    while(i < chars.length){
        const value = chars[i];
        const type = SIMPLE_TOKENS[value];
        if (type) {
            yield {
                type,
                index: i++,
                value
            };
        } else if (value === "\\") {
            yield {
                type: "ESCAPED",
                index: i++,
                value: chars[i++]
            };
        } else if (value === ":") {
            const value = name();
            yield {
                type: "PARAM",
                index: i,
                value
            };
        } else if (value === "*") {
            const value = name();
            yield {
                type: "WILDCARD",
                index: i,
                value
            };
        } else {
            yield {
                type: "CHAR",
                index: i,
                value: chars[i++]
            };
        }
    }
    return {
        type: "END",
        index: i,
        value: ""
    };
}
class Iter {
    constructor(tokens){
        this.tokens = tokens;
    }
    peek() {
        if (!this._peek) {
            const next = this.tokens.next();
            this._peek = next.value;
        }
        return this._peek;
    }
    tryConsume(type) {
        const token = this.peek();
        if (token.type !== type) return;
        this._peek = undefined; // Reset after consumed.
        return token.value;
    }
    consume(type) {
        const value = this.tryConsume(type);
        if (value !== undefined) return value;
        const { type: nextType, index } = this.peek();
        throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}: ${DEBUG_URL}`);
    }
    text() {
        let result = "";
        let value;
        while(value = this.tryConsume("CHAR") || this.tryConsume("ESCAPED")){
            result += value;
        }
        return result;
    }
}
/**
 * Tokenized path instance.
 */ class TokenData {
    constructor(tokens){
        this.tokens = tokens;
    }
}
exports.TokenData = TokenData;
/**
 * Parse a string for the raw tokens.
 */ function parse(str, options = {}) {
    const { encodePath = NOOP_VALUE } = options;
    const it = new Iter(lexer(str));
    function consume(endType) {
        const tokens = [];
        while(true){
            const path = it.text();
            if (path) tokens.push({
                type: "text",
                value: encodePath(path)
            });
            const param = it.tryConsume("PARAM");
            if (param) {
                tokens.push({
                    type: "param",
                    name: param
                });
                continue;
            }
            const wildcard = it.tryConsume("WILDCARD");
            if (wildcard) {
                tokens.push({
                    type: "wildcard",
                    name: wildcard
                });
                continue;
            }
            const open = it.tryConsume("{");
            if (open) {
                tokens.push({
                    type: "group",
                    tokens: consume("}")
                });
                continue;
            }
            it.consume(endType);
            return tokens;
        }
    }
    const tokens = consume("END");
    return new TokenData(tokens);
}
/**
 * Compile a string to a template function for the path.
 */ function compile(path, options = {}) {
    const { encode = encodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;
    const data = path instanceof TokenData ? path : parse(path, options);
    const fn = tokensToFunction(data.tokens, delimiter, encode);
    return function path(data = {}) {
        const [path1, ...missing] = fn(data);
        if (missing.length) {
            throw new TypeError(`Missing parameters: ${missing.join(", ")}`);
        }
        return path1;
    };
}
function tokensToFunction(tokens, delimiter, encode) {
    const encoders = tokens.map((token)=>tokenToFunction(token, delimiter, encode));
    return (data)=>{
        const result = [
            ""
        ];
        for (const encoder of encoders){
            const [value, ...extras] = encoder(data);
            result[0] += value;
            result.push(...extras);
        }
        return result;
    };
}
/**
 * Convert a single token into a path building function.
 */ function tokenToFunction(token, delimiter, encode) {
    if (token.type === "text") return ()=>[
            token.value
        ];
    if (token.type === "group") {
        const fn = tokensToFunction(token.tokens, delimiter, encode);
        return (data)=>{
            const [value, ...missing] = fn(data);
            if (!missing.length) return [
                value
            ];
            return [
                ""
            ];
        };
    }
    const encodeValue = encode || NOOP_VALUE;
    if (token.type === "wildcard" && encode !== false) {
        return (data)=>{
            const value = data[token.name];
            if (value == null) return [
                "",
                token.name
            ];
            if (!Array.isArray(value) || value.length === 0) {
                throw new TypeError(`Expected "${token.name}" to be a non-empty array`);
            }
            return [
                value.map((value, index)=>{
                    if (typeof value !== "string") {
                        throw new TypeError(`Expected "${token.name}/${index}" to be a string`);
                    }
                    return encodeValue(value);
                }).join(delimiter)
            ];
        };
    }
    return (data)=>{
        const value = data[token.name];
        if (value == null) return [
            "",
            token.name
        ];
        if (typeof value !== "string") {
            throw new TypeError(`Expected "${token.name}" to be a string`);
        }
        return [
            encodeValue(value)
        ];
    };
}
/**
 * Transform a path into a match function.
 */ function match(path, options = {}) {
    const { decode = decodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;
    const { regexp, keys } = pathToRegexp(path, options);
    const decoders = keys.map((key)=>{
        if (decode === false) return NOOP_VALUE;
        if (key.type === "param") return decode;
        return (value)=>value.split(delimiter).map(decode);
    });
    return function match(input) {
        const m = regexp.exec(input);
        if (!m) return false;
        const path = m[0];
        const params = Object.create(null);
        for(let i = 1; i < m.length; i++){
            if (m[i] === undefined) continue;
            const key = keys[i - 1];
            const decoder = decoders[i - 1];
            params[key.name] = decoder(m[i]);
        }
        return {
            path,
            params
        };
    };
}
function pathToRegexp(path, options = {}) {
    const { delimiter = DEFAULT_DELIMITER, end = true, sensitive = false, trailing = true } = options;
    const keys = [];
    const sources = [];
    const flags = sensitive ? "" : "i";
    const paths = Array.isArray(path) ? path : [
        path
    ];
    const items = paths.map((path)=>path instanceof TokenData ? path : parse(path, options));
    for (const { tokens } of items){
        for (const seq of flatten(tokens, 0, [])){
            const regexp = sequenceToRegExp(seq, delimiter, keys);
            sources.push(regexp);
        }
    }
    let pattern = `^(?:${sources.join("|")})`;
    if (trailing) pattern += `(?:${escape(delimiter)}$)?`;
    pattern += end ? "$" : `(?=${escape(delimiter)}|$)`;
    const regexp = new RegExp(pattern, flags);
    return {
        regexp,
        keys
    };
}
/**
 * Generate a flat list of sequence tokens from the given tokens.
 */ function* flatten(tokens, index, init) {
    if (index === tokens.length) {
        return yield init;
    }
    const token = tokens[index];
    if (token.type === "group") {
        const fork = init.slice();
        for (const seq of flatten(token.tokens, 0, fork)){
            yield* flatten(tokens, index + 1, seq);
        }
    } else {
        init.push(token);
    }
    yield* flatten(tokens, index + 1, init);
}
/**
 * Transform a flat sequence of tokens into a regular expression.
 */ function sequenceToRegExp(tokens, delimiter, keys) {
    let result = "";
    let backtrack = "";
    let isSafeSegmentParam = true;
    for(let i = 0; i < tokens.length; i++){
        const token = tokens[i];
        if (token.type === "text") {
            result += escape(token.value);
            backtrack += token.value;
            isSafeSegmentParam || (isSafeSegmentParam = token.value.includes(delimiter));
            continue;
        }
        if (token.type === "param" || token.type === "wildcard") {
            if (!isSafeSegmentParam && !backtrack) {
                throw new TypeError(`Missing text after "${token.name}": ${DEBUG_URL}`);
            }
            if (token.type === "param") {
                result += `(${negate(delimiter, isSafeSegmentParam ? "" : backtrack)}+)`;
            } else {
                result += `([\\s\\S]+)`;
            }
            keys.push(token);
            backtrack = "";
            isSafeSegmentParam = false;
            continue;
        }
    }
    return result;
}
function negate(delimiter, backtrack) {
    if (backtrack.length < 2) {
        if (delimiter.length < 2) return `[^${escape(delimiter + backtrack)}]`;
        return `(?:(?!${escape(delimiter)})[^${escape(backtrack)}])`;
    }
    if (delimiter.length < 2) {
        return `(?:(?!${escape(backtrack)})[^${escape(delimiter)}])`;
    }
    return `(?:(?!${escape(backtrack)}|${escape(delimiter)})[\\s\\S])`;
}
/**
 * Stringify token data into a path string.
 */ function stringify(data) {
    return data.tokens.map(function stringifyToken(token, index, tokens) {
        if (token.type === "text") return escapeText(token.value);
        if (token.type === "group") {
            return `{${token.tokens.map(stringifyToken).join("")}}`;
        }
        const isSafe = isNameSafe(token.name) && isNextNameSafe(tokens[index + 1]);
        const key = isSafe ? token.name : JSON.stringify(token.name);
        if (token.type === "param") return `:${key}`;
        if (token.type === "wildcard") return `*${key}`;
        throw new TypeError(`Unexpected token: ${token}`);
    }).join("");
}
function isNameSafe(name) {
    const [first, ...rest] = name;
    if (!ID_START.test(first)) return false;
    return rest.every((char)=>ID_CONTINUE.test(char));
}
function isNextNameSafe(token) {
    if ((token === null || token === void 0 ? void 0 : token.type) !== "text") return true;
    return !ID_CONTINUE.test(token.value[0]);
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/router/lib/layer.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * router
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ const isPromise = __turbopack_context__.r("[project]/node_modules/router/node_modules/is-promise/index.js [app-client] (ecmascript)");
const pathRegexp = __turbopack_context__.r("[project]/node_modules/path-to-regexp/dist/index.js [app-client] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)")('router:layer');
const deprecate = __turbopack_context__.r("[project]/node_modules/depd/lib/browser/index.js [app-client] (ecmascript)")('router');
/**
 * Module variables.
 * @private
 */ const TRAILING_SLASH_REGEXP = /\/+$/;
const MATCHING_GROUP_REGEXP = /\((?:\?<(.*?)>)?(?!\?)/g;
/**
 * Expose `Layer`.
 */ module.exports = Layer;
function Layer(path, options, fn) {
    if (!(this instanceof Layer)) {
        return new Layer(path, options, fn);
    }
    debug('new %o', path);
    const opts = options || {};
    this.handle = fn;
    this.keys = [];
    this.name = fn.name || '<anonymous>';
    this.params = undefined;
    this.path = undefined;
    this.slash = path === '/' && opts.end === false;
    function matcher(_path) {
        if (_path instanceof RegExp) {
            const keys = [];
            let name = 0;
            let m;
            // eslint-disable-next-line no-cond-assign
            while(m = MATCHING_GROUP_REGEXP.exec(_path.source)){
                keys.push({
                    name: m[1] || name++,
                    offset: m.index
                });
            }
            return function regexpMatcher(p) {
                const match = _path.exec(p);
                if (!match) {
                    return false;
                }
                const params = {};
                for(let i = 1; i < match.length; i++){
                    const key = keys[i - 1];
                    const prop = key.name;
                    const val = decodeParam(match[i]);
                    if (val !== undefined) {
                        params[prop] = val;
                    }
                }
                return {
                    params,
                    path: match[0]
                };
            };
        }
        return pathRegexp.match(opts.strict ? _path : loosen(_path), {
            sensitive: opts.sensitive,
            end: opts.end,
            trailing: !opts.strict,
            decode: decodeParam
        });
    }
    this.matchers = Array.isArray(path) ? path.map(matcher) : [
        matcher(path)
    ];
}
/**
 * Handle the error for the layer.
 *
 * @param {Error} error
 * @param {Request} req
 * @param {Response} res
 * @param {function} next
 * @api private
 */ Layer.prototype.handleError = function handleError(error, req, res, next) {
    const fn = this.handle;
    if (fn.length !== 4) {
        // not a standard error handler
        return next(error);
    }
    try {
        // invoke function
        const ret = fn(error, req, res, next);
        // wait for returned promise
        if (isPromise(ret)) {
            if (!(ret instanceof Promise)) {
                deprecate('handlers that are Promise-like are deprecated, use a native Promise instead');
            }
            ret.then(null, function(error) {
                next(error || new Error('Rejected promise'));
            });
        }
    } catch (err) {
        next(err);
    }
};
/**
 * Handle the request for the layer.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {function} next
 * @api private
 */ Layer.prototype.handleRequest = function handleRequest(req, res, next) {
    const fn = this.handle;
    if (fn.length > 3) {
        // not a standard request handler
        return next();
    }
    try {
        // invoke function
        const ret = fn(req, res, next);
        // wait for returned promise
        if (isPromise(ret)) {
            if (!(ret instanceof Promise)) {
                deprecate('handlers that are Promise-like are deprecated, use a native Promise instead');
            }
            ret.then(null, function(error) {
                next(error || new Error('Rejected promise'));
            });
        }
    } catch (err) {
        next(err);
    }
};
/**
 * Check if this route matches `path`, if so
 * populate `.params`.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */ Layer.prototype.match = function match(path) {
    let match;
    if (path != null) {
        // fast path non-ending match for / (any path matches)
        if (this.slash) {
            this.params = {};
            this.path = '';
            return true;
        }
        let i = 0;
        while(!match && i < this.matchers.length){
            // match the path
            match = this.matchers[i](path);
            i++;
        }
    }
    if (!match) {
        this.params = undefined;
        this.path = undefined;
        return false;
    }
    // store values
    this.params = match.params;
    this.path = match.path;
    this.keys = Object.keys(match.params);
    return true;
};
/**
 * Decode param value.
 *
 * @param {string} val
 * @return {string}
 * @private
 */ function decodeParam(val) {
    if (typeof val !== 'string' || val.length === 0) {
        return val;
    }
    try {
        return decodeURIComponent(val);
    } catch (err) {
        if (err instanceof URIError) {
            err.message = 'Failed to decode param \'' + val + '\'';
            err.status = 400;
        }
        throw err;
    }
}
/**
 * Loosens the given path for path-to-regexp matching.
 */ function loosen(path) {
    if (path instanceof RegExp || path === '/') {
        return path;
    }
    return Array.isArray(path) ? path.map(function(p) {
        return loosen(p);
    }) : String(path).replace(TRAILING_SLASH_REGEXP, '');
}
}}),
"[project]/node_modules/router/lib/route.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * router
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ const debug = __turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)")('router:route');
const Layer = __turbopack_context__.r("[project]/node_modules/router/lib/layer.js [app-client] (ecmascript)");
const { METHODS } = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-http/index.js [app-client] (ecmascript)");
/**
 * Module variables.
 * @private
 */ const slice = Array.prototype.slice;
const flatten = Array.prototype.flat;
const methods = METHODS.map((method)=>method.toLowerCase());
/**
 * Expose `Route`.
 */ module.exports = Route;
/**
 * Initialize `Route` with the given `path`,
 *
 * @param {String} path
 * @api private
 */ function Route(path) {
    debug('new %o', path);
    this.path = path;
    this.stack = [];
    // route handlers for various http methods
    this.methods = Object.create(null);
}
/**
 * @private
 */ Route.prototype._handlesMethod = function _handlesMethod(method) {
    if (this.methods._all) {
        return true;
    }
    // normalize name
    let name = typeof method === 'string' ? method.toLowerCase() : method;
    if (name === 'head' && !this.methods.head) {
        name = 'get';
    }
    return Boolean(this.methods[name]);
};
/**
 * @return {array} supported HTTP methods
 * @private
 */ Route.prototype._methods = function _methods() {
    const methods = Object.keys(this.methods);
    // append automatic head
    if (this.methods.get && !this.methods.head) {
        methods.push('head');
    }
    for(let i = 0; i < methods.length; i++){
        // make upper case
        methods[i] = methods[i].toUpperCase();
    }
    return methods;
};
/**
 * dispatch req, res into this route
 *
 * @private
 */ Route.prototype.dispatch = function dispatch(req, res, done) {
    let idx = 0;
    const stack = this.stack;
    let sync = 0;
    if (stack.length === 0) {
        return done();
    }
    let method = typeof req.method === 'string' ? req.method.toLowerCase() : req.method;
    if (method === 'head' && !this.methods.head) {
        method = 'get';
    }
    req.route = this;
    next();
    function next(err) {
        // signal to exit route
        if (err && err === 'route') {
            return done();
        }
        // signal to exit router
        if (err && err === 'router') {
            return done(err);
        }
        // no more matching layers
        if (idx >= stack.length) {
            return done(err);
        }
        // max sync stack
        if (++sync > 100) {
            return setImmediate(next, err);
        }
        let layer;
        let match;
        // find next matching layer
        while(match !== true && idx < stack.length){
            layer = stack[idx++];
            match = !layer.method || layer.method === method;
        }
        // no match
        if (match !== true) {
            return done(err);
        }
        if (err) {
            layer.handleError(err, req, res, next);
        } else {
            layer.handleRequest(req, res, next);
        }
        sync = 0;
    }
};
/**
 * Add a handler for all HTTP verbs to this route.
 *
 * Behaves just like middleware and can respond or call `next`
 * to continue processing.
 *
 * You can use multiple `.all` call to add multiple handlers.
 *
 *   function check_something(req, res, next){
 *     next()
 *   }
 *
 *   function validate_user(req, res, next){
 *     next()
 *   }
 *
 *   route
 *   .all(validate_user)
 *   .all(check_something)
 *   .get(function(req, res, next){
 *     res.send('hello world')
 *   })
 *
 * @param {array|function} handler
 * @return {Route} for chaining
 * @api public
 */ Route.prototype.all = function all(handler) {
    const callbacks = flatten.call(slice.call(arguments), Infinity);
    if (callbacks.length === 0) {
        throw new TypeError('argument handler is required');
    }
    for(let i = 0; i < callbacks.length; i++){
        const fn = callbacks[i];
        if (typeof fn !== 'function') {
            throw new TypeError('argument handler must be a function');
        }
        const layer = Layer('/', {}, fn);
        layer.method = undefined;
        this.methods._all = true;
        this.stack.push(layer);
    }
    return this;
};
methods.forEach(function(method) {
    Route.prototype[method] = function(handler) {
        const callbacks = flatten.call(slice.call(arguments), Infinity);
        if (callbacks.length === 0) {
            throw new TypeError('argument handler is required');
        }
        for(let i = 0; i < callbacks.length; i++){
            const fn = callbacks[i];
            if (typeof fn !== 'function') {
                throw new TypeError('argument handler must be a function');
            }
            debug('%s %s', method, this.path);
            const layer = Layer('/', {}, fn);
            layer.method = method;
            this.methods[method] = true;
            this.stack.push(layer);
        }
        return this;
    };
});
}}),
"[project]/node_modules/router/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * router
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
'use strict';
/**
 * Module dependencies.
 * @private
 */ const isPromise = __turbopack_context__.r("[project]/node_modules/router/node_modules/is-promise/index.js [app-client] (ecmascript)");
const Layer = __turbopack_context__.r("[project]/node_modules/router/lib/layer.js [app-client] (ecmascript)");
const { METHODS } = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-http/index.js [app-client] (ecmascript)");
const parseUrl = __turbopack_context__.r("[project]/node_modules/parseurl/index.js [app-client] (ecmascript)");
const Route = __turbopack_context__.r("[project]/node_modules/router/lib/route.js [app-client] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)")('router');
const deprecate = __turbopack_context__.r("[project]/node_modules/depd/lib/browser/index.js [app-client] (ecmascript)")('router');
/**
 * Module variables.
 * @private
 */ const slice = Array.prototype.slice;
const flatten = Array.prototype.flat;
const methods = METHODS.map((method)=>method.toLowerCase());
/**
 * Expose `Router`.
 */ module.exports = Router;
/**
 * Expose `Route`.
 */ module.exports.Route = Route;
/**
 * Initialize a new `Router` with the given `options`.
 *
 * @param {object} [options]
 * @return {Router} which is a callable function
 * @public
 */ function Router(options) {
    if (!(this instanceof Router)) {
        return new Router(options);
    }
    const opts = options || {};
    function router(req, res, next) {
        router.handle(req, res, next);
    }
    // inherit from the correct prototype
    Object.setPrototypeOf(router, this);
    router.caseSensitive = opts.caseSensitive;
    router.mergeParams = opts.mergeParams;
    router.params = {};
    router.strict = opts.strict;
    router.stack = [];
    return router;
}
/**
 * Router prototype inherits from a Function.
 */ /* istanbul ignore next */ Router.prototype = function() {};
/**
 * Map the given param placeholder `name`(s) to the given callback.
 *
 * Parameter mapping is used to provide pre-conditions to routes
 * which use normalized placeholders. For example a _:user_id_ parameter
 * could automatically load a user's information from the database without
 * any additional code.
 *
 * The callback uses the same signature as middleware, the only difference
 * being that the value of the placeholder is passed, in this case the _id_
 * of the user. Once the `next()` function is invoked, just like middleware
 * it will continue on to execute the route, or subsequent parameter functions.
 *
 * Just like in middleware, you must either respond to the request or call next
 * to avoid stalling the request.
 *
 *  router.param('user_id', function(req, res, next, id){
 *    User.find(id, function(err, user){
 *      if (err) {
 *        return next(err)
 *      } else if (!user) {
 *        return next(new Error('failed to load user'))
 *      }
 *      req.user = user
 *      next()
 *    })
 *  })
 *
 * @param {string} name
 * @param {function} fn
 * @public
 */ Router.prototype.param = function param(name, fn) {
    if (!name) {
        throw new TypeError('argument name is required');
    }
    if (typeof name !== 'string') {
        throw new TypeError('argument name must be a string');
    }
    if (!fn) {
        throw new TypeError('argument fn is required');
    }
    if (typeof fn !== 'function') {
        throw new TypeError('argument fn must be a function');
    }
    let params = this.params[name];
    if (!params) {
        params = this.params[name] = [];
    }
    params.push(fn);
    return this;
};
/**
 * Dispatch a req, res into the router.
 *
 * @private
 */ Router.prototype.handle = function handle(req, res, callback) {
    if (!callback) {
        throw new TypeError('argument callback is required');
    }
    debug('dispatching %s %s', req.method, req.url);
    let idx = 0;
    let methods;
    const protohost = getProtohost(req.url) || '';
    let removed = '';
    const self = this;
    let slashAdded = false;
    let sync = 0;
    const paramcalled = {};
    // middleware and routes
    const stack = this.stack;
    // manage inter-router variables
    const parentParams = req.params;
    const parentUrl = req.baseUrl || '';
    let done = restore(callback, req, 'baseUrl', 'next', 'params');
    // setup next layer
    req.next = next;
    // for options requests, respond with a default if nothing else responds
    if (req.method === 'OPTIONS') {
        methods = [];
        done = wrap(done, generateOptionsResponder(res, methods));
    }
    // setup basic req values
    req.baseUrl = parentUrl;
    req.originalUrl = req.originalUrl || req.url;
    next();
    function next(err) {
        let layerError = err === 'route' ? null : err;
        // remove added slash
        if (slashAdded) {
            req.url = req.url.slice(1);
            slashAdded = false;
        }
        // restore altered req.url
        if (removed.length !== 0) {
            req.baseUrl = parentUrl;
            req.url = protohost + removed + req.url.slice(protohost.length);
            removed = '';
        }
        // signal to exit router
        if (layerError === 'router') {
            setImmediate(done, null);
            return;
        }
        // no more matching layers
        if (idx >= stack.length) {
            setImmediate(done, layerError);
            return;
        }
        // max sync stack
        if (++sync > 100) {
            return setImmediate(next, err);
        }
        // get pathname of request
        const path = getPathname(req);
        if (path == null) {
            return done(layerError);
        }
        // find next matching layer
        let layer;
        let match;
        let route;
        while(match !== true && idx < stack.length){
            layer = stack[idx++];
            match = matchLayer(layer, path);
            route = layer.route;
            if (typeof match !== 'boolean') {
                // hold on to layerError
                layerError = layerError || match;
            }
            if (match !== true) {
                continue;
            }
            if (!route) {
                continue;
            }
            if (layerError) {
                // routes do not match with a pending error
                match = false;
                continue;
            }
            const method = req.method;
            const hasMethod = route._handlesMethod(method);
            // build up automatic options response
            if (!hasMethod && method === 'OPTIONS' && methods) {
                methods.push.apply(methods, route._methods());
            }
            // don't even bother matching route
            if (!hasMethod && method !== 'HEAD') {
                match = false;
            }
        }
        // no match
        if (match !== true) {
            return done(layerError);
        }
        // store route for dispatch on change
        if (route) {
            req.route = route;
        }
        // Capture one-time layer values
        req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
        const layerPath = layer.path;
        // this should be done for the layer
        processParams(self.params, layer, paramcalled, req, res, function(err) {
            if (err) {
                next(layerError || err);
            } else if (route) {
                layer.handleRequest(req, res, next);
            } else {
                trimPrefix(layer, layerError, layerPath, path);
            }
            sync = 0;
        });
    }
    function trimPrefix(layer, layerError, layerPath, path) {
        if (layerPath.length !== 0) {
            // Validate path is a prefix match
            if (layerPath !== path.substring(0, layerPath.length)) {
                next(layerError);
                return;
            }
            // Validate path breaks on a path separator
            const c = path[layerPath.length];
            if (c && c !== '/') {
                next(layerError);
                return;
            }
            // Trim off the part of the url that matches the route
            // middleware (.use stuff) needs to have the path stripped
            debug('trim prefix (%s) from url %s', layerPath, req.url);
            removed = layerPath;
            req.url = protohost + req.url.slice(protohost.length + removed.length);
            // Ensure leading slash
            if (!protohost && req.url[0] !== '/') {
                req.url = '/' + req.url;
                slashAdded = true;
            }
            // Setup base URL (no trailing slash)
            req.baseUrl = parentUrl + (removed[removed.length - 1] === '/' ? removed.substring(0, removed.length - 1) : removed);
        }
        debug('%s %s : %s', layer.name, layerPath, req.originalUrl);
        if (layerError) {
            layer.handleError(layerError, req, res, next);
        } else {
            layer.handleRequest(req, res, next);
        }
    }
};
/**
 * Use the given middleware function, with optional path, defaulting to "/".
 *
 * Use (like `.all`) will run for any http METHOD, but it will not add
 * handlers for those methods so OPTIONS requests will not consider `.use`
 * functions even if they could respond.
 *
 * The other difference is that _route_ path is stripped and not visible
 * to the handler function. The main effect of this feature is that mounted
 * handlers can operate without any code changes regardless of the "prefix"
 * pathname.
 *
 * @public
 */ Router.prototype.use = function use(handler) {
    let offset = 0;
    let path = '/';
    // default path to '/'
    // disambiguate router.use([handler])
    if (typeof handler !== 'function') {
        let arg = handler;
        while(Array.isArray(arg) && arg.length !== 0){
            arg = arg[0];
        }
        // first arg is the path
        if (typeof arg !== 'function') {
            offset = 1;
            path = handler;
        }
    }
    const callbacks = flatten.call(slice.call(arguments, offset), Infinity);
    if (callbacks.length === 0) {
        throw new TypeError('argument handler is required');
    }
    for(let i = 0; i < callbacks.length; i++){
        const fn = callbacks[i];
        if (typeof fn !== 'function') {
            throw new TypeError('argument handler must be a function');
        }
        // add the middleware
        debug('use %o %s', path, fn.name || '<anonymous>');
        const layer = new Layer(path, {
            sensitive: this.caseSensitive,
            strict: false,
            end: false
        }, fn);
        layer.route = undefined;
        this.stack.push(layer);
    }
    return this;
};
/**
 * Create a new Route for the given path.
 *
 * Each route contains a separate middleware stack and VERB handlers.
 *
 * See the Route api documentation for details on adding handlers
 * and middleware to routes.
 *
 * @param {string} path
 * @return {Route}
 * @public
 */ Router.prototype.route = function route(path) {
    const route = new Route(path);
    const layer = new Layer(path, {
        sensitive: this.caseSensitive,
        strict: this.strict,
        end: true
    }, handle);
    function handle(req, res, next) {
        route.dispatch(req, res, next);
    }
    layer.route = route;
    this.stack.push(layer);
    return route;
};
// create Router#VERB functions
methods.concat('all').forEach(function(method) {
    Router.prototype[method] = function(path) {
        const route = this.route(path);
        route[method].apply(route, slice.call(arguments, 1));
        return this;
    };
});
/**
 * Generate a callback that will make an OPTIONS response.
 *
 * @param {OutgoingMessage} res
 * @param {array} methods
 * @private
 */ function generateOptionsResponder(res, methods) {
    return function onDone(fn, err) {
        if (err || methods.length === 0) {
            return fn(err);
        }
        trySendOptionsResponse(res, methods, fn);
    };
}
/**
 * Get pathname of request.
 *
 * @param {IncomingMessage} req
 * @private
 */ function getPathname(req) {
    try {
        return parseUrl(req).pathname;
    } catch (err) {
        return undefined;
    }
}
/**
 * Get get protocol + host for a URL.
 *
 * @param {string} url
 * @private
 */ function getProtohost(url) {
    if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {
        return undefined;
    }
    const searchIndex = url.indexOf('?');
    const pathLength = searchIndex !== -1 ? searchIndex : url.length;
    const fqdnIndex = url.substring(0, pathLength).indexOf('://');
    return fqdnIndex !== -1 ? url.substring(0, url.indexOf('/', 3 + fqdnIndex)) : undefined;
}
/**
 * Match path to a layer.
 *
 * @param {Layer} layer
 * @param {string} path
 * @private
 */ function matchLayer(layer, path) {
    try {
        return layer.match(path);
    } catch (err) {
        return err;
    }
}
/**
 * Merge params with parent params
 *
 * @private
 */ function mergeParams(params, parent) {
    if (typeof parent !== 'object' || !parent) {
        return params;
    }
    // make copy of parent for base
    const obj = Object.assign({}, parent);
    // simple non-numeric merging
    if (!(0 in params) || !(0 in parent)) {
        return Object.assign(obj, params);
    }
    let i = 0;
    let o = 0;
    // determine numeric gap in params
    while(i in params){
        i++;
    }
    // determine numeric gap in parent
    while(o in parent){
        o++;
    }
    // offset numeric indices in params before merge
    for(i--; i >= 0; i--){
        params[i + o] = params[i];
        // create holes for the merge when necessary
        if (i < o) {
            delete params[i];
        }
    }
    return Object.assign(obj, params);
}
/**
 * Process any parameters for the layer.
 *
 * @private
 */ function processParams(params, layer, called, req, res, done) {
    // captured parameters from the layer, keys and values
    const keys = layer.keys;
    // fast track
    if (!keys || keys.length === 0) {
        return done();
    }
    let i = 0;
    let paramIndex = 0;
    let key;
    let paramVal;
    let paramCallbacks;
    let paramCalled;
    // process params in order
    // param callbacks can be async
    function param(err) {
        if (err) {
            return done(err);
        }
        if (i >= keys.length) {
            return done();
        }
        paramIndex = 0;
        key = keys[i++];
        paramVal = req.params[key];
        paramCallbacks = params[key];
        paramCalled = called[key];
        if (paramVal === undefined || !paramCallbacks) {
            return param();
        }
        // param previously called with same value or error occurred
        if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== 'route')) {
            // restore value
            req.params[key] = paramCalled.value;
            // next param
            return param(paramCalled.error);
        }
        called[key] = paramCalled = {
            error: null,
            match: paramVal,
            value: paramVal
        };
        paramCallback();
    }
    // single param callbacks
    function paramCallback(err) {
        const fn = paramCallbacks[paramIndex++];
        // store updated value
        paramCalled.value = req.params[key];
        if (err) {
            // store error
            paramCalled.error = err;
            param(err);
            return;
        }
        if (!fn) return param();
        try {
            const ret = fn(req, res, paramCallback, paramVal, key);
            if (isPromise(ret)) {
                if (!(ret instanceof Promise)) {
                    deprecate('parameters that are Promise-like are deprecated, use a native Promise instead');
                }
                ret.then(null, function(error) {
                    paramCallback(error || new Error('Rejected promise'));
                });
            }
        } catch (e) {
            paramCallback(e);
        }
    }
    param();
}
/**
 * Restore obj props after function
 *
 * @private
 */ function restore(fn, obj) {
    const props = new Array(arguments.length - 2);
    const vals = new Array(arguments.length - 2);
    for(let i = 0; i < props.length; i++){
        props[i] = arguments[i + 2];
        vals[i] = obj[props[i]];
    }
    return function() {
        // restore vals
        for(let i = 0; i < props.length; i++){
            obj[props[i]] = vals[i];
        }
        return fn.apply(this, arguments);
    };
}
/**
 * Send an OPTIONS response.
 *
 * @private
 */ function sendOptionsResponse(res, methods) {
    const options = Object.create(null);
    // build unique method map
    for(let i = 0; i < methods.length; i++){
        options[methods[i]] = true;
    }
    // construct the allow list
    const allow = Object.keys(options).sort().join(', ');
    // send response
    res.setHeader('Allow', allow);
    res.setHeader('Content-Length', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].byteLength(allow));
    res.setHeader('Content-Type', 'text/plain');
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.end(allow);
}
/**
 * Try to send an OPTIONS response.
 *
 * @private
 */ function trySendOptionsResponse(res, methods, next) {
    try {
        sendOptionsResponse(res, methods);
    } catch (err) {
        next(err);
    }
}
/**
 * Wrap a function
 *
 * @private
 */ function wrap(old, fn) {
    return function proxy() {
        const args = new Array(arguments.length + 1);
        args[0] = old;
        for(let i = 0, len = arguments.length; i < len; i++){
            args[i + 1] = arguments[i];
        }
        fn.apply(this, args);
    };
}
}}),
"[project]/node_modules/negotiator/lib/charset.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module exports.
 * @public
 */ module.exports = preferredCharsets;
module.exports.preferredCharsets = preferredCharsets;
/**
 * Module variables.
 * @private
 */ var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
/**
 * Parse the Accept-Charset header.
 * @private
 */ function parseAcceptCharset(accept) {
    var accepts = accept.split(',');
    for(var i = 0, j = 0; i < accepts.length; i++){
        var charset = parseCharset(accepts[i].trim(), i);
        if (charset) {
            accepts[j++] = charset;
        }
    }
    // trim accepts
    accepts.length = j;
    return accepts;
}
/**
 * Parse a charset from the Accept-Charset header.
 * @private
 */ function parseCharset(str, i) {
    var match = simpleCharsetRegExp.exec(str);
    if (!match) return null;
    var charset = match[1];
    var q = 1;
    if (match[2]) {
        var params = match[2].split(';');
        for(var j = 0; j < params.length; j++){
            var p = params[j].trim().split('=');
            if (p[0] === 'q') {
                q = parseFloat(p[1]);
                break;
            }
        }
    }
    return {
        charset: charset,
        q: q,
        i: i
    };
}
/**
 * Get the priority of a charset.
 * @private
 */ function getCharsetPriority(charset, accepted, index) {
    var priority = {
        o: -1,
        q: 0,
        s: 0
    };
    for(var i = 0; i < accepted.length; i++){
        var spec = specify(charset, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
            priority = spec;
        }
    }
    return priority;
}
/**
 * Get the specificity of the charset.
 * @private
 */ function specify(charset, spec, index) {
    var s = 0;
    if (spec.charset.toLowerCase() === charset.toLowerCase()) {
        s |= 1;
    } else if (spec.charset !== '*') {
        return null;
    }
    return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s
    };
}
/**
 * Get the preferred charsets from an Accept-Charset header.
 * @public
 */ function preferredCharsets(accept, provided) {
    // RFC 2616 sec 14.2: no header = *
    var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');
    if (!provided) {
        // sorted list of all charsets
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
    }
    var priorities = provided.map(function getPriority(type, index) {
        return getCharsetPriority(type, accepts, index);
    });
    // sorted list of accepted charsets
    return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
        return provided[priorities.indexOf(priority)];
    });
}
/**
 * Compare two specs.
 * @private
 */ function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
/**
 * Get full charset string.
 * @private
 */ function getFullCharset(spec) {
    return spec.charset;
}
/**
 * Check if a spec has any quality.
 * @private
 */ function isQuality(spec) {
    return spec.q > 0;
}
}}),
"[project]/node_modules/negotiator/lib/encoding.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module exports.
 * @public
 */ module.exports = preferredEncodings;
module.exports.preferredEncodings = preferredEncodings;
/**
 * Module variables.
 * @private
 */ var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
/**
 * Parse the Accept-Encoding header.
 * @private
 */ function parseAcceptEncoding(accept) {
    var accepts = accept.split(',');
    var hasIdentity = false;
    var minQuality = 1;
    for(var i = 0, j = 0; i < accepts.length; i++){
        var encoding = parseEncoding(accepts[i].trim(), i);
        if (encoding) {
            accepts[j++] = encoding;
            hasIdentity = hasIdentity || specify('identity', encoding);
            minQuality = Math.min(minQuality, encoding.q || 1);
        }
    }
    if (!hasIdentity) {
        /*
     * If identity doesn't explicitly appear in the accept-encoding header,
     * it's added to the list of acceptable encoding with the lowest q
     */ accepts[j++] = {
            encoding: 'identity',
            q: minQuality,
            i: i
        };
    }
    // trim accepts
    accepts.length = j;
    return accepts;
}
/**
 * Parse an encoding from the Accept-Encoding header.
 * @private
 */ function parseEncoding(str, i) {
    var match = simpleEncodingRegExp.exec(str);
    if (!match) return null;
    var encoding = match[1];
    var q = 1;
    if (match[2]) {
        var params = match[2].split(';');
        for(var j = 0; j < params.length; j++){
            var p = params[j].trim().split('=');
            if (p[0] === 'q') {
                q = parseFloat(p[1]);
                break;
            }
        }
    }
    return {
        encoding: encoding,
        q: q,
        i: i
    };
}
/**
 * Get the priority of an encoding.
 * @private
 */ function getEncodingPriority(encoding, accepted, index) {
    var priority = {
        encoding: encoding,
        o: -1,
        q: 0,
        s: 0
    };
    for(var i = 0; i < accepted.length; i++){
        var spec = specify(encoding, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
            priority = spec;
        }
    }
    return priority;
}
/**
 * Get the specificity of the encoding.
 * @private
 */ function specify(encoding, spec, index) {
    var s = 0;
    if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
        s |= 1;
    } else if (spec.encoding !== '*') {
        return null;
    }
    return {
        encoding: encoding,
        i: index,
        o: spec.i,
        q: spec.q,
        s: s
    };
}
;
/**
 * Get the preferred encodings from an Accept-Encoding header.
 * @public
 */ function preferredEncodings(accept, provided, preferred) {
    var accepts = parseAcceptEncoding(accept || '');
    var comparator = preferred ? function comparator(a, b) {
        if (a.q !== b.q) {
            return b.q - a.q // higher quality first
            ;
        }
        var aPreferred = preferred.indexOf(a.encoding);
        var bPreferred = preferred.indexOf(b.encoding);
        if (aPreferred === -1 && bPreferred === -1) {
            // consider the original specifity/order
            return b.s - a.s || a.o - b.o || a.i - b.i;
        }
        if (aPreferred !== -1 && bPreferred !== -1) {
            return aPreferred - bPreferred // consider the preferred order
            ;
        }
        return aPreferred === -1 ? 1 : -1 // preferred first
        ;
    } : compareSpecs;
    if (!provided) {
        // sorted list of all encodings
        return accepts.filter(isQuality).sort(comparator).map(getFullEncoding);
    }
    var priorities = provided.map(function getPriority(type, index) {
        return getEncodingPriority(type, accepts, index);
    });
    // sorted list of accepted encodings
    return priorities.filter(isQuality).sort(comparator).map(function getEncoding(priority) {
        return provided[priorities.indexOf(priority)];
    });
}
/**
 * Compare two specs.
 * @private
 */ function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i;
}
/**
 * Get full encoding string.
 * @private
 */ function getFullEncoding(spec) {
    return spec.encoding;
}
/**
 * Check if a spec has any quality.
 * @private
 */ function isQuality(spec) {
    return spec.q > 0;
}
}}),
"[project]/node_modules/negotiator/lib/language.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module exports.
 * @public
 */ module.exports = preferredLanguages;
module.exports.preferredLanguages = preferredLanguages;
/**
 * Module variables.
 * @private
 */ var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
/**
 * Parse the Accept-Language header.
 * @private
 */ function parseAcceptLanguage(accept) {
    var accepts = accept.split(',');
    for(var i = 0, j = 0; i < accepts.length; i++){
        var language = parseLanguage(accepts[i].trim(), i);
        if (language) {
            accepts[j++] = language;
        }
    }
    // trim accepts
    accepts.length = j;
    return accepts;
}
/**
 * Parse a language from the Accept-Language header.
 * @private
 */ function parseLanguage(str, i) {
    var match = simpleLanguageRegExp.exec(str);
    if (!match) return null;
    var prefix = match[1];
    var suffix = match[2];
    var full = prefix;
    if (suffix) full += "-" + suffix;
    var q = 1;
    if (match[3]) {
        var params = match[3].split(';');
        for(var j = 0; j < params.length; j++){
            var p = params[j].split('=');
            if (p[0] === 'q') q = parseFloat(p[1]);
        }
    }
    return {
        prefix: prefix,
        suffix: suffix,
        q: q,
        i: i,
        full: full
    };
}
/**
 * Get the priority of a language.
 * @private
 */ function getLanguagePriority(language, accepted, index) {
    var priority = {
        o: -1,
        q: 0,
        s: 0
    };
    for(var i = 0; i < accepted.length; i++){
        var spec = specify(language, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
            priority = spec;
        }
    }
    return priority;
}
/**
 * Get the specificity of the language.
 * @private
 */ function specify(language, spec, index) {
    var p = parseLanguage(language);
    if (!p) return null;
    var s = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
        s |= 4;
    } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
        s |= 2;
    } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
        s |= 1;
    } else if (spec.full !== '*') {
        return null;
    }
    return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s
    };
}
;
/**
 * Get the preferred languages from an Accept-Language header.
 * @public
 */ function preferredLanguages(accept, provided) {
    // RFC 2616 sec 14.4: no header = *
    var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');
    if (!provided) {
        // sorted list of all languages
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
    }
    var priorities = provided.map(function getPriority(type, index) {
        return getLanguagePriority(type, accepts, index);
    });
    // sorted list of accepted languages
    return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
        return provided[priorities.indexOf(priority)];
    });
}
/**
 * Compare two specs.
 * @private
 */ function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
/**
 * Get full language string.
 * @private
 */ function getFullLanguage(spec) {
    return spec.full;
}
/**
 * Check if a spec has any quality.
 * @private
 */ function isQuality(spec) {
    return spec.q > 0;
}
}}),
"[project]/node_modules/negotiator/lib/mediaType.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module exports.
 * @public
 */ module.exports = preferredMediaTypes;
module.exports.preferredMediaTypes = preferredMediaTypes;
/**
 * Module variables.
 * @private
 */ var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
/**
 * Parse the Accept header.
 * @private
 */ function parseAccept(accept) {
    var accepts = splitMediaTypes(accept);
    for(var i = 0, j = 0; i < accepts.length; i++){
        var mediaType = parseMediaType(accepts[i].trim(), i);
        if (mediaType) {
            accepts[j++] = mediaType;
        }
    }
    // trim accepts
    accepts.length = j;
    return accepts;
}
/**
 * Parse a media type from the Accept header.
 * @private
 */ function parseMediaType(str, i) {
    var match = simpleMediaTypeRegExp.exec(str);
    if (!match) return null;
    var params = Object.create(null);
    var q = 1;
    var subtype = match[2];
    var type = match[1];
    if (match[3]) {
        var kvps = splitParameters(match[3]).map(splitKeyValuePair);
        for(var j = 0; j < kvps.length; j++){
            var pair = kvps[j];
            var key = pair[0].toLowerCase();
            var val = pair[1];
            // get the value, unwrapping quotes
            var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.slice(1, -1) : val;
            if (key === 'q') {
                q = parseFloat(value);
                break;
            }
            // store parameter
            params[key] = value;
        }
    }
    return {
        type: type,
        subtype: subtype,
        params: params,
        q: q,
        i: i
    };
}
/**
 * Get the priority of a media type.
 * @private
 */ function getMediaTypePriority(type, accepted, index) {
    var priority = {
        o: -1,
        q: 0,
        s: 0
    };
    for(var i = 0; i < accepted.length; i++){
        var spec = specify(type, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
            priority = spec;
        }
    }
    return priority;
}
/**
 * Get the specificity of the media type.
 * @private
 */ function specify(type, spec, index) {
    var p = parseMediaType(type);
    var s = 0;
    if (!p) {
        return null;
    }
    if (spec.type.toLowerCase() == p.type.toLowerCase()) {
        s |= 4;
    } else if (spec.type != '*') {
        return null;
    }
    if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
        s |= 2;
    } else if (spec.subtype != '*') {
        return null;
    }
    var keys = Object.keys(spec.params);
    if (keys.length > 0) {
        if (keys.every(function(k) {
            return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
        })) {
            s |= 1;
        } else {
            return null;
        }
    }
    return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s
    };
}
/**
 * Get the preferred media types from an Accept header.
 * @public
 */ function preferredMediaTypes(accept, provided) {
    // RFC 2616 sec 14.2: no header = */*
    var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');
    if (!provided) {
        // sorted list of all types
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
    }
    var priorities = provided.map(function getPriority(type, index) {
        return getMediaTypePriority(type, accepts, index);
    });
    // sorted list of accepted types
    return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
        return provided[priorities.indexOf(priority)];
    });
}
/**
 * Compare two specs.
 * @private
 */ function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
/**
 * Get full type string.
 * @private
 */ function getFullType(spec) {
    return spec.type + '/' + spec.subtype;
}
/**
 * Check if a spec has any quality.
 * @private
 */ function isQuality(spec) {
    return spec.q > 0;
}
/**
 * Count the number of quotes in a string.
 * @private
 */ function quoteCount(string) {
    var count = 0;
    var index = 0;
    while((index = string.indexOf('"', index)) !== -1){
        count++;
        index++;
    }
    return count;
}
/**
 * Split a key value pair.
 * @private
 */ function splitKeyValuePair(str) {
    var index = str.indexOf('=');
    var key;
    var val;
    if (index === -1) {
        key = str;
    } else {
        key = str.slice(0, index);
        val = str.slice(index + 1);
    }
    return [
        key,
        val
    ];
}
/**
 * Split an Accept header into media types.
 * @private
 */ function splitMediaTypes(accept) {
    var accepts = accept.split(',');
    for(var i = 1, j = 0; i < accepts.length; i++){
        if (quoteCount(accepts[j]) % 2 == 0) {
            accepts[++j] = accepts[i];
        } else {
            accepts[j] += ',' + accepts[i];
        }
    }
    // trim accepts
    accepts.length = j + 1;
    return accepts;
}
/**
 * Split a string of parameters.
 * @private
 */ function splitParameters(str) {
    var parameters = str.split(';');
    for(var i = 1, j = 0; i < parameters.length; i++){
        if (quoteCount(parameters[j]) % 2 == 0) {
            parameters[++j] = parameters[i];
        } else {
            parameters[j] += ';' + parameters[i];
        }
    }
    // trim parameters
    parameters.length = j + 1;
    for(var i = 0; i < parameters.length; i++){
        parameters[i] = parameters[i].trim();
    }
    return parameters;
}
}}),
"[project]/node_modules/negotiator/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
var preferredCharsets = __turbopack_context__.r("[project]/node_modules/negotiator/lib/charset.js [app-client] (ecmascript)");
var preferredEncodings = __turbopack_context__.r("[project]/node_modules/negotiator/lib/encoding.js [app-client] (ecmascript)");
var preferredLanguages = __turbopack_context__.r("[project]/node_modules/negotiator/lib/language.js [app-client] (ecmascript)");
var preferredMediaTypes = __turbopack_context__.r("[project]/node_modules/negotiator/lib/mediaType.js [app-client] (ecmascript)");
/**
 * Module exports.
 * @public
 */ module.exports = Negotiator;
module.exports.Negotiator = Negotiator;
/**
 * Create a Negotiator instance from a request.
 * @param {object} request
 * @public
 */ function Negotiator(request) {
    if (!(this instanceof Negotiator)) {
        return new Negotiator(request);
    }
    this.request = request;
}
Negotiator.prototype.charset = function charset(available) {
    var set = this.charsets(available);
    return set && set[0];
};
Negotiator.prototype.charsets = function charsets(available) {
    return preferredCharsets(this.request.headers['accept-charset'], available);
};
Negotiator.prototype.encoding = function encoding(available, opts) {
    var set = this.encodings(available, opts);
    return set && set[0];
};
Negotiator.prototype.encodings = function encodings(available, options) {
    var opts = options || {};
    return preferredEncodings(this.request.headers['accept-encoding'], available, opts.preferred);
};
Negotiator.prototype.language = function language(available) {
    var set = this.languages(available);
    return set && set[0];
};
Negotiator.prototype.languages = function languages(available) {
    return preferredLanguages(this.request.headers['accept-language'], available);
};
Negotiator.prototype.mediaType = function mediaType(available) {
    var set = this.mediaTypes(available);
    return set && set[0];
};
Negotiator.prototype.mediaTypes = function mediaTypes(available) {
    return preferredMediaTypes(this.request.headers.accept, available);
};
// Backwards compatibility
Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
}}),
"[project]/node_modules/accepts/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ var Negotiator = __turbopack_context__.r("[project]/node_modules/negotiator/index.js [app-client] (ecmascript)");
var mime = __turbopack_context__.r("[project]/node_modules/accepts/node_modules/mime-types/index.js [app-client] (ecmascript)");
/**
 * Module exports.
 * @public
 */ module.exports = Accepts;
/**
 * Create a new Accepts object for the given req.
 *
 * @param {object} req
 * @public
 */ function Accepts(req) {
    if (!(this instanceof Accepts)) {
        return new Accepts(req);
    }
    this.headers = req.headers;
    this.negotiator = new Negotiator(req);
}
/**
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single mime type string
 * such as "application/json", the extension name
 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
 * or array is given the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     this.types('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     this.types('html');
 *     // => "html"
 *     this.types('text/html');
 *     // => "text/html"
 *     this.types('json', 'text');
 *     // => "json"
 *     this.types('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     this.types('image/png');
 *     this.types('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     this.types(['html', 'json']);
 *     this.types('html', 'json');
 *     // => "json"
 *
 * @param {String|Array} types...
 * @return {String|Array|Boolean}
 * @public
 */ Accepts.prototype.type = Accepts.prototype.types = function(types_) {
    var types = types_;
    // support flattened arguments
    if (types && !Array.isArray(types)) {
        types = new Array(arguments.length);
        for(var i = 0; i < types.length; i++){
            types[i] = arguments[i];
        }
    }
    // no types, return all requested types
    if (!types || types.length === 0) {
        return this.negotiator.mediaTypes();
    }
    // no accept header, return first given type
    if (!this.headers.accept) {
        return types[0];
    }
    var mimes = types.map(extToMime);
    var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
    var first = accepts[0];
    return first ? types[mimes.indexOf(first)] : false;
};
/**
 * Return accepted encodings or best fit based on `encodings`.
 *
 * Given `Accept-Encoding: gzip, deflate`
 * an array sorted by quality is returned:
 *
 *     ['gzip', 'deflate']
 *
 * @param {String|Array} encodings...
 * @return {String|Array}
 * @public
 */ Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
    var encodings = encodings_;
    // support flattened arguments
    if (encodings && !Array.isArray(encodings)) {
        encodings = new Array(arguments.length);
        for(var i = 0; i < encodings.length; i++){
            encodings[i] = arguments[i];
        }
    }
    // no encodings, return all requested encodings
    if (!encodings || encodings.length === 0) {
        return this.negotiator.encodings();
    }
    return this.negotiator.encodings(encodings)[0] || false;
};
/**
 * Return accepted charsets or best fit based on `charsets`.
 *
 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
 * an array sorted by quality is returned:
 *
 *     ['utf-8', 'utf-7', 'iso-8859-1']
 *
 * @param {String|Array} charsets...
 * @return {String|Array}
 * @public
 */ Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
    var charsets = charsets_;
    // support flattened arguments
    if (charsets && !Array.isArray(charsets)) {
        charsets = new Array(arguments.length);
        for(var i = 0; i < charsets.length; i++){
            charsets[i] = arguments[i];
        }
    }
    // no charsets, return all requested charsets
    if (!charsets || charsets.length === 0) {
        return this.negotiator.charsets();
    }
    return this.negotiator.charsets(charsets)[0] || false;
};
/**
 * Return accepted languages or best fit based on `langs`.
 *
 * Given `Accept-Language: en;q=0.8, es, pt`
 * an array sorted by quality is returned:
 *
 *     ['es', 'pt', 'en']
 *
 * @param {String|Array} langs...
 * @return {Array|String}
 * @public
 */ Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
    var languages = languages_;
    // support flattened arguments
    if (languages && !Array.isArray(languages)) {
        languages = new Array(arguments.length);
        for(var i = 0; i < languages.length; i++){
            languages[i] = arguments[i];
        }
    }
    // no languages, return all requested languages
    if (!languages || languages.length === 0) {
        return this.negotiator.languages();
    }
    return this.negotiator.languages(languages)[0] || false;
};
/**
 * Convert extnames to mime.
 *
 * @param {String} type
 * @return {String}
 * @private
 */ function extToMime(type) {
    return type.indexOf('/') === -1 ? mime.lookup(type) : type;
}
/**
 * Check if mime is valid.
 *
 * @param {String} type
 * @return {Boolean}
 * @private
 */ function validMime(type) {
    return typeof type === 'string';
}
}}),
"[project]/node_modules/safe-buffer/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src){
        dst[key] = src[key];
    }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
} else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
    }
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === 'string') {
            buf.fill(fill, encoding);
        } else {
            buf.fill(fill);
        }
    } else {
        buf.fill(0);
    }
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return buffer.SlowBuffer(size);
};
}}),
"[project]/node_modules/content-disposition/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module exports.
 * @public
 */ module.exports = contentDisposition;
module.exports.parse = parse;
/**
 * Module dependencies.
 * @private
 */ var basename = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)").basename;
var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-client] (ecmascript)").Buffer;
/**
 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
 * @private
 */ var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g // eslint-disable-line no-control-regex
;
/**
 * RegExp to match percent encoding escape.
 * @private
 */ var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
/**
 * RegExp to match non-latin1 characters.
 * @private
 */ var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 * @private
 */ var QESC_REGEXP = /\\([\u0000-\u007f])/g // eslint-disable-line no-control-regex
;
/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 * @private
 */ var QUOTE_REGEXP = /([\\"])/g;
/**
 * RegExp for various RFC 2616 grammar
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * HT            = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 * @private
 */ var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g // eslint-disable-line no-control-regex
;
var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
/**
 * RegExp for various RFC 5987 grammar
 *
 * ext-value     = charset  "'" [ language ] "'" value-chars
 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
 * mime-charset  = 1*mime-charsetc
 * mime-charsetc = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "%" / "&"
 *               / "+" / "-" / "^" / "_" / "`"
 *               / "{" / "}" / "~"
 * language      = ( 2*3ALPHA [ extlang ] )
 *               / 4ALPHA
 *               / 5*8ALPHA
 * extlang       = *3( "-" 3ALPHA )
 * value-chars   = *( pct-encoded / attr-char )
 * pct-encoded   = "%" HEXDIG HEXDIG
 * attr-char     = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
 *               / "^" / "_" / "`" / "|" / "~"
 * @private
 */ var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
/**
 * RegExp for various RFC 6266 grammar
 *
 * disposition-type = "inline" | "attachment" | disp-ext-type
 * disp-ext-type    = token
 * disposition-parm = filename-parm | disp-ext-parm
 * filename-parm    = "filename" "=" value
 *                  | "filename*" "=" ext-value
 * disp-ext-parm    = token "=" value
 *                  | ext-token "=" ext-value
 * ext-token        = <the characters in token, followed by "*">
 * @private
 */ var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/ // eslint-disable-line no-control-regex
;
/**
 * Create an attachment Content-Disposition header.
 *
 * @param {string} [filename]
 * @param {object} [options]
 * @param {string} [options.type=attachment]
 * @param {string|boolean} [options.fallback=true]
 * @return {string}
 * @public
 */ function contentDisposition(filename, options) {
    var opts = options || {};
    // get type
    var type = opts.type || 'attachment';
    // get parameters
    var params = createparams(filename, opts.fallback);
    // format into string
    return format(new ContentDisposition(type, params));
}
/**
 * Create parameters object from filename and fallback.
 *
 * @param {string} [filename]
 * @param {string|boolean} [fallback=true]
 * @return {object}
 * @private
 */ function createparams(filename, fallback) {
    if (filename === undefined) {
        return;
    }
    var params = {};
    if (typeof filename !== 'string') {
        throw new TypeError('filename must be a string');
    }
    // fallback defaults to true
    if (fallback === undefined) {
        fallback = true;
    }
    if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
        throw new TypeError('fallback must be a string or boolean');
    }
    if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {
        throw new TypeError('fallback must be ISO-8859-1 string');
    }
    // restrict to file base name
    var name = basename(filename);
    // determine if name is suitable for quoted string
    var isQuotedString = TEXT_REGEXP.test(name);
    // generate fallback name
    var fallbackName = typeof fallback !== 'string' ? fallback && getlatin1(name) : basename(fallback);
    var hasFallback = typeof fallbackName === 'string' && fallbackName !== name;
    // set extended filename parameter
    if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
        params['filename*'] = name;
    }
    // set filename parameter
    if (isQuotedString || hasFallback) {
        params.filename = hasFallback ? fallbackName : name;
    }
    return params;
}
/**
 * Format object to Content-Disposition header.
 *
 * @param {object} obj
 * @param {string} obj.type
 * @param {object} [obj.parameters]
 * @return {string}
 * @private
 */ function format(obj) {
    var parameters = obj.parameters;
    var type = obj.type;
    if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {
        throw new TypeError('invalid type');
    }
    // start with normalized type
    var string = String(type).toLowerCase();
    // append parameters
    if (parameters && typeof parameters === 'object') {
        var param;
        var params = Object.keys(parameters).sort();
        for(var i = 0; i < params.length; i++){
            param = params[i];
            var val = param.slice(-1) === '*' ? ustring(parameters[param]) : qstring(parameters[param]);
            string += '; ' + param + '=' + val;
        }
    }
    return string;
}
/**
 * Decode a RFC 5987 field value (gracefully).
 *
 * @param {string} str
 * @return {string}
 * @private
 */ function decodefield(str) {
    var match = EXT_VALUE_REGEXP.exec(str);
    if (!match) {
        throw new TypeError('invalid extended field value');
    }
    var charset = match[1].toLowerCase();
    var encoded = match[2];
    var value;
    // to binary string
    var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
    switch(charset){
        case 'iso-8859-1':
            value = getlatin1(binary);
            break;
        case 'utf-8':
        case 'utf8':
            value = Buffer.from(binary, 'binary').toString('utf8');
            break;
        default:
            throw new TypeError('unsupported charset in extended field');
    }
    return value;
}
/**
 * Get ISO-8859-1 version of string.
 *
 * @param {string} val
 * @return {string}
 * @private
 */ function getlatin1(val) {
    // simple Unicode -> ISO-8859-1 transformation
    return String(val).replace(NON_LATIN1_REGEXP, '?');
}
/**
 * Parse Content-Disposition header string.
 *
 * @param {string} string
 * @return {object}
 * @public
 */ function parse(string) {
    if (!string || typeof string !== 'string') {
        throw new TypeError('argument string is required');
    }
    var match = DISPOSITION_TYPE_REGEXP.exec(string);
    if (!match) {
        throw new TypeError('invalid type format');
    }
    // normalize type
    var index = match[0].length;
    var type = match[1].toLowerCase();
    var key;
    var names = [];
    var params = {};
    var value;
    // calculate index to start at
    index = PARAM_REGEXP.lastIndex = match[0].slice(-1) === ';' ? index - 1 : index;
    // match parameters
    while(match = PARAM_REGEXP.exec(string)){
        if (match.index !== index) {
            throw new TypeError('invalid parameter format');
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (names.indexOf(key) !== -1) {
            throw new TypeError('invalid duplicate parameter');
        }
        names.push(key);
        if (key.indexOf('*') + 1 === key.length) {
            // decode extended value
            key = key.slice(0, -1);
            value = decodefield(value);
            // overwrite existing value
            params[key] = value;
            continue;
        }
        if (typeof params[key] === 'string') {
            continue;
        }
        if (value[0] === '"') {
            // remove quotes and escapes
            value = value.slice(1, -1).replace(QESC_REGEXP, '$1');
        }
        params[key] = value;
    }
    if (index !== -1 && index !== string.length) {
        throw new TypeError('invalid parameter format');
    }
    return new ContentDisposition(type, params);
}
/**
 * Percent decode a single character.
 *
 * @param {string} str
 * @param {string} hex
 * @return {string}
 * @private
 */ function pdecode(str, hex) {
    return String.fromCharCode(parseInt(hex, 16));
}
/**
 * Percent encode a single character.
 *
 * @param {string} char
 * @return {string}
 * @private
 */ function pencode(char) {
    return '%' + String(char).charCodeAt(0).toString(16).toUpperCase();
}
/**
 * Quote a string for HTTP.
 *
 * @param {string} val
 * @return {string}
 * @private
 */ function qstring(val) {
    var str = String(val);
    return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
}
/**
 * Encode a Unicode string for HTTP (RFC 5987).
 *
 * @param {string} val
 * @return {string}
 * @private
 */ function ustring(val) {
    var str = String(val);
    // percent encode as UTF-8
    var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
    return 'UTF-8\'\'' + encoded;
}
/**
 * Class for parsed Content-Disposition header for v8 optimization
 *
 * @public
 * @param {string} type
 * @param {object} parameters
 * @constructor
 */ function ContentDisposition(type, parameters) {
    this.type = type;
    this.parameters = parameters;
}
}}),
"[project]/node_modules/cookie-signature/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Module dependencies.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var crypto = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/crypto-browserify/index.js [app-client] (ecmascript)");
/**
 * Sign the given `val` with `secret`.
 *
 * @param {String} val
 * @param {String|NodeJS.ArrayBufferView|crypto.KeyObject} secret
 * @return {String}
 * @api private
 */ exports.sign = function(val, secret) {
    if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
    if (null == secret) throw new TypeError("Secret key must be provided.");
    return val + '.' + crypto.createHmac('sha256', secret).update(val).digest('base64').replace(/\=+$/, '');
};
/**
 * Unsign and decode the given `input` with `secret`,
 * returning `false` if the signature is invalid.
 *
 * @param {String} input
 * @param {String|NodeJS.ArrayBufferView|crypto.KeyObject} secret
 * @return {String|Boolean}
 * @api private
 */ exports.unsign = function(input, secret) {
    if ('string' != typeof input) throw new TypeError("Signed cookie string must be provided.");
    if (null == secret) throw new TypeError("Secret key must be provided.");
    var tentativeValue = input.slice(0, input.lastIndexOf('.')), expectedInput = exports.sign(tentativeValue, secret), expectedBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(expectedInput), inputBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(input);
    return expectedBuffer.length === inputBuffer.length && crypto.timingSafeEqual(expectedBuffer, inputBuffer) ? tentativeValue : false;
};
}}),
"[project]/node_modules/cookie/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module exports.
 * @public
 */ exports.parse = parse;
exports.serialize = serialize;
/**
 * Module variables.
 * @private
 */ var __toString = Object.prototype.toString;
var __hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
 * which has been replaced by the token definition in RFC 7230 appendix B.
 *
 * cookie-name       = token
 * token             = 1*tchar
 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
 *                     "*" / "+" / "-" / "." / "^" / "_" /
 *                     "`" / "|" / "~" / DIGIT / ALPHA
 */ var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
/**
 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
 *
 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
 *                     ; US-ASCII characters excluding CTLs,
 *                     ; whitespace DQUOTE, comma, semicolon,
 *                     ; and backslash
 */ var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
/**
 * RegExp to match domain-value in RFC 6265 sec 4.1.1
 *
 * domain-value      = <subdomain>
 *                     ; defined in [RFC1034], Section 3.5, as
 *                     ; enhanced by [RFC1123], Section 2.1
 * <subdomain>       = <label> | <subdomain> "." <label>
 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
 *                     Labels must be 63 characters or less.
 *                     'let-dig' not 'letter' in the first char, per RFC1123
 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
 * <let-dig-hyp>     = <let-dig> | "-"
 * <let-dig>         = <letter> | <digit>
 * <letter>          = any one of the 52 alphabetic characters A through Z in
 *                     upper case and a through z in lower case
 * <digit>           = any one of the ten digits 0 through 9
 *
 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
 *
 * > (Note that a leading %x2E ("."), if present, is ignored even though that
 * character is not permitted, but a trailing %x2E ("."), if present, will
 * cause the user agent to ignore the attribute.)
 */ var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
/**
 * RegExp to match path-value in RFC 6265 sec 4.1.1
 *
 * path-value        = <any CHAR except CTLs or ";">
 * CHAR              = %x01-7F
 *                     ; defined in RFC 5234 appendix B.1
 */ var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [opt]
 * @return {object}
 * @public
 */ function parse(str, opt) {
    if (typeof str !== 'string') {
        throw new TypeError('argument str must be a string');
    }
    var obj = {};
    var len = str.length;
    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
    if (len < 2) return obj;
    var dec = opt && opt.decode || decode;
    var index = 0;
    var eqIdx = 0;
    var endIdx = 0;
    do {
        eqIdx = str.indexOf('=', index);
        if (eqIdx === -1) break; // No more cookie pairs.
        endIdx = str.indexOf(';', index);
        if (endIdx === -1) {
            endIdx = len;
        } else if (eqIdx > endIdx) {
            // backtrack on prior semicolon
            index = str.lastIndexOf(';', eqIdx - 1) + 1;
            continue;
        }
        var keyStartIdx = startIndex(str, index, eqIdx);
        var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
        var key = str.slice(keyStartIdx, keyEndIdx);
        // only assign once
        if (!__hasOwnProperty.call(obj, key)) {
            var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
            var valEndIdx = endIndex(str, endIdx, valStartIdx);
            if (str.charCodeAt(valStartIdx) === 0x22 /* " */  && str.charCodeAt(valEndIdx - 1) === 0x22 /* " */ ) {
                valStartIdx++;
                valEndIdx--;
            }
            var val = str.slice(valStartIdx, valEndIdx);
            obj[key] = tryDecode(val, dec);
        }
        index = endIdx + 1;
    }while (index < len)
    return obj;
}
function startIndex(str, index, max) {
    do {
        var code = str.charCodeAt(index);
        if (code !== 0x20 /*   */  && code !== 0x09 /* \t */ ) return index;
    }while (++index < max)
    return max;
}
function endIndex(str, index, min) {
    while(index > min){
        var code = str.charCodeAt(--index);
        if (code !== 0x20 /*   */  && code !== 0x09 /* \t */ ) return index + 1;
    }
    return min;
}
/**
 * Serialize data into a cookie header.
 *
 * Serialize a name value pair into a cookie string suitable for
 * http headers. An optional options object specifies cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [opt]
 * @return {string}
 * @public
 */ function serialize(name, val, opt) {
    var enc = opt && opt.encode || encodeURIComponent;
    if (typeof enc !== 'function') {
        throw new TypeError('option encode is invalid');
    }
    if (!cookieNameRegExp.test(name)) {
        throw new TypeError('argument name is invalid');
    }
    var value = enc(val);
    if (!cookieValueRegExp.test(value)) {
        throw new TypeError('argument val is invalid');
    }
    var str = name + '=' + value;
    if (!opt) return str;
    if (null != opt.maxAge) {
        var maxAge = Math.floor(opt.maxAge);
        if (!isFinite(maxAge)) {
            throw new TypeError('option maxAge is invalid');
        }
        str += '; Max-Age=' + maxAge;
    }
    if (opt.domain) {
        if (!domainValueRegExp.test(opt.domain)) {
            throw new TypeError('option domain is invalid');
        }
        str += '; Domain=' + opt.domain;
    }
    if (opt.path) {
        if (!pathValueRegExp.test(opt.path)) {
            throw new TypeError('option path is invalid');
        }
        str += '; Path=' + opt.path;
    }
    if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
            throw new TypeError('option expires is invalid');
        }
        str += '; Expires=' + expires.toUTCString();
    }
    if (opt.httpOnly) {
        str += '; HttpOnly';
    }
    if (opt.secure) {
        str += '; Secure';
    }
    if (opt.partitioned) {
        str += '; Partitioned';
    }
    if (opt.priority) {
        var priority = typeof opt.priority === 'string' ? opt.priority.toLowerCase() : opt.priority;
        switch(priority){
            case 'low':
                str += '; Priority=Low';
                break;
            case 'medium':
                str += '; Priority=Medium';
                break;
            case 'high':
                str += '; Priority=High';
                break;
            default:
                throw new TypeError('option priority is invalid');
        }
    }
    if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch(sameSite){
            case true:
                str += '; SameSite=Strict';
                break;
            case 'lax':
                str += '; SameSite=Lax';
                break;
            case 'strict':
                str += '; SameSite=Strict';
                break;
            case 'none':
                str += '; SameSite=None';
                break;
            default:
                throw new TypeError('option sameSite is invalid');
        }
    }
    return str;
}
/**
 * URL-decode string value. Optimized to skip native call when no %.
 *
 * @param {string} str
 * @returns {string}
 */ function decode(str) {
    return str.indexOf('%') !== -1 ? decodeURIComponent(str) : str;
}
/**
 * Determine if value is a Date.
 *
 * @param {*} val
 * @private
 */ function isDate(val) {
    return __toString.call(val) === '[object Date]';
}
/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */ function tryDecode(str, decode) {
    try {
        return decode(str);
    } catch (e) {
        return str;
    }
}
}}),
"[project]/node_modules/vary/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module exports.
 */ module.exports = vary;
module.exports.append = append;
/**
 * RegExp to match field-name in RFC 7230 sec 3.2
 *
 * field-name    = token
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 */ var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
/**
 * Append a field to a vary header.
 *
 * @param {String} header
 * @param {String|Array} field
 * @return {String}
 * @public
 */ function append(header, field) {
    if (typeof header !== 'string') {
        throw new TypeError('header argument is required');
    }
    if (!field) {
        throw new TypeError('field argument is required');
    }
    // get fields array
    var fields = !Array.isArray(field) ? parse(String(field)) : field;
    // assert on invalid field names
    for(var j = 0; j < fields.length; j++){
        if (!FIELD_NAME_REGEXP.test(fields[j])) {
            throw new TypeError('field argument contains an invalid header name');
        }
    }
    // existing, unspecified vary
    if (header === '*') {
        return header;
    }
    // enumerate current values
    var val = header;
    var vals = parse(header.toLowerCase());
    // unspecified vary
    if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
        return '*';
    }
    for(var i = 0; i < fields.length; i++){
        var fld = fields[i].toLowerCase();
        // append value (case-preserving)
        if (vals.indexOf(fld) === -1) {
            vals.push(fld);
            val = val ? val + ', ' + fields[i] : fields[i];
        }
    }
    return val;
}
/**
 * Parse a vary header into an array.
 *
 * @param {String} header
 * @return {Array}
 * @private
 */ function parse(header) {
    var end = 0;
    var list = [];
    var start = 0;
    // gather tokens
    for(var i = 0, len = header.length; i < len; i++){
        switch(header.charCodeAt(i)){
            case 0x20:
                /*   */ if (start === end) {
                    start = end = i + 1;
                }
                break;
            case 0x2c:
                /* , */ list.push(header.substring(start, end));
                start = end = i + 1;
                break;
            default:
                end = i + 1;
                break;
        }
    }
    // final token
    list.push(header.substring(start, end));
    return list;
}
/**
 * Mark that a request is varied on a header field.
 *
 * @param {Object} res
 * @param {String|Array} field
 * @public
 */ function vary(res, field) {
    if (!res || !res.getHeader || !res.setHeader) {
        // quack quack
        throw new TypeError('res argument is required');
    }
    // get existing header
    var val = res.getHeader('Vary') || '';
    var header = Array.isArray(val) ? val.join(', ') : String(val);
    // set new header
    if (val = append(header, field)) {
        res.setHeader('Vary', val);
    }
}
}}),
"[project]/node_modules/data-uri-to-buffer/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Returns a `Buffer` instance from the given data URI `uri`.
 *
 * @param {String} uri Data URI to turn into a Buffer instance
 * @returns {Buffer} Buffer instance from Data URI
 * @api public
 */ __turbopack_context__.s({
    "dataUriToBuffer": (()=>dataUriToBuffer),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
function dataUriToBuffer(uri) {
    if (!/^data:/i.test(uri)) {
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
    }
    // strip newlines
    uri = uri.replace(/\r?\n/g, '');
    // split the URI up into the "metadata" and the "data" portions
    const firstComma = uri.indexOf(',');
    if (firstComma === -1 || firstComma <= 4) {
        throw new TypeError('malformed data: URI');
    }
    // remove the "data:" scheme and parse the metadata
    const meta = uri.substring(5, firstComma).split(';');
    let charset = '';
    let base64 = false;
    const type = meta[0] || 'text/plain';
    let typeFull = type;
    for(let i = 1; i < meta.length; i++){
        if (meta[i] === 'base64') {
            base64 = true;
        } else if (meta[i]) {
            typeFull += `;${meta[i]}`;
            if (meta[i].indexOf('charset=') === 0) {
                charset = meta[i].substring(8);
            }
        }
    }
    // defaults to US-ASCII only if type is not provided
    if (!meta[0] && !charset.length) {
        typeFull += ';charset=US-ASCII';
        charset = 'US-ASCII';
    }
    // get the encoded data portion and decode URI-encoded chars
    const encoding = base64 ? 'base64' : 'ascii';
    const data = unescape(uri.substring(firstComma + 1));
    const buffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(data, encoding);
    // set `.type` and `.typeFull` properties to MIME type
    buffer.type = type;
    buffer.typeFull = typeFull;
    // set the `.charset` property
    buffer.charset = charset;
    return buffer;
}
const __TURBOPACK__default__export__ = dataUriToBuffer;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/fetch-blob/streams.cjs [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* c8 ignore start */ // 64 KiB (same size chrome slice theirs blob into Uint8array's)
const POOL_SIZE = 65536;
if (!globalThis.ReadableStream) {
    // `node:stream/web` got introduced in v16.5.0 as experimental
    // and it's preferred over the polyfilled version. So we also
    // suppress the warning that gets emitted by NodeJS for using it.
    try {
        const process = __turbopack_context__.r("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
        const { emitWarning } = process;
        try {
            process.emitWarning = ()=>{};
            Object.assign(globalThis, (()=>{
                const e = new Error("Cannot find module 'node:stream/web': Unsupported external type Url for commonjs reference");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })());
            process.emitWarning = emitWarning;
        } catch (error) {
            process.emitWarning = emitWarning;
            throw error;
        }
    } catch (error) {
        // fallback to polyfill implementation
        Object.assign(globalThis, __turbopack_context__.r("[project]/node_modules/web-streams-polyfill/dist/ponyfill.es2018.js [app-client] (ecmascript)"));
    }
}
try {
    // Don't use node: prefix for this, require+node: is not supported until node v14.14
    // Only `import()` can use prefix in 12.20 and later
    const { Blob } = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
    if (Blob && !Blob.prototype.stream) {
        Blob.prototype.stream = function name(params) {
            let position = 0;
            const blob = this;
            return new ReadableStream({
                type: 'bytes',
                async pull (ctrl) {
                    const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE));
                    const buffer = await chunk.arrayBuffer();
                    position += buffer.byteLength;
                    ctrl.enqueue(new Uint8Array(buffer));
                    if (position === blob.size) {
                        ctrl.close();
                    }
                }
            });
        };
    }
} catch (error) {} /* c8 ignore end */ 
}}),
"[project]/node_modules/fetch-blob/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ // TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)
// Node has recently added whatwg stream into core
__turbopack_context__.s({
    "Blob": (()=>Blob),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$streams$2e$cjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fetch-blob/streams.cjs [app-client] (ecmascript)");
;
// 64 KiB (same size chrome slice theirs blob into Uint8array's)
const POOL_SIZE = 65536;
/** @param {(Blob | Uint8Array)[]} parts */ async function* toIterator(parts, clone = true) {
    for (const part of parts){
        if ('stream' in part) {
            yield* part.stream();
        } else if (ArrayBuffer.isView(part)) {
            if (clone) {
                let position = part.byteOffset;
                const end = part.byteOffset + part.byteLength;
                while(position !== end){
                    const size = Math.min(end - position, POOL_SIZE);
                    const chunk = part.buffer.slice(position, position + size);
                    position += chunk.byteLength;
                    yield new Uint8Array(chunk);
                }
            } else {
                yield part;
            }
        /* c8 ignore next 10 */ } else {
            // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)
            let position = 0, b = part;
            while(position !== b.size){
                const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));
                const buffer = await chunk.arrayBuffer();
                position += buffer.byteLength;
                yield new Uint8Array(buffer);
            }
        }
    }
}
const _Blob = class Blob {
    /** @type {Array.<(Blob|Uint8Array)>} */ #parts = [];
    #type = '';
    #size = 0;
    #endings = 'transparent';
    /**
   * The Blob() constructor returns a new Blob object. The content
   * of the blob consists of the concatenation of the values given
   * in the parameter array.
   *
   * @param {*} blobParts
   * @param {{ type?: string, endings?: string }} [options]
   */ constructor(blobParts = [], options = {}){
        if (typeof blobParts !== 'object' || blobParts === null) {
            throw new TypeError('Failed to construct \'Blob\': The provided value cannot be converted to a sequence.');
        }
        if (typeof blobParts[Symbol.iterator] !== 'function') {
            throw new TypeError('Failed to construct \'Blob\': The object must have a callable @@iterator property.');
        }
        if (typeof options !== 'object' && typeof options !== 'function') {
            throw new TypeError('Failed to construct \'Blob\': parameter 2 cannot convert to dictionary.');
        }
        if (options === null) options = {};
        const encoder = new TextEncoder();
        for (const element of blobParts){
            let part;
            if (ArrayBuffer.isView(element)) {
                part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
            } else if (element instanceof ArrayBuffer) {
                part = new Uint8Array(element.slice(0));
            } else if (element instanceof Blob) {
                part = element;
            } else {
                part = encoder.encode(`${element}`);
            }
            this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
            this.#parts.push(part);
        }
        this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`;
        const type = options.type === undefined ? '' : String(options.type);
        this.#type = /^[\x20-\x7E]*$/.test(type) ? type : '';
    }
    /**
   * The Blob interface's size property returns the
   * size of the Blob in bytes.
   */ get size() {
        return this.#size;
    }
    /**
   * The type property of a Blob object returns the MIME type of the file.
   */ get type() {
        return this.#type;
    }
    /**
   * The text() method in the Blob interface returns a Promise
   * that resolves with a string containing the contents of
   * the blob, interpreted as UTF-8.
   *
   * @return {Promise<string>}
   */ async text() {
        // More optimized than using this.arrayBuffer()
        // that requires twice as much ram
        const decoder = new TextDecoder();
        let str = '';
        for await (const part of toIterator(this.#parts, false)){
            str += decoder.decode(part, {
                stream: true
            });
        }
        // Remaining
        str += decoder.decode();
        return str;
    }
    /**
   * The arrayBuffer() method in the Blob interface returns a
   * Promise that resolves with the contents of the blob as
   * binary data contained in an ArrayBuffer.
   *
   * @return {Promise<ArrayBuffer>}
   */ async arrayBuffer() {
        // Easier way... Just a unnecessary overhead
        // const view = new Uint8Array(this.size);
        // await this.stream().getReader({mode: 'byob'}).read(view);
        // return view.buffer;
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)){
            data.set(chunk, offset);
            offset += chunk.length;
        }
        return data.buffer;
    }
    stream() {
        const it = toIterator(this.#parts, true);
        return new globalThis.ReadableStream({
            // @ts-ignore
            type: 'bytes',
            async pull (ctrl) {
                const chunk = await it.next();
                chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
            },
            async cancel () {
                await it.return();
            }
        });
    }
    /**
   * The Blob interface's slice() method creates and returns a
   * new Blob object which contains data from a subset of the
   * blob on which it's called.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @param {string} [type]
   */ slice(start = 0, end = this.size, type = '') {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts){
            // don't add the overflow to new blobParts
            if (added >= span) {
                break;
            }
            const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;
            if (relativeStart && size <= relativeStart) {
                // Skip the beginning and change the relative
                // start & end position as we skip the unwanted parts
                relativeStart -= size;
                relativeEnd -= size;
            } else {
                let chunk;
                if (ArrayBuffer.isView(part)) {
                    chunk = part.subarray(relativeStart, Math.min(size, relativeEnd));
                    added += chunk.byteLength;
                } else {
                    chunk = part.slice(relativeStart, Math.min(size, relativeEnd));
                    added += chunk.size;
                }
                relativeEnd -= size;
                blobParts.push(chunk);
                relativeStart = 0 // All next sequential parts should start at 0
                ;
            }
        }
        const blob = new Blob([], {
            type: String(type).toLowerCase()
        });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
    }
    get [Symbol.toStringTag]() {
        return 'Blob';
    }
    static [Symbol.hasInstance](object) {
        return object && typeof object === 'object' && typeof object.constructor === 'function' && (typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
};
Object.defineProperties(_Blob.prototype, {
    size: {
        enumerable: true
    },
    type: {
        enumerable: true
    },
    slice: {
        enumerable: true
    }
});
const Blob = _Blob;
const __TURBOPACK__default__export__ = Blob;
}}),
"[project]/node_modules/fetch-blob/file.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "File": (()=>File),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fetch-blob/index.js [app-client] (ecmascript)");
;
const _File = class File extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    #lastModified = 0;
    #name = '';
    /**
   * @param {*[]} fileBits
   * @param {string} fileName
   * @param {{lastModified?: number, type?: string}} options
   */ // @ts-ignore
    constructor(fileBits, fileName, options = {}){
        if (arguments.length < 2) {
            throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options);
        if (options === null) options = {};
        // Simulate WebIDL type casting for NaN value in lastModified option.
        const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
            this.#lastModified = lastModified;
        }
        this.#name = String(fileName);
    }
    get name() {
        return this.#name;
    }
    get lastModified() {
        return this.#lastModified;
    }
    get [Symbol.toStringTag]() {
        return 'File';
    }
    static [Symbol.hasInstance](object) {
        return !!object && object instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] && /^(File)$/.test(object[Symbol.toStringTag]);
    }
};
const File = _File;
const __TURBOPACK__default__export__ = File;
}}),
"[project]/node_modules/fetch-blob/from.js [app-client] (ecmascript) <locals>": (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/fetch-blob/from.js [app-client] (ecmascript) <locals>\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:fs)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/fetch-blob/from.js [app-client] (ecmascript) <locals>\n- Execution of <EcmascriptModuleLocalsChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:fs)");

}}),
"[project]/node_modules/fetch-blob/from.js [app-client] (ecmascript) <module evaluation>": (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/fetch-blob/from.js [app-client] (ecmascript) <module evaluation>\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:fs)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/fetch-blob/from.js [app-client] (ecmascript) <module evaluation>\n- Execution of <EcmascriptModuleFacadeChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- the chunking context (unknown) does not support external modules (request: node:fs)");

}}),
"[project]/node_modules/fetch-blob/index.js [app-client] (ecmascript) <export default as Blob>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Blob": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fetch-blob/index.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/fetch-blob/file.js [app-client] (ecmascript) <export default as File>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "File": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$file$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$file$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fetch-blob/file.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/formdata-polyfill/esm.min.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ __turbopack_context__.s({
    "File": (()=>File),
    "FormData": (()=>FormData),
    "formDataToBlob": (()=>formDataToBlob)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fetch-blob/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$file$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fetch-blob/file.js [app-client] (ecmascript)");
;
;
var { toStringTag: t, iterator: i, hasInstance: h } = Symbol, r = Math.random, m = 'append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(','), f = (a, b, c)=>(a += '', /^(Blob|File)$/.test(b && b[t]) ? [
        (c = c !== void 0 ? c + '' : b[t] == 'File' ? b.name : 'blob', a),
        b.name !== c || b[t] == 'blob' ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$file$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]([
            b
        ], c, b) : b
    ] : [
        a,
        b + ''
    ]), e = (c, f)=>(f ? c : c.replace(/\r?\n|\r/g, '\r\n')).replace(/\n/g, '%0A').replace(/\r/g, '%0D').replace(/"/g, '%22'), x = (n, a, e)=>{
    if (a.length < e) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`);
    }
};
const File = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$file$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
const FormData = class FormData {
    #d = [];
    constructor(...a){
        if (a.length) throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
    }
    get [t]() {
        return 'FormData';
    }
    [i]() {
        return this.entries();
    }
    static [h](o) {
        return o && typeof o === 'object' && o[t] === 'FormData' && !m.some((m)=>typeof o[m] != 'function');
    }
    append(...a) {
        x('append', arguments, 2);
        this.#d.push(f(...a));
    }
    delete(a) {
        x('delete', arguments, 1);
        a += '';
        this.#d = this.#d.filter(([b])=>b !== a);
    }
    get(a) {
        x('get', arguments, 1);
        a += '';
        for(var b = this.#d, l = b.length, c = 0; c < l; c++)if (b[c][0] === a) return b[c][1];
        return null;
    }
    getAll(a, b) {
        x('getAll', arguments, 1);
        b = [];
        a += '';
        this.#d.forEach((c)=>c[0] === a && b.push(c[1]));
        return b;
    }
    has(a) {
        x('has', arguments, 1);
        a += '';
        return this.#d.some((b)=>b[0] === a);
    }
    forEach(a, b) {
        x('forEach', arguments, 1);
        for (var [c, d] of this)a.call(b, d, c, this);
    }
    set(...a) {
        x('set', arguments, 2);
        var b = [], c = !0;
        a = f(...a);
        this.#d.forEach((d)=>{
            d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        });
        c && b.push(a);
        this.#d = b;
    }
    *entries() {
        yield* this.#d;
    }
    *keys() {
        for (var [a] of this)yield a;
    }
    *values() {
        for (var [, a] of this)yield a;
    }
};
function formDataToBlob(F, B = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
    var b = `${r()}${r()}`.replace(/\./g, '').slice(-28).padStart(32, '-'), c = [], p = `--${b}\r\nContent-Disposition: form-data; name="`;
    F.forEach((v, n)=>typeof v == 'string' ? c.push(p + e(n) + `"\r\n\r\n${v.replace(/\r(?!\n)|(?<!\r)\n/g, '\r\n')}\r\n`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r\nContent-Type: ${v.type || "application/octet-stream"}\r\n\r\n`, v, '\r\n'));
    c.push(`--${b}--`);
    return new B(c, {
        type: "multipart/form-data; boundary=" + b
    });
}
}}),
"[project]/node_modules/node-domexception/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ if (!globalThis.DOMException) {
    try {
        const { MessageChannel } = (()=>{
            const e = new Error("Cannot find module 'worker_threads'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })(), port = new MessageChannel().port1, ab = new ArrayBuffer();
        port.postMessage(ab, [
            ab,
            ab
        ]);
    } catch (err) {
        err.constructor.name === 'DOMException' && (globalThis.DOMException = err.constructor);
    }
}
module.exports = globalThis.DOMException;
}}),
"[project]/node_modules/node-fetch/src/errors/base.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "FetchBaseError": (()=>FetchBaseError)
});
class FetchBaseError extends Error {
    constructor(message, type){
        super(message);
        // Hide custom error implementation details from end-users
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
    }
    get name() {
        return this.constructor.name;
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
}
}}),
"[project]/node_modules/node-fetch/src/errors/fetch-error.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "FetchError": (()=>FetchError)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/errors/base.js [app-client] (ecmascript)");
;
class FetchError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FetchBaseError"] {
    /**
	 * @param  {string} message -      Error message for human
	 * @param  {string} [type] -        Error type for machine
	 * @param  {SystemError} [systemError] - For Node.js system error
	 */ constructor(message, type, systemError){
        super(message, type);
        // When err.type is `system`, err.erroredSysCall contains system error and err.code contains system error code
        if (systemError) {
            // eslint-disable-next-line no-multi-assign
            this.code = this.errno = systemError.code;
            this.erroredSysCall = systemError.syscall;
        }
    }
}
}}),
"[project]/node_modules/node-fetch/src/utils/is.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Is.js
 *
 * Object type checks.
 */ __turbopack_context__.s({
    "isAbortSignal": (()=>isAbortSignal),
    "isBlob": (()=>isBlob),
    "isDomainOrSubdomain": (()=>isDomainOrSubdomain),
    "isSameProtocol": (()=>isSameProtocol),
    "isURLSearchParameters": (()=>isURLSearchParameters)
});
const NAME = Symbol.toStringTag;
const isURLSearchParameters = (object)=>{
    return typeof object === 'object' && typeof object.append === 'function' && typeof object.delete === 'function' && typeof object.get === 'function' && typeof object.getAll === 'function' && typeof object.has === 'function' && typeof object.set === 'function' && typeof object.sort === 'function' && object[NAME] === 'URLSearchParams';
};
const isBlob = (object)=>{
    return object && typeof object === 'object' && typeof object.arrayBuffer === 'function' && typeof object.type === 'string' && typeof object.stream === 'function' && typeof object.constructor === 'function' && /^(Blob|File)$/.test(object[NAME]);
};
const isAbortSignal = (object)=>{
    return typeof object === 'object' && (object[NAME] === 'AbortSignal' || object[NAME] === 'EventTarget');
};
const isDomainOrSubdomain = (destination, original)=>{
    const orig = new URL(original).hostname;
    const dest = new URL(destination).hostname;
    return orig === dest || orig.endsWith(`.${dest}`);
};
const isSameProtocol = (destination, original)=>{
    const orig = new URL(original).protocol;
    const dest = new URL(destination).protocol;
    return orig === dest;
};
}}),
"[project]/node_modules/node-fetch/src/body.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Body.js
 *
 * Body interface provides common methods for Request and Response
 */ __turbopack_context__.s({
    "clone": (()=>clone),
    "default": (()=>Body),
    "extractContentType": (()=>extractContentType),
    "getTotalBytes": (()=>getTotalBytes),
    "writeToStream": (()=>writeToStream)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fetch-blob/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formdata$2d$polyfill$2f$esm$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formdata-polyfill/esm.min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$fetch$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/errors/fetch-error.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/errors/base.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/utils/is.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const pipeline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["promisify"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].pipeline);
const INTERNALS = Symbol('Body internals');
class Body {
    constructor(body, { size = 0 } = {}){
        let boundary = null;
        if (body === null) {
            // Body is undefined or null
            body = null;
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isURLSearchParameters"])(body)) {
            // Body is a URLSearchParams
            body = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(body.toString());
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBlob"])(body)) {
        // Body is blob
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(body)) {
        // Body is Buffer
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].isAnyArrayBuffer(body)) {
            // Body is ArrayBuffer
            body = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(body);
        } else if (ArrayBuffer.isView(body)) {
            // Body is ArrayBufferView
            body = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
        // Body is stream
        } else if (body instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formdata$2d$polyfill$2f$esm$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FormData"]) {
            // Body is FormData
            body = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formdata$2d$polyfill$2f$esm$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formDataToBlob"])(body);
            boundary = body.type.split('=')[1];
        } else {
            // None of the above
            // coerce to string then buffer
            body = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(String(body));
        }
        let stream = body;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(body)) {
            stream = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Readable.from(body);
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBlob"])(body)) {
            stream = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Readable.from(body.stream());
        }
        this[INTERNALS] = {
            body,
            stream,
            boundary,
            disturbed: false,
            error: null
        };
        this.size = size;
        if (body instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
            body.on('error', (error_)=>{
                const error = error_ instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FetchBaseError"] ? error_ : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$fetch$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FetchError"](`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);
                this[INTERNALS].error = error;
            });
        }
    }
    get body() {
        return this[INTERNALS].stream;
    }
    get bodyUsed() {
        return this[INTERNALS].disturbed;
    }
    /**
	 * Decode response as ArrayBuffer
	 *
	 * @return  Promise
	 */ async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
    }
    async formData() {
        const ct = this.headers.get('content-type');
        if (ct.startsWith('application/x-www-form-urlencoded')) {
            const formData = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formdata$2d$polyfill$2f$esm$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FormData"]();
            const parameters = new URLSearchParams(await this.text());
            for (const [name, value] of parameters){
                formData.append(name, value);
            }
            return formData;
        }
        const { toFormData } = await __turbopack_context__.r("[project]/node_modules/node-fetch/src/utils/multipart-parser.js [app-client] (ecmascript, async loader)")(__turbopack_context__.i);
        return toFormData(this.body, ct);
    }
    /**
	 * Return raw response as Blob
	 *
	 * @return Promise
	 */ async blob() {
        const ct = this.headers && this.headers.get('content-type') || this[INTERNALS].body && this[INTERNALS].body.type || '';
        const buf = await this.arrayBuffer();
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]([
            buf
        ], {
            type: ct
        });
    }
    /**
	 * Decode response as json
	 *
	 * @return  Promise
	 */ async json() {
        const text = await this.text();
        return JSON.parse(text);
    }
    /**
	 * Decode response as text
	 *
	 * @return  Promise
	 */ async text() {
        const buffer = await consumeBody(this);
        return new TextDecoder().decode(buffer);
    }
    /**
	 * Decode response as buffer (non-spec api)
	 *
	 * @return  Promise
	 */ buffer() {
        return consumeBody(this);
    }
}
Body.prototype.buffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deprecate"])(Body.prototype.buffer, 'Please use \'response.arrayBuffer()\' instead of \'response.buffer()\'', 'node-fetch#buffer');
// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
    body: {
        enumerable: true
    },
    bodyUsed: {
        enumerable: true
    },
    arrayBuffer: {
        enumerable: true
    },
    blob: {
        enumerable: true
    },
    json: {
        enumerable: true
    },
    text: {
        enumerable: true
    },
    data: {
        get: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deprecate"])(()=>{}, 'data doesn\'t exist, use json(), text(), arrayBuffer(), or body instead', 'https://github.com/node-fetch/node-fetch/issues/1000 (response)')
    }
});
/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return Promise
 */ async function consumeBody(data) {
    if (data[INTERNALS].disturbed) {
        throw new TypeError(`body used already for: ${data.url}`);
    }
    data[INTERNALS].disturbed = true;
    if (data[INTERNALS].error) {
        throw data[INTERNALS].error;
    }
    const { body } = data;
    // Body is null
    if (body === null) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(0);
    }
    /* c8 ignore next 3 */ if (!(body instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(0);
    }
    // Body is stream
    // get ready to actually consume the body
    const accum = [];
    let accumBytes = 0;
    try {
        for await (const chunk of body){
            if (data.size > 0 && accumBytes + chunk.length > data.size) {
                const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$fetch$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FetchError"](`content size at ${data.url} over limit: ${data.size}`, 'max-size');
                body.destroy(error);
                throw error;
            }
            accumBytes += chunk.length;
            accum.push(chunk);
        }
    } catch (error) {
        const error_ = error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FetchBaseError"] ? error : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$fetch$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FetchError"](`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);
        throw error_;
    }
    if (body.readableEnded === true || body._readableState.ended === true) {
        try {
            if (accum.every((c)=>typeof c === 'string')) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(accum.join(''));
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(accum, accumBytes);
        } catch (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$fetch$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FetchError"](`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);
        }
    } else {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$fetch$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FetchError"](`Premature close of server response while trying to fetch ${data.url}`);
    }
}
const clone = (instance, highWaterMark)=>{
    let p1;
    let p2;
    let { body } = instance[INTERNALS];
    // Don't allow cloning a used body
    if (instance.bodyUsed) {
        throw new Error('cannot clone body after it is used');
    }
    // Check that body is a stream and not form-data object
    // note: we can't clone the form-data object without having it as a dependency
    if (body instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] && typeof body.getBoundary !== 'function') {
        // Tee instance body
        p1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PassThrough"]({
            highWaterMark
        });
        p2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PassThrough"]({
            highWaterMark
        });
        body.pipe(p1);
        body.pipe(p2);
        // Set instance body to teed body and return the other teed body
        instance[INTERNALS].stream = p1;
        body = p2;
    }
    return body;
};
const getNonSpecFormDataBoundary = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deprecate"])((body)=>body.getBoundary(), 'form-data doesn\'t follow the spec and requires special treatment. Use alternative package', 'https://github.com/node-fetch/node-fetch/issues/1167');
const extractContentType = (body, request)=>{
    // Body is null or undefined
    if (body === null) {
        return null;
    }
    // Body is string
    if (typeof body === 'string') {
        return 'text/plain;charset=UTF-8';
    }
    // Body is a URLSearchParams
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isURLSearchParameters"])(body)) {
        return 'application/x-www-form-urlencoded;charset=UTF-8';
    }
    // Body is blob
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBlob"])(body)) {
        return body.type || null;
    }
    // Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(body) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
    }
    if (body instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formdata$2d$polyfill$2f$esm$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FormData"]) {
        return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
    }
    // Detect form data input from form-data module
    if (body && typeof body.getBoundary === 'function') {
        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
    }
    // Body is stream - can't really do much about this
    if (body instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
        return null;
    }
    // Body constructor defaults other things to string
    return 'text/plain;charset=UTF-8';
};
const getTotalBytes = (request)=>{
    const { body } = request[INTERNALS];
    // Body is null or undefined
    if (body === null) {
        return 0;
    }
    // Body is Blob
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBlob"])(body)) {
        return body.size;
    }
    // Body is Buffer
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(body)) {
        return body.length;
    }
    // Detect form data input from form-data module
    if (body && typeof body.getLengthSync === 'function') {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
    }
    // Body is stream
    return null;
};
const writeToStream = async (dest, { body })=>{
    if (body === null) {
        // Body is null
        dest.end();
    } else {
        // Body is stream
        await pipeline(body, dest);
    }
};
}}),
"[project]/node_modules/node-fetch/src/headers.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Headers.js
 *
 * Headers class offers convenient helpers
 */ __turbopack_context__.s({
    "default": (()=>Headers),
    "fromRawHeaders": (()=>fromRawHeaders)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$http$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/stream-http/index.js [app-client] (ecmascript)");
;
;
/* c8 ignore next 9 */ const validateHeaderName = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$http$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validateHeaderName === 'function' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$http$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validateHeaderName : (name)=>{
    if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(error, 'code', {
            value: 'ERR_INVALID_HTTP_TOKEN'
        });
        throw error;
    }
};
/* c8 ignore next 9 */ const validateHeaderValue = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$http$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validateHeaderValue === 'function' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$http$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validateHeaderValue : (name, value)=>{
    if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(error, 'code', {
            value: 'ERR_INVALID_CHAR'
        });
        throw error;
    }
};
class Headers extends URLSearchParams {
    /**
	 * Headers class
	 *
	 * @constructor
	 * @param {HeadersInit} [init] - Response headers
	 */ constructor(init){
        // Validate and normalize init object in [name, value(s)][]
        /** @type {string[][]} */ let result = [];
        if (init instanceof Headers) {
            const raw = init.raw();
            for (const [name, values] of Object.entries(raw)){
                result.push(...values.map((value)=>[
                        name,
                        value
                    ]));
            }
        } else if (init == null) {
        // No op
        } else if (typeof init === 'object' && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].isBoxedPrimitive(init)) {
            const method = init[Symbol.iterator];
            // eslint-disable-next-line no-eq-null, eqeqeq
            if (method == null) {
                // Record<ByteString, ByteString>
                result.push(...Object.entries(init));
            } else {
                if (typeof method !== 'function') {
                    throw new TypeError('Header pairs must be iterable');
                }
                // Sequence<sequence<ByteString>>
                // Note: per spec we have to first exhaust the lists then process them
                result = [
                    ...init
                ].map((pair)=>{
                    if (typeof pair !== 'object' || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].isBoxedPrimitive(pair)) {
                        throw new TypeError('Each header pair must be an iterable object');
                    }
                    return [
                        ...pair
                    ];
                }).map((pair)=>{
                    if (pair.length !== 2) {
                        throw new TypeError('Each header pair must be a name/value tuple');
                    }
                    return [
                        ...pair
                    ];
                });
            }
        } else {
            throw new TypeError('Failed to construct \'Headers\': The provided value is not of type \'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');
        }
        // Validate and lowercase
        result = result.length > 0 ? result.map(([name, value])=>{
            validateHeaderName(name);
            validateHeaderValue(name, String(value));
            return [
                String(name).toLowerCase(),
                String(value)
            ];
        }) : undefined;
        super(result);
        // Returning a Proxy that will lowercase key names, validate parameters and sort keys
        // eslint-disable-next-line no-constructor-return
        return new Proxy(this, {
            get (target, p, receiver) {
                switch(p){
                    case 'append':
                    case 'set':
                        return (name, value)=>{
                            validateHeaderName(name);
                            validateHeaderValue(name, String(value));
                            return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
                        };
                    case 'delete':
                    case 'has':
                    case 'getAll':
                        return (name)=>{
                            validateHeaderName(name);
                            return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
                        };
                    case 'keys':
                        return ()=>{
                            target.sort();
                            return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                        };
                    default:
                        return Reflect.get(target, p, receiver);
                }
            }
        });
    /* c8 ignore next */ }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    toString() {
        return Object.prototype.toString.call(this);
    }
    get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
            return null;
        }
        let value = values.join(', ');
        if (/^content-encoding$/i.test(name)) {
            value = value.toLowerCase();
        }
        return value;
    }
    forEach(callback, thisArg = undefined) {
        for (const name of this.keys()){
            Reflect.apply(callback, thisArg, [
                this.get(name),
                name,
                this
            ]);
        }
    }
    *values() {
        for (const name of this.keys()){
            yield this.get(name);
        }
    }
    /**
	 * @type {() => IterableIterator<[string, string]>}
	 */ *entries() {
        for (const name of this.keys()){
            yield [
                name,
                this.get(name)
            ];
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
	 * Node-fetch non-spec method
	 * returning all headers and their values as array
	 * @returns {Record<string, string[]>}
	 */ raw() {
        return [
            ...this.keys()
        ].reduce((result, key)=>{
            result[key] = this.getAll(key);
            return result;
        }, {});
    }
    /**
	 * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
	 */ [Symbol.for('nodejs.util.inspect.custom')]() {
        return [
            ...this.keys()
        ].reduce((result, key)=>{
            const values = this.getAll(key);
            // Http.request() only supports string as Host header.
            // This hack makes specifying custom Host header possible.
            if (key === 'host') {
                result[key] = values[0];
            } else {
                result[key] = values.length > 1 ? values : values[0];
            }
            return result;
        }, {});
    }
}
/**
 * Re-shaping object for Web IDL tests
 * Only need to do it for overridden methods
 */ Object.defineProperties(Headers.prototype, [
    'get',
    'entries',
    'forEach',
    'values'
].reduce((result, property)=>{
    result[property] = {
        enumerable: true
    };
    return result;
}, {}));
function fromRawHeaders(headers = []) {
    return new Headers(headers// Split into pairs
    .reduce((result, value, index, array)=>{
        if (index % 2 === 0) {
            result.push(array.slice(index, index + 2));
        }
        return result;
    }, []).filter(([name, value])=>{
        try {
            validateHeaderName(name);
            validateHeaderValue(name, String(value));
            return true;
        } catch  {
            return false;
        }
    }));
}
}}),
"[project]/node_modules/node-fetch/src/utils/is-redirect.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "isRedirect": (()=>isRedirect)
});
const redirectStatus = new Set([
    301,
    302,
    303,
    307,
    308
]);
const isRedirect = (code)=>{
    return redirectStatus.has(code);
};
}}),
"[project]/node_modules/node-fetch/src/response.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Response.js
 *
 * Response class provides content decoding
 */ __turbopack_context__.s({
    "default": (()=>Response)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$headers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/headers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$body$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/body.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2d$redirect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/utils/is-redirect.js [app-client] (ecmascript)");
;
;
;
const INTERNALS = Symbol('Response internals');
class Response extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$body$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(body = null, options = {}){
        super(body, options);
        // eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition
        const status = options.status != null ? options.status : 200;
        const headers = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$headers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](options.headers);
        if (body !== null && !headers.has('Content-Type')) {
            const contentType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$body$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extractContentType"])(body, this);
            if (contentType) {
                headers.append('Content-Type', contentType);
            }
        }
        this[INTERNALS] = {
            type: 'default',
            url: options.url,
            status,
            statusText: options.statusText || '',
            headers,
            counter: options.counter,
            highWaterMark: options.highWaterMark
        };
    }
    get type() {
        return this[INTERNALS].type;
    }
    get url() {
        return this[INTERNALS].url || '';
    }
    get status() {
        return this[INTERNALS].status;
    }
    /**
	 * Convenience property representing if the request ended normally
	 */ get ok() {
        return this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;
    }
    get redirected() {
        return this[INTERNALS].counter > 0;
    }
    get statusText() {
        return this[INTERNALS].statusText;
    }
    get headers() {
        return this[INTERNALS].headers;
    }
    get highWaterMark() {
        return this[INTERNALS].highWaterMark;
    }
    /**
	 * Clone this response
	 *
	 * @return  Response
	 */ clone() {
        return new Response((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$body$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this, this.highWaterMark), {
            type: this.type,
            url: this.url,
            status: this.status,
            statusText: this.statusText,
            headers: this.headers,
            ok: this.ok,
            redirected: this.redirected,
            size: this.size,
            highWaterMark: this.highWaterMark
        });
    }
    /**
	 * @param {string} url    The URL that the new response is to originate from.
	 * @param {number} status An optional status code for the response (e.g., 302.)
	 * @returns {Response}    A Response object.
	 */ static redirect(url, status = 302) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2d$redirect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isRedirect"])(status)) {
            throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response(null, {
            headers: {
                location: new URL(url).toString()
            },
            status
        });
    }
    static error() {
        const response = new Response(null, {
            status: 0,
            statusText: ''
        });
        response[INTERNALS].type = 'error';
        return response;
    }
    static json(data = undefined, init = {}) {
        const body = JSON.stringify(data);
        if (body === undefined) {
            throw new TypeError('data is not JSON serializable');
        }
        const headers = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$headers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](init && init.headers);
        if (!headers.has('content-type')) {
            headers.set('content-type', 'application/json');
        }
        return new Response(body, {
            ...init,
            headers
        });
    }
    get [Symbol.toStringTag]() {
        return 'Response';
    }
}
Object.defineProperties(Response.prototype, {
    type: {
        enumerable: true
    },
    url: {
        enumerable: true
    },
    status: {
        enumerable: true
    },
    ok: {
        enumerable: true
    },
    redirected: {
        enumerable: true
    },
    statusText: {
        enumerable: true
    },
    headers: {
        enumerable: true
    },
    clone: {
        enumerable: true
    }
});
}}),
"[project]/node_modules/node-fetch/src/utils/get-search.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getSearch": (()=>getSearch)
});
const getSearch = (parsedURL)=>{
    if (parsedURL.search) {
        return parsedURL.search;
    }
    const lastOffset = parsedURL.href.length - 1;
    const hash = parsedURL.hash || (parsedURL.href[lastOffset] === '#' ? '#' : '');
    return parsedURL.href[lastOffset - hash.length] === '?' ? '?' : '';
};
}}),
"[project]/node_modules/node-fetch/src/utils/referrer.js [app-client] (ecmascript)": (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/node-fetch/src/utils/referrer.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:net)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/node-fetch/src/utils/referrer.js [app-client] (ecmascript)\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:net)");

}}),
"[project]/node_modules/node-fetch/src/request.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Request.js
 *
 * Request class contains server only options
 *
 * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
 */ __turbopack_context__.s({
    "default": (()=>Request),
    "getNodeRequestOptions": (()=>getNodeRequestOptions)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$native$2d$url$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/native-url/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$headers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/headers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$body$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/body.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$get$2d$search$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/utils/get-search.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$referrer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/utils/referrer.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const INTERNALS = Symbol('Request internals');
/**
 * Check if `obj` is an instance of Request.
 *
 * @param  {*} object
 * @return {boolean}
 */ const isRequest = (object)=>{
    return typeof object === 'object' && typeof object[INTERNALS] === 'object';
};
const doBadDataWarn = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deprecate"])(()=>{}, '.data is not a valid RequestInit property, use .body instead', 'https://github.com/node-fetch/node-fetch/issues/1000 (request)');
class Request extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$body$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(input, init = {}){
        let parsedURL;
        // Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)
        if (isRequest(input)) {
            parsedURL = new URL(input.url);
        } else {
            parsedURL = new URL(input);
            input = {};
        }
        if (parsedURL.username !== '' || parsedURL.password !== '') {
            throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
        }
        let method = init.method || input.method || 'GET';
        if (/^(delete|get|head|options|post|put)$/i.test(method)) {
            method = method.toUpperCase();
        }
        if (!isRequest(init) && 'data' in init) {
            doBadDataWarn();
        }
        // eslint-disable-next-line no-eq-null, eqeqeq
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
            throw new TypeError('Request with GET/HEAD method cannot have body');
        }
        const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$body$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(input) : null;
        super(inputBody, {
            size: init.size || input.size || 0
        });
        const headers = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$headers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](init.headers || input.headers || {});
        if (inputBody !== null && !headers.has('Content-Type')) {
            const contentType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$body$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extractContentType"])(inputBody, this);
            if (contentType) {
                headers.set('Content-Type', contentType);
            }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ('signal' in init) {
            signal = init.signal;
        }
        // eslint-disable-next-line no-eq-null, eqeqeq
        if (signal != null && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAbortSignal"])(signal)) {
            throw new TypeError('Expected signal to be an instanceof AbortSignal or EventTarget');
        }
        // §5.4, Request constructor steps, step 15.1
        // eslint-disable-next-line no-eq-null, eqeqeq
        let referrer = init.referrer == null ? input.referrer : init.referrer;
        if (referrer === '') {
            // §5.4, Request constructor steps, step 15.2
            referrer = 'no-referrer';
        } else if (referrer) {
            // §5.4, Request constructor steps, step 15.3.1, 15.3.2
            const parsedReferrer = new URL(referrer);
            // §5.4, Request constructor steps, step 15.3.3, 15.3.4
            referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? 'client' : parsedReferrer;
        } else {
            referrer = undefined;
        }
        this[INTERNALS] = {
            method,
            redirect: init.redirect || input.redirect || 'follow',
            headers,
            parsedURL,
            signal,
            referrer
        };
        // Node-fetch-only options
        this.follow = init.follow === undefined ? input.follow === undefined ? 20 : input.follow : init.follow;
        this.compress = init.compress === undefined ? input.compress === undefined ? true : input.compress : init.compress;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
        this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;
        // §5.4, Request constructor steps, step 16.
        // Default is empty string per https://fetch.spec.whatwg.org/#concept-request-referrer-policy
        this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || '';
    }
    /** @returns {string} */ get method() {
        return this[INTERNALS].method;
    }
    /** @returns {string} */ get url() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$native$2d$url$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(this[INTERNALS].parsedURL);
    }
    /** @returns {Headers} */ get headers() {
        return this[INTERNALS].headers;
    }
    get redirect() {
        return this[INTERNALS].redirect;
    }
    /** @returns {AbortSignal} */ get signal() {
        return this[INTERNALS].signal;
    }
    // https://fetch.spec.whatwg.org/#dom-request-referrer
    get referrer() {
        if (this[INTERNALS].referrer === 'no-referrer') {
            return '';
        }
        if (this[INTERNALS].referrer === 'client') {
            return 'about:client';
        }
        if (this[INTERNALS].referrer) {
            return this[INTERNALS].referrer.toString();
        }
        return undefined;
    }
    get referrerPolicy() {
        return this[INTERNALS].referrerPolicy;
    }
    set referrerPolicy(referrerPolicy) {
        this[INTERNALS].referrerPolicy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$referrer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateReferrerPolicy"])(referrerPolicy);
    }
    /**
	 * Clone this request
	 *
	 * @return  Request
	 */ clone() {
        return new Request(this);
    }
    get [Symbol.toStringTag]() {
        return 'Request';
    }
}
Object.defineProperties(Request.prototype, {
    method: {
        enumerable: true
    },
    url: {
        enumerable: true
    },
    headers: {
        enumerable: true
    },
    redirect: {
        enumerable: true
    },
    clone: {
        enumerable: true
    },
    signal: {
        enumerable: true
    },
    referrer: {
        enumerable: true
    },
    referrerPolicy: {
        enumerable: true
    }
});
const getNodeRequestOptions = (request)=>{
    const { parsedURL } = request[INTERNALS];
    const headers = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$headers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](request[INTERNALS].headers);
    // Fetch step 1.3
    if (!headers.has('Accept')) {
        headers.set('Accept', '*/*');
    }
    // HTTP-network-or-cache fetch steps 2.4-2.7
    let contentLengthValue = null;
    if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = '0';
    }
    if (request.body !== null) {
        const totalBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$body$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTotalBytes"])(request);
        // Set Content-Length if totalBytes is a number (that is not NaN)
        if (typeof totalBytes === 'number' && !Number.isNaN(totalBytes)) {
            contentLengthValue = String(totalBytes);
        }
    }
    if (contentLengthValue) {
        headers.set('Content-Length', contentLengthValue);
    }
    // 4.1. Main fetch, step 2.6
    // > If request's referrer policy is the empty string, then set request's referrer policy to the
    // > default referrer policy.
    if (request.referrerPolicy === '') {
        request.referrerPolicy = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$referrer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_REFERRER_POLICY"];
    }
    // 4.1. Main fetch, step 2.7
    // > If request's referrer is not "no-referrer", set request's referrer to the result of invoking
    // > determine request's referrer.
    if (request.referrer && request.referrer !== 'no-referrer') {
        request[INTERNALS].referrer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$referrer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["determineRequestsReferrer"])(request);
    } else {
        request[INTERNALS].referrer = 'no-referrer';
    }
    // 4.5. HTTP-network-or-cache fetch, step 6.9
    // > If httpRequest's referrer is a URL, then append `Referer`/httpRequest's referrer, serialized
    // >  and isomorphic encoded, to httpRequest's header list.
    if (request[INTERNALS].referrer instanceof URL) {
        headers.set('Referer', request.referrer);
    }
    // HTTP-network-or-cache fetch step 2.11
    if (!headers.has('User-Agent')) {
        headers.set('User-Agent', 'node-fetch');
    }
    // HTTP-network-or-cache fetch step 2.15
    if (request.compress && !headers.has('Accept-Encoding')) {
        headers.set('Accept-Encoding', 'gzip, deflate, br');
    }
    let { agent } = request;
    if (typeof agent === 'function') {
        agent = agent(parsedURL);
    }
    // HTTP-network fetch step 4.2
    // chunked encoding is handled by Node.js
    const search = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$get$2d$search$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSearch"])(parsedURL);
    // Pass the full URL directly to request(), but overwrite the following
    // options:
    const options = {
        // Overwrite search to retain trailing ? (issue #776)
        path: parsedURL.pathname + search,
        // The following options are not expressed in the URL
        method: request.method,
        headers: headers[Symbol.for('nodejs.util.inspect.custom')](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
    };
    return {
        /** @type {URL} */ parsedURL,
        options
    };
};
}}),
"[project]/node_modules/node-fetch/src/errors/abort-error.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AbortError": (()=>AbortError)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/errors/base.js [app-client] (ecmascript)");
;
class AbortError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FetchBaseError"] {
    constructor(message, type = 'aborted'){
        super(message, type);
    }
}
}}),
"[project]/node_modules/node-fetch/src/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Index.js
 *
 * a request API compatible with window.fetch
 *
 * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
 */ __turbopack_context__.s({
    "default": (()=>fetch)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$http$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/stream-http/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$https$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/https-browserify/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$browserify$2d$zlib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/browserify-zlib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$data$2d$uri$2d$to$2d$buffer$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/data-uri-to-buffer/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$body$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/body.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/response.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$headers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/headers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/request.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$fetch$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/errors/fetch-error.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$abort$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/errors/abort-error.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2d$redirect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/utils/is-redirect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formdata$2d$polyfill$2f$esm$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formdata-polyfill/esm.min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$referrer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/utils/referrer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/fetch-blob/from.js [app-client] (ecmascript) <module evaluation>");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const supportedSchemas = new Set([
    'data:',
    'http:',
    'https:'
]);
async function fetch(url, options_) {
    return new Promise((resolve, reject)=>{
        // Build request object
        const request = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](url, options_);
        const { parsedURL, options } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNodeRequestOptions"])(request);
        if (!supportedSchemas.has(parsedURL.protocol)) {
            throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, '')}" is not supported.`);
        }
        if (parsedURL.protocol === 'data:') {
            const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$data$2d$uri$2d$to$2d$buffer$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(request.url);
            const response = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](data, {
                headers: {
                    'Content-Type': data.typeFull
                }
            });
            resolve(response);
            return;
        }
        // Wrap http.request into fetch
        const send = (parsedURL.protocol === 'https:' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$https$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$http$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]).request;
        const { signal } = request;
        let response = null;
        const abort = ()=>{
            const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$abort$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AbortError"]('The operation was aborted.');
            reject(error);
            if (request.body && request.body instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Readable) {
                request.body.destroy(error);
            }
            if (!response || !response.body) {
                return;
            }
            response.body.emit('error', error);
        };
        if (signal && signal.aborted) {
            abort();
            return;
        }
        const abortAndFinalize = ()=>{
            abort();
            finalize();
        };
        // Send request
        const request_ = send(parsedURL.toString(), options);
        if (signal) {
            signal.addEventListener('abort', abortAndFinalize);
        }
        const finalize = ()=>{
            request_.abort();
            if (signal) {
                signal.removeEventListener('abort', abortAndFinalize);
            }
        };
        request_.on('error', (error)=>{
            reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$fetch$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FetchError"](`request to ${request.url} failed, reason: ${error.message}`, 'system', error));
            finalize();
        });
        fixResponseChunkedTransferBadEnding(request_, (error)=>{
            if (response && response.body) {
                response.body.destroy(error);
            }
        });
        /* c8 ignore next 18 */ if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].version < 'v14') {
            // Before Node.js 14, pipeline() does not fully support async iterators and does not always
            // properly handle when the socket close/end events are out of order.
            request_.on('socket', (s)=>{
                let endedWithEventsCount;
                s.prependListener('end', ()=>{
                    endedWithEventsCount = s._eventsCount;
                });
                s.prependListener('close', (hadError)=>{
                    // if end happened before close but the socket didn't emit an error, do it now
                    if (response && endedWithEventsCount < s._eventsCount && !hadError) {
                        const error = new Error('Premature close');
                        error.code = 'ERR_STREAM_PREMATURE_CLOSE';
                        response.body.emit('error', error);
                    }
                });
            });
        }
        request_.on('response', (response_)=>{
            request_.setTimeout(0);
            const headers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$headers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromRawHeaders"])(response_.rawHeaders);
            // HTTP fetch step 5
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2d$redirect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isRedirect"])(response_.statusCode)) {
                // HTTP fetch step 5.2
                const location = headers.get('Location');
                // HTTP fetch step 5.3
                let locationURL = null;
                try {
                    locationURL = location === null ? null : new URL(location, request.url);
                } catch  {
                    // error here can only be invalid URL in Location: header
                    // do not throw when options.redirect == manual
                    // let the user extract the errorneous redirect URL
                    if (request.redirect !== 'manual') {
                        reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$fetch$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FetchError"](`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
                        finalize();
                        return;
                    }
                }
                // HTTP fetch step 5.5
                switch(request.redirect){
                    case 'error':
                        reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$fetch$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FetchError"](`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
                        finalize();
                        return;
                    case 'manual':
                        break;
                    case 'follow':
                        {
                            // HTTP-redirect fetch step 2
                            if (locationURL === null) {
                                break;
                            }
                            // HTTP-redirect fetch step 5
                            if (request.counter >= request.follow) {
                                reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$fetch$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FetchError"](`maximum redirect reached at: ${request.url}`, 'max-redirect'));
                                finalize();
                                return;
                            }
                            // HTTP-redirect fetch step 6 (counter increment)
                            // Create a new Request object.
                            const requestOptions = {
                                headers: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$headers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](request.headers),
                                follow: request.follow,
                                counter: request.counter + 1,
                                agent: request.agent,
                                compress: request.compress,
                                method: request.method,
                                body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$body$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(request),
                                signal: request.signal,
                                size: request.size,
                                referrer: request.referrer,
                                referrerPolicy: request.referrerPolicy
                            };
                            // when forwarding sensitive headers like "Authorization",
                            // "WWW-Authenticate", and "Cookie" to untrusted targets,
                            // headers will be ignored when following a redirect to a domain
                            // that is not a subdomain match or exact match of the initial domain.
                            // For example, a redirect from "foo.com" to either "foo.com" or "sub.foo.com"
                            // will forward the sensitive headers, but a redirect to "bar.com" will not.
                            // headers will also be ignored when following a redirect to a domain using
                            // a different protocol. For example, a redirect from "https://foo.com" to "http://foo.com"
                            // will not forward the sensitive headers
                            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDomainOrSubdomain"])(request.url, locationURL) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSameProtocol"])(request.url, locationURL)) {
                                for (const name of [
                                    'authorization',
                                    'www-authenticate',
                                    'cookie',
                                    'cookie2'
                                ]){
                                    requestOptions.headers.delete(name);
                                }
                            }
                            // HTTP-redirect fetch step 9
                            if (response_.statusCode !== 303 && request.body && options_.body instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Readable) {
                                reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$fetch$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FetchError"]('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
                                finalize();
                                return;
                            }
                            // HTTP-redirect fetch step 11
                            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === 'POST') {
                                requestOptions.method = 'GET';
                                requestOptions.body = undefined;
                                requestOptions.headers.delete('content-length');
                            }
                            // HTTP-redirect fetch step 14
                            const responseReferrerPolicy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$referrer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseReferrerPolicyFromHeader"])(headers);
                            if (responseReferrerPolicy) {
                                requestOptions.referrerPolicy = responseReferrerPolicy;
                            }
                            // HTTP-redirect fetch step 15
                            resolve(fetch(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](locationURL, requestOptions)));
                            finalize();
                            return;
                        }
                    default:
                        return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
                }
            }
            // Prepare response
            if (signal) {
                response_.once('end', ()=>{
                    signal.removeEventListener('abort', abortAndFinalize);
                });
            }
            let body = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipeline"])(response_, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PassThrough"](), (error)=>{
                if (error) {
                    reject(error);
                }
            });
            // see https://github.com/nodejs/node/pull/29376
            /* c8 ignore next 3 */ if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].version < 'v12.10') {
                response_.on('aborted', abortAndFinalize);
            }
            const responseOptions = {
                url: request.url,
                status: response_.statusCode,
                statusText: response_.statusMessage,
                headers,
                size: request.size,
                counter: request.counter,
                highWaterMark: request.highWaterMark
            };
            // HTTP-network fetch step 12.1.1.3
            const codings = headers.get('Content-Encoding');
            // HTTP-network fetch step 12.1.1.4: handle content codings
            // in following scenarios we ignore compression support
            // 1. compression support is disabled
            // 2. HEAD request
            // 3. no Content-Encoding header
            // 4. no content response (204)
            // 5. content not modified response (304)
            if (!request.compress || request.method === 'HEAD' || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
                response = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](body, responseOptions);
                resolve(response);
                return;
            }
            // For Node v6+
            // Be less strict when decoding compressed responses, since sometimes
            // servers send slightly invalid responses that are still accepted
            // by common browsers.
            // Always using Z_SYNC_FLUSH is what cURL does.
            const zlibOptions = {
                flush: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$browserify$2d$zlib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Z_SYNC_FLUSH,
                finishFlush: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$browserify$2d$zlib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Z_SYNC_FLUSH
            };
            // For gzip
            if (codings === 'gzip' || codings === 'x-gzip') {
                body = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipeline"])(body, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$browserify$2d$zlib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createGunzip(zlibOptions), (error)=>{
                    if (error) {
                        reject(error);
                    }
                });
                response = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](body, responseOptions);
                resolve(response);
                return;
            }
            // For deflate
            if (codings === 'deflate' || codings === 'x-deflate') {
                // Handle the infamous raw deflate response from old servers
                // a hack for old IIS and Apache servers
                const raw = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipeline"])(response_, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PassThrough"](), (error)=>{
                    if (error) {
                        reject(error);
                    }
                });
                raw.once('data', (chunk)=>{
                    // See http://stackoverflow.com/questions/37519828
                    if ((chunk[0] & 0x0F) === 0x08) {
                        body = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipeline"])(body, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$browserify$2d$zlib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createInflate(), (error)=>{
                            if (error) {
                                reject(error);
                            }
                        });
                    } else {
                        body = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipeline"])(body, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$browserify$2d$zlib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createInflateRaw(), (error)=>{
                            if (error) {
                                reject(error);
                            }
                        });
                    }
                    response = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](body, responseOptions);
                    resolve(response);
                });
                raw.once('end', ()=>{
                    // Some old IIS servers return zero-length OK deflate responses, so
                    // 'data' is never emitted. See https://github.com/node-fetch/node-fetch/pull/903
                    if (!response) {
                        response = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](body, responseOptions);
                        resolve(response);
                    }
                });
                return;
            }
            // For br
            if (codings === 'br') {
                body = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipeline"])(body, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$browserify$2d$zlib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createBrotliDecompress(), (error)=>{
                    if (error) {
                        reject(error);
                    }
                });
                response = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](body, responseOptions);
                resolve(response);
                return;
            }
            // Otherwise, use response as-is
            response = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](body, responseOptions);
            resolve(response);
        });
        // eslint-disable-next-line promise/prefer-await-to-then
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$body$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writeToStream"])(request_, request).catch(reject);
    });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
    const LAST_CHUNK = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from('0\r\n\r\n');
    let isChunkedTransfer = false;
    let properLastChunkReceived = false;
    let previousChunk;
    request.on('response', (response)=>{
        const { headers } = response;
        isChunkedTransfer = headers['transfer-encoding'] === 'chunked' && !headers['content-length'];
    });
    request.on('socket', (socket)=>{
        const onSocketClose = ()=>{
            if (isChunkedTransfer && !properLastChunkReceived) {
                const error = new Error('Premature close');
                error.code = 'ERR_STREAM_PREMATURE_CLOSE';
                errorCallback(error);
            }
        };
        const onData = (buf)=>{
            properLastChunkReceived = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].compare(buf.slice(-5), LAST_CHUNK) === 0;
            // Sometimes final 0-length chunk and end of message code are in separate packets
            if (!properLastChunkReceived && previousChunk) {
                properLastChunkReceived = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
            }
            previousChunk = buf;
        };
        socket.prependListener('close', onSocketClose);
        socket.on('data', onData);
        request.on('close', ()=>{
            socket.removeListener('close', onSocketClose);
            socket.removeListener('data', onData);
        });
    });
}
}}),
"[project]/node_modules/node-fetch/src/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$http$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/stream-http/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$https$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/https-browserify/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$browserify$2d$zlib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/browserify-zlib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$data$2d$uri$2d$to$2d$buffer$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/data-uri-to-buffer/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formdata$2d$polyfill$2f$esm$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formdata-polyfill/esm.min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/fetch-blob/from.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/node-fetch/src/index.js [app-client] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AbortError": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$abort$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AbortError"]),
    "Blob": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Blob$3e$__["Blob"]),
    "FetchError": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$fetch$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FetchError"]),
    "File": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$file$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__File$3e$__["File"]),
    "FormData": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formdata$2d$polyfill$2f$esm$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FormData"]),
    "Headers": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$headers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]),
    "Request": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]),
    "Response": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]),
    "blobFrom": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["blobFrom"]),
    "blobFromSync": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["blobFromSync"]),
    "default": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"]),
    "fileFrom": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fileFrom"]),
    "fileFromSync": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fileFromSync"]),
    "isRedirect": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2d$redirect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isRedirect"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/response.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$headers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/headers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/request.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$fetch$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/errors/fetch-error.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$errors$2f$abort$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/errors/abort-error.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$utils$2f$is$2d$redirect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/utils/is-redirect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formdata$2d$polyfill$2f$esm$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formdata-polyfill/esm.min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Blob$3e$__ = __turbopack_context__.i("[project]/node_modules/fetch-blob/index.js [app-client] (ecmascript) <export default as Blob>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$file$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__File$3e$__ = __turbopack_context__.i("[project]/node_modules/fetch-blob/file.js [app-client] (ecmascript) <export default as File>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fetch$2d$blob$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/fetch-blob/from.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/node-fetch/src/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AbortError": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["AbortError"]),
    "Blob": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["Blob"]),
    "FetchError": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["FetchError"]),
    "File": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["File"]),
    "FormData": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["FormData"]),
    "Headers": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["Headers"]),
    "Request": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["Request"]),
    "Response": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["Response"]),
    "blobFrom": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["blobFrom"]),
    "blobFromSync": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["blobFromSync"]),
    "default": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["default"]),
    "fileFrom": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["fileFrom"]),
    "fileFromSync": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["fileFromSync"]),
    "isRedirect": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["isRedirect"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/index.js [app-client] (ecmascript) <exports>");
}}),
"[project]/node_modules/cors/lib/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function() {
    'use strict';
    var assign = __turbopack_context__.r("[project]/node_modules/next/dist/build/polyfills/object-assign.js [app-client] (ecmascript)");
    var vary = __turbopack_context__.r("[project]/node_modules/vary/index.js [app-client] (ecmascript)");
    var defaults = {
        origin: '*',
        methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
        preflightContinue: false,
        optionsSuccessStatus: 204
    };
    function isString(s) {
        return typeof s === 'string' || s instanceof String;
    }
    function isOriginAllowed(origin, allowedOrigin) {
        if (Array.isArray(allowedOrigin)) {
            for(var i = 0; i < allowedOrigin.length; ++i){
                if (isOriginAllowed(origin, allowedOrigin[i])) {
                    return true;
                }
            }
            return false;
        } else if (isString(allowedOrigin)) {
            return origin === allowedOrigin;
        } else if (allowedOrigin instanceof RegExp) {
            return allowedOrigin.test(origin);
        } else {
            return !!allowedOrigin;
        }
    }
    function configureOrigin(options, req) {
        var requestOrigin = req.headers.origin, headers = [], isAllowed;
        if (!options.origin || options.origin === '*') {
            // allow any origin
            headers.push([
                {
                    key: 'Access-Control-Allow-Origin',
                    value: '*'
                }
            ]);
        } else if (isString(options.origin)) {
            // fixed origin
            headers.push([
                {
                    key: 'Access-Control-Allow-Origin',
                    value: options.origin
                }
            ]);
            headers.push([
                {
                    key: 'Vary',
                    value: 'Origin'
                }
            ]);
        } else {
            isAllowed = isOriginAllowed(requestOrigin, options.origin);
            // reflect origin
            headers.push([
                {
                    key: 'Access-Control-Allow-Origin',
                    value: isAllowed ? requestOrigin : false
                }
            ]);
            headers.push([
                {
                    key: 'Vary',
                    value: 'Origin'
                }
            ]);
        }
        return headers;
    }
    function configureMethods(options) {
        var methods = options.methods;
        if (methods.join) {
            methods = options.methods.join(','); // .methods is an array, so turn it into a string
        }
        return {
            key: 'Access-Control-Allow-Methods',
            value: methods
        };
    }
    function configureCredentials(options) {
        if (options.credentials === true) {
            return {
                key: 'Access-Control-Allow-Credentials',
                value: 'true'
            };
        }
        return null;
    }
    function configureAllowedHeaders(options, req) {
        var allowedHeaders = options.allowedHeaders || options.headers;
        var headers = [];
        if (!allowedHeaders) {
            allowedHeaders = req.headers['access-control-request-headers']; // .headers wasn't specified, so reflect the request headers
            headers.push([
                {
                    key: 'Vary',
                    value: 'Access-Control-Request-Headers'
                }
            ]);
        } else if (allowedHeaders.join) {
            allowedHeaders = allowedHeaders.join(','); // .headers is an array, so turn it into a string
        }
        if (allowedHeaders && allowedHeaders.length) {
            headers.push([
                {
                    key: 'Access-Control-Allow-Headers',
                    value: allowedHeaders
                }
            ]);
        }
        return headers;
    }
    function configureExposedHeaders(options) {
        var headers = options.exposedHeaders;
        if (!headers) {
            return null;
        } else if (headers.join) {
            headers = headers.join(','); // .headers is an array, so turn it into a string
        }
        if (headers && headers.length) {
            return {
                key: 'Access-Control-Expose-Headers',
                value: headers
            };
        }
        return null;
    }
    function configureMaxAge(options) {
        var maxAge = (typeof options.maxAge === 'number' || options.maxAge) && options.maxAge.toString();
        if (maxAge && maxAge.length) {
            return {
                key: 'Access-Control-Max-Age',
                value: maxAge
            };
        }
        return null;
    }
    function applyHeaders(headers, res) {
        for(var i = 0, n = headers.length; i < n; i++){
            var header = headers[i];
            if (header) {
                if (Array.isArray(header)) {
                    applyHeaders(header, res);
                } else if (header.key === 'Vary' && header.value) {
                    vary(res, header.value);
                } else if (header.value) {
                    res.setHeader(header.key, header.value);
                }
            }
        }
    }
    function cors(options, req, res, next) {
        var headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
        if (method === 'OPTIONS') {
            // preflight
            headers.push(configureOrigin(options, req));
            headers.push(configureCredentials(options, req));
            headers.push(configureMethods(options, req));
            headers.push(configureAllowedHeaders(options, req));
            headers.push(configureMaxAge(options, req));
            headers.push(configureExposedHeaders(options, req));
            applyHeaders(headers, res);
            if (options.preflightContinue) {
                next();
            } else {
                // Safari (and potentially other browsers) need content-length 0,
                //   for 204 or they just hang waiting for a body
                res.statusCode = options.optionsSuccessStatus;
                res.setHeader('Content-Length', '0');
                res.end();
            }
        } else {
            // actual response
            headers.push(configureOrigin(options, req));
            headers.push(configureCredentials(options, req));
            headers.push(configureExposedHeaders(options, req));
            applyHeaders(headers, res);
            next();
        }
    }
    function middlewareWrapper(o) {
        // if options are static (either via defaults or custom options passed in), wrap in a function
        var optionsCallback = null;
        if (typeof o === 'function') {
            optionsCallback = o;
        } else {
            optionsCallback = function(req, cb) {
                cb(null, o);
            };
        }
        return function corsMiddleware(req, res, next) {
            optionsCallback(req, function(err, options) {
                if (err) {
                    next(err);
                } else {
                    var corsOptions = assign({}, defaults, options);
                    var originCallback = null;
                    if (corsOptions.origin && typeof corsOptions.origin === 'function') {
                        originCallback = corsOptions.origin;
                    } else if (corsOptions.origin) {
                        originCallback = function(origin, cb) {
                            cb(null, corsOptions.origin);
                        };
                    }
                    if (originCallback) {
                        originCallback(req.headers.origin, function(err2, origin) {
                            if (err2 || !origin) {
                                next(err2);
                            } else {
                                corsOptions.origin = origin;
                                cors(corsOptions, req, res, next);
                            }
                        });
                    } else {
                        next();
                    }
                }
            });
        };
    }
    // can pass either an options hash, an options delegate, or nothing
    module.exports = middlewareWrapper;
})();
}}),
}]);

//# sourceMappingURL=node_modules_d36db0ac._.js.map